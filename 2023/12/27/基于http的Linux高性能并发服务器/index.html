<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="webserver学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="基于http的Linux高性能并发服务器">
<meta property="og:url" content="http://example.com/2023/12/27/%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="webserver学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\xzuiCU6kQVcQ4IWY.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\ZSfJN5pDVM15eQLV.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\PzBXwpDP7sNdsDG7.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\RSKrvQWQfVey2eUx.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\eh458JlvXVeL9FOz.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\hzLNWyEaPnwEEhH9.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/xRhJpX7WnfixzdBH.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\qQjp65wQuBmsjoIG.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\Y2mbSMK8OYm61UQo.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\RiNRoQkRjTmmOXmr.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\P2jRTAY9ediHLXrL.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\7qaAE9XAjUKBvMNH.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\fqW87jS0FAkBTJ1K.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\V6dLb8f0gs77LyFK.png!thumbnail">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240102210431160.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240102210455881.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240102210505511.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240104213546429.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240104213555696.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240106151123719.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240107140312527.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240107150011858.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240107165037885.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122133916483.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122134521469.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122145712118.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122145720598.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122145731979.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122145740191.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122145750661.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240122181743080.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240123131458814.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240123172019352.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240124110140579.png">
<meta property="og:image" content="d:\Blog\source\_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240124110239309.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240124224829624.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240128114213324.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240128114151163.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240131170102250.png">
<meta property="og:image" content="http://example.com/2023/12/27/%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/Blog/source_posts/webserver/image-20240210121918330.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240225123554728.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240225144746090.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240225155110793.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240225164741522.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240226220202694.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240226220315579.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240226232931128.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240226232940914.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240303162229015.png">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\discuss_1682656246568.jpeg">
<meta property="og:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\image-20240303130817904.png">
<meta property="article:published_time" content="2023-12-27T12:27:16.095Z">
<meta property="article:modified_time" content="2024-03-28T08:33:25.071Z">
<meta property="article:author" content="小白">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\Blog\source_posts\%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\xzuiCU6kQVcQ4IWY.png!thumbnail">

<link rel="canonical" href="http://example.com/2023/12/27/%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>基于http的Linux高性能并发服务器 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div><a target="_blank" rel="noopener" href="https://github.com/balgg" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/27/%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="小白">
      <meta itemprop="description" content="月下惊鸿影，疑是画中仙">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于http的Linux高性能并发服务器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-27 20:27:16" itemprop="dateCreated datePublished" datetime="2023-12-27T20:27:16+08:00">2023-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-28 16:33:25" itemprop="dateModified" datetime="2024-03-28T16:33:25+08:00">2024-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">项目总结</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>
            <div class="post-description">webserver学习笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章-Linux系统编程"><a href="#第一章-Linux系统编程" class="headerlink" title="第一章 Linux系统编程"></a>第一章 Linux系统编程</h1><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\xzuiCU6kQVcQ4IWY.png!thumbnail" alt="img">第一章 Linux系统编程入门</p>
<h2 id="1-gcc"><a href="#1-gcc" class="headerlink" title="1 gcc"></a>1 gcc</h2><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\ZSfJN5pDVM15eQLV.png!thumbnail" alt="img"><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\PzBXwpDP7sNdsDG7.png!thumbnail" alt="img">	-D：相当于在程序中使用 #define  <img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\RSKrvQWQfVey2eUx.png!thumbnail" alt="img"> </p>
<h2 id="2-静态库"><a href="#2-静态库" class="headerlink" title="2 静态库"></a>2 静态库</h2><p>静态库在程序的链接阶段被复制到了程序中<img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\eh458JlvXVeL9FOz.png!thumbnail" alt="img">初始状态：<img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\hzLNWyEaPnwEEhH9.png!thumbnail" alt="img">预处理、编译、汇编.c源文件进入src目录使用 -I 参数指定包含的头文件目录<img src="https://uploader.shimo.im/f/xRhJpX7WnfixzdBH.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img">链接静态库ar rcs libxxx.a xxx.o xxx.o移动到 lib 目录下<img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\qQjp65wQuBmsjoIG.png!thumbnail" alt="img">生成 .o 可执行文件需要指定头文件  -I .&#x2F;include需要指定静态库   -l  xxx  -L </p>
<p>生成app可执行文件<img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\Y2mbSMK8OYm61UQo.png!thumbnail" alt="img"> </p>
<h2 id="3-动态库"><a href="#3-动态库" class="headerlink" title="3 动态库"></a>3 动态库</h2><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\RiNRoQkRjTmmOXmr.png!thumbnail" alt="img">第一种方式：修改LD_LIBRARY_PATH临时添加：export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;home&#x2F;bal&#x2F;linux&#x2F;lesson06&#x2F;library&#x2F;lib永久配置：用户级别：vim .bashrc  最后一行添加上面的指令  source .bashrc系统级别：sudo vim &#x2F;etc&#x2F;profile最后一行添加上面的命令source &#x2F;etc&#x2F;profile</p>
<p>第二种方式：修改&#x2F;etc&#x2F;ld.so.cachesudo vim &#x2F;etc&#x2F;ld.so.conf添加动态库路径sudo ldconfig第三种方式：将动态库文件放在&#x2F;lib 或 &#x2F;usr&#x2F;lib目录下（不建议，里面有很多系统库文件）</p>
<h2 id="4-静态库和动态库对比"><a href="#4-静态库和动态库对比" class="headerlink" title="4 静态库和动态库对比"></a>4 静态库和动态库对比</h2><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\P2jRTAY9ediHLXrL.png!thumbnail" alt="img"></p>
<h2 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5 Makefile"></a>5 Makefile</h2><p>目标+依赖+命令<img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\7qaAE9XAjUKBvMNH.png!thumbnail" alt="img"><code>src=sub.o add.o mult.o div.o main.o target=app  $(target):$(src)        $(CC) $(src) -o $(target)  %.o:%.c        $(CC) -c $&lt; -o $@</code></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\fqW87jS0FAkBTJ1K.png!thumbnail" alt="img"> </p>
<p><code>target=app src=$(wildcard ./*.c) objs=$(patsubst %.c, %.o, $(src))  $(target):$(objs)        $(CC) $(objs) -o $(target)  %.o:%.c        $(CC) -c $&lt; -o $@</code></p>
<h2 id="6-GDB"><a href="#6-GDB" class="headerlink" title="6 GDB"></a>6 GDB</h2><p>为调试而编译时，关掉优化选项-o  ，打开调试选项-g，-Wall（警告）<code>gcc -g -Wall program.c -o program </code></p>
<p>启动和退出：gdb  可执行程序   quit</p>
<p>设置参数  set args 10 20   ； show args  <img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\V6dLb8f0gs77LyFK.png!thumbnail" alt="img">until ：需要循环里没有断点，且代码执行完7 文件io</p>
<p>可跨平台（不同平台使用不同的api）</p>
<p>程序执行后（成为进程）会为其创建独立的虚拟地址空间CPU的MMU会将虚拟地址空间映射到真实物理内存堆：从下往上（低地址-&gt;高地址）栈：从上往下（高地址-&gt;低地址）   </p>
<h2 id="7-文件io"><a href="#7-文件io" class="headerlink" title="7 文件io"></a>7 文件io</h2><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240102210431160.png" alt="image-20240102210431160"></p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 打开一个已经存在的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment">     参数：</span></span><br><span class="line"><span class="comment">            - pathname：要打开的文件路径</span></span><br><span class="line"><span class="comment">            - flags：对文件的操作权限设置还有其他的设置</span></span><br><span class="line"><span class="comment">            O_RDONLY,  O_WRONLY,  O_RDWR  </span></span><br><span class="line"><span class="comment">            (这三个设置是互斥的)</span></span><br><span class="line"><span class="comment">     返回值：返回一个新的文件描述符，如果调用失败，返回-1</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    void perror(const char *s);</span></span><br><span class="line"><span class="comment">    作用：打印errno对应的错误描述</span></span><br><span class="line"><span class="comment">    s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 创建一个新的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  ...读写操作</span></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    标准C库的函数</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Linux系统函数</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">            - offset：偏移量</span></span><br><span class="line"><span class="comment">            - whence:</span></span><br><span class="line"><span class="comment">                SEEK_SET</span></span><br><span class="line"><span class="comment">                    设置文件指针的偏移量（通过offset指定大小）：起始位置+offset</span></span><br><span class="line"><span class="comment">                SEEK_CUR</span></span><br><span class="line"><span class="comment">                    设置偏移量：当前位置 + offset</span></span><br><span class="line"><span class="comment">                SEEK_END</span></span><br><span class="line"><span class="comment">                    设置偏移量：文件结尾 + offset</span></span><br><span class="line"><span class="comment">        返回值：返回文件指针的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">        1.移动文件指针到文件头</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.获取当前文件指针的位置</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.获取文件长度</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment">        lseek(fd, 100, SEEK_END)</span></span><br><span class="line"><span class="comment">        注意：需要写一次数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="stat-lstat"><a href="#stat-lstat" class="headerlink" title="stat lstat"></a>stat lstat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.txt -&gt; b.txt 软链接</span></span><br><span class="line"><span class="comment">lstat获取a.txt的信息，stat获取b.txt的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>struct stat *statbuf 结构体</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240102210455881.png" alt="image-20240102210455881"></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240102210505511.png" alt="image-20240102210505511"></p>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int access(const char *pathname, int mode);</span></span><br><span class="line"><span class="comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 判断的文件路径</span></span><br><span class="line"><span class="comment">            - mode:</span></span><br><span class="line"><span class="comment">                R_OK: 判断是否有读权限</span></span><br><span class="line"><span class="comment">                W_OK: 判断是否有写权限</span></span><br><span class="line"><span class="comment">                X_OK: 判断是否有执行权限</span></span><br><span class="line"><span class="comment">                F_OK: 判断文件是否存在</span></span><br><span class="line"><span class="comment">        返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        修改文件的权限</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - mode:需要修改的权限值，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">        作用：缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - path: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - length: 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用：创建一个目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="chdir-getcwd"><a href="#chdir-getcwd" class="headerlink" title="chdir getcwd"></a>chdir getcwd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            path : 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span></span><br><span class="line"><span class="comment">            - size: 数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">           返回指向的一块内存(就是第一个参数buf)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="opendir-readdir-closedir"><a href="#opendir-readdir-closedir" class="headerlink" title="opendir readdir closedir"></a>opendir readdir closedir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型，理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup  dup2"></a>dup  dup2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup(int oldfd);</span></span><br><span class="line"><span class="comment">        作用：复制一个新的文件描述符</span></span><br><span class="line"><span class="comment">        fd=3, int fd1 = dup(fd),</span></span><br><span class="line"><span class="comment">        fd指向的是a.txt, fd1也指向a.txt</span></span><br><span class="line"><span class="comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符(例如fd1=4)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">	int dup2(int oldfd,int newfd);</span></span><br><span class="line"><span class="comment">	作用：重定向文件描述符（将newfd指向oldfd指向的文件）</span></span><br><span class="line"><span class="comment">	注：oldfd-&gt;a,txt  newfd-&gt;b.txt</span></span><br><span class="line"><span class="comment">	调用函数 int fd3 = dup2(oldfd,newfd)</span></span><br><span class="line"><span class="comment">    	newfd和b.txt先close 然后newfd-&gt;a.txt</span></span><br><span class="line"><span class="comment">    （oldfd必须是一个有效的文件描述符）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    返回值：fd3=newfd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int fcntl(int fd, int cmd, ...);</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        fd : 表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment">        cmd: 表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">                int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_SETFL : 设置文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span></span><br><span class="line"><span class="comment">              可选性：O_APPEND, O)NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                NONBLOK 设置成非阻塞</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        阻塞和非阻塞：描述的是函数调用的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="第二章-Linux多进程开发"><a href="#第二章-Linux多进程开发" class="headerlink" title="第二章 Linux多进程开发"></a>第二章 Linux多进程开发</h1><h2 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h2><p>程序是包含一系列信息的文件（信息用来描述如何创建进程）</p>
<p>进程是正在运行的程序的实例（程序不占用内存和cpu）</p>
<p>时间片由操作系统内核的调度程序分配给进程</p>
<p>（注：熟悉进程调度算法）</p>
<p>并行：同时执行</p>
<p>并发：交替执行</p>
<p>PCB进程控制块：task__struct 结构体</p>
<ul>
<li>​	进程id：pid_t类型，系统中每个进程唯一的id</li>
<li>​	进程状态：就绪、运行、挂起、停止等</li>
<li>​	进程切换时需要保存和恢复的cpu寄存器</li>
<li>​	描述虚拟地址空间的信息</li>
<li>​	描述控制终端的信息</li>
<li>​	当前工作目录</li>
<li>​	umask掩码</li>
<li>​	文件描述符表（包含很多指向file结构体的指针）</li>
<li>​	信号相关的信息</li>
<li>​	用户id和组id</li>
<li>​	会话（session）和进程组</li>
<li>​	进程可以使用的资源上限</li>
</ul>
<h2 id="2-2-进程状态转换"><a href="#2-2-进程状态转换" class="headerlink" title="2.2 进程状态转换"></a>2.2 进程状态转换</h2><p>三态：就绪、运行、阻塞</p>
<p>五态：新建、就绪、运行、阻塞、终止</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240104213546429.png" alt="image-20240104213546429"></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240104213555696.png" alt="image-20240104213555696"></p>
<ul>
<li>查看进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps aux / ajx</span><br><span class="line">a：显示终端上所有进程</span><br><span class="line">u：显示进程详细信息</span><br><span class="line">x：显示没有控制终端的进程</span><br><span class="line">j：列出与作业控制相关的信息</span><br></pre></td></tr></table></figure>

<ul>
<li>实时显示进程动态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">M 根据内存使用量排序 </span><br><span class="line">P 根据 CPU 占有率排序</span><br><span class="line">T 根据进程运行时间长短排序</span><br><span class="line">U 根据用户名来筛选进程</span><br><span class="line">K 输入指定的 PID 杀死进程</span><br></pre></td></tr></table></figure>

<ul>
<li>杀死进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br><span class="line">kill –l 列出所有信号</span><br><span class="line">kill –SIGKILL 进程ID</span><br><span class="line">kill -9 进程ID</span><br><span class="line">killall name 根据进程名杀死进程</span><br></pre></td></tr></table></figure>

<p>**◼ **每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p>◼ 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。</p>
<p>◼ 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。</p>
<p>◼ 进程号和进程组相关函数：</p>
<p>pid_t getpid(void);</p>
<p>pid_t getppid(void);</p>
<p>pid_t getpgid(pid_t pid);</p>
<h2 id="2-3-进程创建"><a href="#2-3-进程创建" class="headerlink" title="2.3 进程创建"></a>2.3 进程创建</h2><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t fork(void);</span><br><span class="line">	返回值：</span><br><span class="line">		成功：子进程中返回0，父进程中返回子进程ID</span><br><span class="line">		失败：返回-1</span><br><span class="line">	失败原因：</span><br><span class="line">		1、当前系统进程数已达上限，errno=EAGAIN</span><br><span class="line">		2、系统内存不足，errno=ENOMEM</span><br></pre></td></tr></table></figure>

<h2 id="2-4-父子进程虚拟地址空间"><a href="#2-4-父子进程虚拟地址空间" class="headerlink" title="2.4  父子进程虚拟地址空间"></a>2.4  父子进程虚拟地址空间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父子进程之间的关系：</span><br><span class="line">   区别：</span><br><span class="line">       1.fork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;0 返回的子进程的ID</span><br><span class="line">            子进程中: =0</span><br><span class="line">       2.pcb中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">             信号集</span><br><span class="line">    共同点：</span><br><span class="line">       某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据一样</span><br><span class="line">            - 文件描述符表一样</span><br><span class="line">        </span><br><span class="line">  父子进程对变量是不是共享的？</span><br><span class="line"> - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line"> - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。（COW）</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span><br><span class="line">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span><br><span class="line">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span><br><span class="line">只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自独立的地址空间。</span><br><span class="line">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span><br><span class="line">注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享 文件偏移指针。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="2-5-GDB多进程调试"><a href="#2-5-GDB多进程调试" class="headerlink" title="2.5 GDB多进程调试"></a>2.5 GDB多进程调试</h2><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240106151123719.png" alt="image-20240106151123719"></p>
<h2 id="2-6-exec函数族"><a href="#2-6-exec函数族" class="headerlink" title="2.6 exec函数族"></a>2.6 exec函数族</h2><p>作用：调用可执行文件，取代进程后续的内容</p>
<p>调用成功不返回（因为原代码已被替换为可执行文件的内容，没有exec这行代码了）</p>
<p>调用失败返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int execl(const char * path,const char *arg, ...);</span><br><span class="line">        - 参数：</span><br><span class="line">            - path:需要指定的执行的文件的路径或者名称</span><br><span class="line">                a.out /home/nowcoder/a.out 推荐使用绝对路径</span><br><span class="line">                ./a.out hello world</span><br><span class="line"></span><br><span class="line">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">                参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">            如果调用成功，没有返回值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> int execlp(const char *file, const char *arg, ... );</span><br><span class="line">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="line">        - 参数：</span><br><span class="line">            - file:需要执行的可执行文件的文件名</span><br><span class="line">                a.out</span><br><span class="line">                ps</span><br><span class="line"></span><br><span class="line">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">                参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">            如果调用成功，没有返回值。</span><br><span class="line">            </span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">        argv是需要的参数的一个字符串数组</span><br><span class="line">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span><br><span class="line">        execv(&quot;/bin/ps&quot;, argv);</span><br><span class="line">        </span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240107140312527.png" alt="image-20240107140312527"></p>
<p>有p或e：传文件名，否则传路径</p>
<p>e：自定义去哪些环境变量中查找</p>
<p>v：用参数数组写入参数</p>
<p>l：直接写入参数，以null结尾</p>
<h2 id="2-7-进程控制"><a href="#2-7-进程控制" class="headerlink" title="2.7 进程控制"></a>2.7 进程控制</h2><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240107150011858.png" alt="image-20240107150011858"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;hello\n&quot;);</span><br><span class="line">	printf(&quot;world&quot;);</span><br><span class="line">	</span><br><span class="line">	exit(0); // 标准c库，会刷新缓冲区 打印 hello world</span><br><span class="line">	_exit(0);// 系统调用，不会刷新缓冲区  打印 hello （\n会刷新缓冲区） </span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status的值代表进程退出状态，可以被wait或waitpid捕获</span><br></pre></td></tr></table></figure>

<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>◼ <strong>父进程先运行结束，但子进程还在运行，这样的子进程就称为孤儿进程</strong>（Orphan Process）。</p>
<p>◼ 每当出现一个孤儿进程，<strong>内核就把孤儿进程的父进程设为 init ， init 进程会循环地 wait() 这些孤儿进程。</strong>这样，当一个孤儿进程结束了其生命周期的时候，init 进程就会处理它的一切善后工作</p>
<p>◼ 因此孤儿进程并不会有什么危害</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，但内核区的 PCB 没有办法自己释放掉，需要父进程去释放</p>
<p>◼ <strong>子进程先终止</strong>，如果父进程尚未回收，子进程残留的资源（PCB）存放于内核中，变成僵尸（Zombie）进程</p>
<p>◼ <strong>僵尸进程不能被 kill -9 杀死</strong>，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是<strong>系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程</strong>，此为僵尸进程的危害，应当避免</p>
<p>解决方法：</p>
<ol>
<li>终止父进程，让子进程被init进程回收（企业中已运行，不能终止）</li>
<li>在父进程中调用wait或waitpid（常用）</li>
</ol>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>◼ 在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件、占用的内存等。</p>
<p>但是仍然为其保留一定的信息，这些信息主要是进程控制块PCB的信息（包括进程号、退出状态、运行时间等）</p>
<p>◼ 父进程可以通过调用wait或waitpid得到它的退出状态，同时彻底清除掉这个进程</p>
<p>◼ wait() 和 waitpid() 函数的功能一样，区别在于，<strong>wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束</strong></p>
<p>◼ <strong>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环</strong></p>
<h3 id="wait（）"><a href="#wait（）" class="headerlink" title="wait（）"></a>wait（）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t wait(int *wstatus);</span><br><span class="line">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span><br><span class="line">        参数：int *wstatus</span><br><span class="line">            进程退出时的状态信息，传入的是一个int类型的地址，将状态赋给这个参数 （传出参数）</span><br><span class="line">            可以为NULL，表示不获取子进程退出状态</span><br><span class="line">        返回值：</span><br><span class="line">            - 成功：返回被回收的子进程的id</span><br><span class="line">            - 失败：-1 (所有的子进程都已结束/调用函数失败)</span><br><span class="line"></span><br><span class="line">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240107165037885.png" alt="image-20240107165037885"></p>
<h3 id="waitpid（）"><a href="#waitpid（）" class="headerlink" title="waitpid（）"></a>waitpid（）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">        参数：</span><br><span class="line">            - pid:</span><br><span class="line">                pid &gt; 0 : 某个子进程的pid</span><br><span class="line">                pid = 0 : 回收当前进程组中的任意一个子进程    </span><br><span class="line">                pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）</span><br><span class="line">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">            - options：设置阻塞或者非阻塞</span><br><span class="line">                0 : 阻塞</span><br><span class="line">                WNOHANG : 非阻塞</span><br><span class="line">            - 返回值：</span><br><span class="line">                &gt; 0 : 返回子进程的id</span><br><span class="line">                = 0 : options=WNOHANG时, 表示还有子进程</span><br><span class="line">                = -1 ：错误或者没有子进程了</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="2-8-进程间通信IPC"><a href="#2-8-进程间通信IPC" class="headerlink" title="2.8 进程间通信IPC"></a>2.8 进程间通信IPC</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p><strong><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122133916483.png" alt="image-20240122133916483"></strong></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>在内核内存中维护的缓冲器</li>
<li>拥有文件的特质：读操作、写操作</li>
<li>匿名管道没有文件实体，有名管道有文件实体,但不存储数据</li>
<li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少</li>
<li>传递的数据是顺序的</li>
<li>传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的</li>
<li>读数据是一次性操作,在管道中无法使用 lseek() 来随机的访问数据</li>
<li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">◼ 创建匿名管道</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">◼ 查看管道缓冲大小命令</span><br><span class="line">ulimit –a</span><br><span class="line">◼ 查看管道缓冲大小函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">long fpathconf(int fd, int name);</span><br><span class="line">/*</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int pipe(int pipefd[2]);</span><br><span class="line">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="line">            pipefd[0] 对应的是管道的读端</span><br><span class="line">            pipefd[1] 对应的是管道的写端</span><br><span class="line">        返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1</span><br><span class="line"></span><br><span class="line">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line"></span><br><span class="line">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">获取管道大小：fpathconf（）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">◼ 通过命令创建有名管道</span><br><span class="line">mkfifo 名字</span><br><span class="line">◼ 通过函数创建有名管道</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    创建fifo文件</span><br><span class="line">    1.通过命令：mkfifo 名字</span><br><span class="line">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/stat.h&gt;</span><br><span class="line">    int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">        参数：</span><br><span class="line">            - pathname: 管道名称的路径</span><br><span class="line">            - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="line">                    是一个八进制的数</span><br><span class="line">        返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中</li>
<li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用</li>
<li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信</li>
</ol>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122134521469.png" alt="image-20240122134521469"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">◼ #include &lt;sys/mman.h&gt;</span><br><span class="line">◼ void *mmap(void *addr, size_t length, int prot, int flags, </span><br><span class="line">int fd, off_t offset);</span><br><span class="line">◼ int munmap(void *addr, size_t length);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/mman.h&gt;</span><br><span class="line">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">        - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="line">        - 参数：</span><br><span class="line">            - void *addr: NULL, 由内核指定</span><br><span class="line">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="line">                    获取文件的长度：stat lseek</span><br><span class="line">            - prot : 对申请的内存映射区的操作权限</span><br><span class="line">                -PROT_EXEC ：可执行的权限</span><br><span class="line">                -PROT_READ ：读权限</span><br><span class="line">                -PROT_WRITE ：写权限</span><br><span class="line">                -PROT_NONE ：没有权限</span><br><span class="line">                要操作映射内存，必须要有读的权限。</span><br><span class="line">                PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="line">            - flags :</span><br><span class="line">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="line">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="line">            - fd: 需要映射的那个文件的文件描述符</span><br><span class="line">                - 通过open得到，open的是一个磁盘文件</span><br><span class="line">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="line">                    prot: PROT_READ                open:只读/读写 </span><br><span class="line">                    prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="line">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移</span><br><span class="line">        - 返回值：返回创建的内存的首地址</span><br><span class="line">            失败返回MAP_FAILED，(void *) -1</span><br><span class="line"></span><br><span class="line">    int munmap(void *addr, size_t length);</span><br><span class="line">        - 功能：释放内存映射</span><br><span class="line">        - 参数：</span><br><span class="line">            - addr : 要释放的内存的首地址</span><br><span class="line">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    使用内存映射实现进程间通信：</span><br><span class="line">    1.有关系的进程（父子进程）</span><br><span class="line">        - 还没有子进程的时候</span><br><span class="line">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="line">        - 有了内存映射区以后，创建子进程</span><br><span class="line">        - 父子进程共享创建的内存映射区</span><br><span class="line">    </span><br><span class="line">    2.没有关系的进程间通信</span><br><span class="line">        - 准备一个大小不是0的磁盘文件</span><br><span class="line">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="line">            - 得到一个操作这块内存的指针</span><br><span class="line">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="line">            - 得到一个操作这块内存的指针</span><br><span class="line">        - 使用内存映射区通信</span><br><span class="line"></span><br><span class="line">    注意：内存映射区通信，是非阻塞。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">参数: </span><br><span class="line">	sem:信号对象</span><br><span class="line">	pshared: 控制信号量类型</span><br><span class="line">		- <span class="number">0</span> ：多线程间同步</span><br><span class="line">		- &gt;<span class="number">0</span> : 多进程间同步</span><br><span class="line">	value:信号量的初始值</span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; </span><br><span class="line">    阻塞函数，检测sem的值</span><br><span class="line">    若sem&gt;<span class="number">0</span>，将值减<span class="number">1</span>并返回</span><br><span class="line">    若sem&lt;=<span class="number">0</span>，阻塞，直到sem&gt;<span class="number">0</span>，此时立即减<span class="number">1</span>并返回</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sem_trywait(<span class="type">sem_t</span> *sem);</span><br><span class="line">	非阻塞的函数</span><br><span class="line">	尝试获取获取 sem value 值，如果 sem value = <span class="number">0</span>，不阻塞，直接返回一个错误 EAGAIN</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sem_post(<span class="type">sem_t</span> *sem);</span><br><span class="line">	把指定的信号量 sem 的值加 <span class="number">1</span>，唤醒正在等待该信号量的任意线程</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line">	获取信号量 sem 的当前值，把该值保存在 sval</span><br><span class="line">	若有 <span class="number">1</span> 个或多个线程正在调用 sem_wait 阻塞在该信号量上，该函数返回阻塞在该信号量上进程或线程个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">	对用完的信号量的清理</span><br><span class="line">	成功 <span class="number">0</span>，失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure>



<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>事件发生时对进程的通知机制</li>
<li>软件中断，异步通信</li>
</ul>
<p>引发内核为进程产生信号的各类事件如下：</p>
<p> 对于<strong>前台进程，用户可以通过输入特殊的终端字符来给它发送信号</strong>。比如输入Ctrl+C 通常会给进程发送一个中断信号。</p>
<p> <strong>硬件发生异常，即硬件检测到一个错误条件并通知内</strong>核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</p>
<p> <strong>系统状态变化，比如 alarm 定时器到期</strong>将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。</p>
<p> <strong>运行 kill 命令或调用 kill 函数</strong></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122145712118.png" alt="image-20240122145712118"></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122145720598.png" alt="image-20240122145720598"></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122145731979.png" alt="image-20240122145731979"></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122145740191.png" alt="image-20240122145740191"></p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122145750661.png" alt="image-20240122145750661"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">信号的 5 种默认处理动作</span><br><span class="line">◼ 查看信号的详细信息：man 7 signal</span><br><span class="line">◼ 信号的5种默认处理动作</span><br><span class="line">	 Term 终止进程</span><br><span class="line">	 Ign 当前进程忽略掉这个信号</span><br><span class="line">	 Core 终止进程，并生成一个Core文件</span><br><span class="line">	 Stop 暂停当前进程</span><br><span class="line">	 Cont 继续执行当前被暂停的进程</span><br><span class="line">◼ 信号的几种状态：产生、未决、递达</span><br><span class="line">◼ SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</span><br></pre></td></tr></table></figure>

<p>kill、raise、alarm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*  </span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">    int kill(pid_t pid, int sig);</span><br><span class="line">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="line">        - 参数：</span><br><span class="line">            - pid ：</span><br><span class="line">                &gt; 0 : 将信号发送给指定的进程</span><br><span class="line">                = 0 : 将信号发送给当前的进程组</span><br><span class="line">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="line">                &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="line">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="line"></span><br><span class="line">        kill(getppid(), 9);</span><br><span class="line">        kill(getpid(), 9);</span><br><span class="line">        </span><br><span class="line">    int raise(int sig);</span><br><span class="line">        - 功能：给当前进程发送信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - sig : 要发送的信号</span><br><span class="line">        - 返回值：</span><br><span class="line">            - 成功 0</span><br><span class="line">            - 失败 非0</span><br><span class="line">        kill(getpid(), sig);   </span><br><span class="line"></span><br><span class="line">    void abort(void);</span><br><span class="line">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="line">        kill(getpid(), SIGABRT);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>定时器alarm</p>
<p>函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALRM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    unsigned int alarm(unsigned int seconds);</span><br><span class="line">        - 功能：设置定时器（闹钟）。</span><br><span class="line">        - 参数：</span><br><span class="line">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="line">           取消一个定时器，通过alarm(0)。</span><br><span class="line">        - 返回值：</span><br><span class="line">            - 之前没有定时器，返回0</span><br><span class="line">            - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="line"></span><br><span class="line">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="line">        alarm(10);  -&gt; 返回0</span><br><span class="line">        过了1秒</span><br><span class="line">        alarm(5);   -&gt; 返回9</span><br><span class="line">        </span><br><span class="line">    alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    实际的时间 = 内核时间 + 用户时间 + 消耗的时间</span><br><span class="line">    进行文件IO操作的时候比较浪费时间</span><br><span class="line">    定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>定时器setitimer</p>
<p>函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALRM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/time.h&gt;</span><br><span class="line">    int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</span><br><span class="line">    - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">    - 参数：</span><br><span class="line">       - which : 定时器以什么时间计时</span><br><span class="line">      ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用</span><br><span class="line">      ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">      ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line">      - new_value: 设置定时器的属性</span><br><span class="line">      		struct itimerval &#123;      // 定时器的结构体</span><br><span class="line">                struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="line">                struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="line">                &#125;;</span><br><span class="line">            struct timeval &#123;        // 时间的结构体</span><br><span class="line">                 time_t      tv_sec;     //  秒数     </span><br><span class="line">                 suseconds_t tv_usec;    //  微秒    </span><br><span class="line">                &#125;;</span><br><span class="line">      过10秒后，每个2秒定时一次</span><br><span class="line">       - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">       - 返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1 并设置错误号</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>信号捕捉函数signal</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    typedef void (*sighandler_t)(int);</span><br><span class="line">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">        - 功能：设置某个信号的捕捉行为</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum: 要捕捉的信号</span><br><span class="line">            - handler: 捕捉到信号要如何处理</span><br><span class="line">                - SIG_IGN ： 忽略信号</span><br><span class="line">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="line">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="line">                回调函数：</span><br><span class="line">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="line">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="line">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">            失败，返回SIG_ERR，设置错误号</span><br><span class="line">            </span><br><span class="line">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>信号捕捉函数sigaction</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line">    - 功能：检查或者改变信号的处理（信号捕捉）</span><br><span class="line">    - 参数：</span><br><span class="line">        - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">        - act ：捕捉到信号之后的处理动作</span><br><span class="line">        - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递<span class="literal">NULL</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 <span class="number">0</span></span><br><span class="line">        失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">    <span class="type">void</span>  (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不常用</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">    <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 被废弃掉了</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>信号集</p>
<p>​	未决信号集、阻塞信号集（内核使用位图机制实现）</p>
<p>​	操作系统不允许我们直接对这两个信号集进行位操作，而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改</p>
<p>​	多个同样的信号到来时，只能记录一个未决信号或阻塞信号（不支持排队）</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240122181743080.png" alt="image-20240122181743080"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">信号集相关函数</span><br><span class="line">/*</span><br><span class="line">    以下信号集相关的函数都是对自定义的信号集进行操作。</span><br><span class="line">    int sigemptyset(sigset_t *set);</span><br><span class="line">        - 功能：清空信号集中的数据,将信号集中的所有标志位 置0</span><br><span class="line">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigfillset(sigset_t *set);</span><br><span class="line">        - 功能：将信号集中的所有的标志位置为1</span><br><span class="line">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigaddset(sigset_t *set, int signum);</span><br><span class="line">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：传出参数，需要操作的信号集</span><br><span class="line">            - signum：需要设置阻塞的那个信号</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigdelset(sigset_t *set, int signum);</span><br><span class="line">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：传出参数，需要操作的信号集</span><br><span class="line">            - signum：需要设置不阻塞的那个信号</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigismember(const sigset_t *set, int signum);</span><br><span class="line">        - 功能：判断某个信号是否阻塞</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：需要操作的信号集</span><br><span class="line">            - signum：需要判断的那个信号</span><br><span class="line">        - 返回值：</span><br><span class="line">            1 ： signum被阻塞</span><br><span class="line">            0 ： signum不阻塞</span><br><span class="line">            -1 ： 失败</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>sigprocmask</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">操作内核中的信号集</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"></span><br><span class="line">   - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">     参数：</span><br><span class="line">     - how : 如何对内核阻塞信号集进行处理</span><br><span class="line">       SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="line">           假设内核中默认的阻塞信号集是mask， mask | <span class="built_in">set</span></span><br><span class="line">       SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="line">           mask &amp;= ~<span class="built_in">set</span></span><br><span class="line">       SIG_SETMASK:覆盖内核中原来的值</span><br><span class="line"></span><br><span class="line">     - <span class="built_in">set</span> ：已经初始化好的用户自定义的信号集</span><br><span class="line">     - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 <span class="literal">NULL</span></span><br><span class="line">          - 返回值：</span><br><span class="line">            成功：<span class="number">0</span></span><br><span class="line">            失败：<span class="number">-1</span></span><br><span class="line">            设置错误号：EFAULT、EINVAL</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sigpending(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">   - 功能：获取内核中的未决信号集</span><br><span class="line">     ：<span class="built_in">set</span>,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240123131458814.png" alt="image-20240123131458814"></p>
<p>SIGCHLD信号</p>
<p>◼ SIGCHLD信号产生的条件</p>
<p>​	 子进程终止时</p>
<p>​	 子进程接收到 SIGSTOP 信号停止时</p>
<p>​	 子进程处在停止态，接受到SIGCONT后唤醒时</p>
<p>◼ 以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>1、调用shmget（）创建或获取一个共享内存段</p>
<p>2、调用shmat（）附上该共享内存段</p>
<p>3、调用shmdt（）分离共享内存段</p>
<p>4、调用shmctl（）删除共享内存段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识（新创建的内存段中的数据都会被初始化为<span class="number">0</span>）</span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  </span><br><span class="line">        失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line">    - 功能：对共享内存进行操作。主要用来删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁对共享内存没有任何影响</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁（所有进程都标记销毁，共享内存才会销毁）</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">    - 功能：根据指定的 路径名和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体<span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> 这个结构体中有一个成员 <span class="title">shm_nattch</span></span></span><br><span class="line"><span class="class">    - <span class="title">shm_nattach</span> 记录了关联的进程个数</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">问题2：可不可以对共享内存进行多次删除 <span class="title">shmctl</span></span></span><br><span class="line"><span class="class">    - 可以的</span></span><br><span class="line"><span class="class">    - 因为<span class="title">shmctl</span> 标记删除共享内存，不是直接删除</span></span><br><span class="line"><span class="class">    - 什么时候真正删除呢?</span></span><br><span class="line"><span class="class">        当和共享内存关联的进程数为0的时候，就真正被删除</span></span><br><span class="line"><span class="class">    - 当共享内存的<span class="title">key</span>为0的时候，表示共享内存被标记删除了</span></span><br><span class="line"><span class="class">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    共享内存和内存映射的区别</span></span><br><span class="line"><span class="class">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span></span><br><span class="line"><span class="class">    2.共享内存效率更高</span></span><br><span class="line"><span class="class">    3.内存</span></span><br><span class="line"><span class="class">        所有的进程操作的是同一块共享内存（在各自的虚拟地址空间中都一样）</span></span><br><span class="line"><span class="class">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存</span></span><br><span class="line"><span class="class">        <span class="title">shm</span>目的是共享，<span class="title">mmap</span>目的是加快文件访问速度</span></span><br><span class="line"><span class="class">    4.数据安全</span></span><br><span class="line"><span class="class">        - 进程突然退出</span></span><br><span class="line"><span class="class">            共享内存还存在</span></span><br><span class="line"><span class="class">            内存映射区消失</span></span><br><span class="line"><span class="class">        - 运行进程的电脑死机，宕机了</span></span><br><span class="line"><span class="class">            数据存储在共享内存中，就没有了</span></span><br><span class="line"><span class="class">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    5.生命周期</span></span><br><span class="line"><span class="class">        - 内存映射区：进程退出，内存映射区销毁</span></span><br><span class="line"><span class="class">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span></span><br><span class="line"><span class="class">            如果一个进程退出，会自动和共享内存取消关联</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240123172019352.png" alt="image-20240123172019352"></p>
<h2 id="2-9-守护进程"><a href="#2-9-守护进程" class="headerlink" title="2.9 守护进程"></a>2.9 守护进程</h2><p>◼ 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是<strong>Linux 中的后台服务进程</strong>。</p>
<p>它是一个生存期较长的进程，通常<strong>独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</strong>。一般采用以 d 结尾的名字</p>
<p>◼ 守护进程具备下列特征：</p>
<p>​	 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</p>
<p>​	 它在后台运行并且不拥有控制终端。<strong>没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</strong></p>
<p>◼ <strong>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">守护进程创建步骤</span><br><span class="line">1、执行fork（），父进程退出，子进程继续执行</span><br><span class="line">2、子进程调用setsid（）开启一个新会话</span><br><span class="line">3、清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限</span><br><span class="line">4、修改进程的当前工作目录，通常会改为根目录（/）</span><br><span class="line">5、关闭守护进程从其父进程继承来的所有打开着的文件描述符</span><br><span class="line">6、在关闭了文件描述符0、1、2后，守护进程通常会打开/dev/null，并使用dup2（）使所有这些描述符指向这个设备  （所有输入到这个设备的内容都会被丢弃）</span><br><span class="line">7、核心业务逻辑</span><br></pre></td></tr></table></figure>

<h1 id="第三章-Linux多线程开发"><a href="#第三章-Linux多线程开发" class="headerlink" title="第三章  Linux多线程开发"></a>第三章  Linux多线程开发</h1><h2 id="3-1-线程概述"><a href="#3-1-线程概述" class="headerlink" title="3.1 线程概述"></a>3.1 线程概述</h2><p>​	与进程（process）类似，线程（thread）是<strong>允许应用程序并发执行多个任务的一种机制</strong>。<strong>一个进程可以包含多个线程</strong>。</p>
<p>​	同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。</p>
<p>（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p>
<p>◼ <strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p>
<p>◼ 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。</p>
<p>◼ 查看指定进程的 LWP 号：ps –Lf pid</p>
<h3 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h3><p>进程间并未共享内存，需要采用一些进程间通信的方式，在进程间做数据交换；调用fork创建进程开销很大，即使采用写时复制技术，仍需要复制像内存页表和文件描述符表等多种进程属性</p>
<p>线程之间由于共享虚拟地址空间，可以方便快速的共享和传递信息；创建线程不需要复制内存或页表等，比创建进程快10倍以上</p>
<h3 id="线程共享和非共享资源"><a href="#线程共享和非共享资源" class="headerlink" title="线程共享和非共享资源"></a>线程共享和非共享资源</h3><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240124110140579.png" alt="image-20240124110140579"></p>
<img src="D:\Blog\source\_posts\基于http的Linux高性能并发服务器\image-20240124110239309.png" alt="image-20240124110239309" style="zoom:67%;">

<h2 id="3-2-创建线程"><a href="#3-2-创建线程" class="headerlink" title="3.2 创建线程"></a>3.2 创建线程</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span><br><span class="line">    称之为子线程。</span><br><span class="line">    程序中默认只有一个进程，fork()函数调用，<span class="number">2</span>进行</span><br><span class="line">    程序中默认只有一个线程，pthread_create()函数调用，<span class="number">2</span>个线程。</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params">    <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">        - 功能：创建一个子线程</span><br><span class="line">        - 参数：</span><br><span class="line">            - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span><br><span class="line">            - attr : 设置线程的属性，一般使用默认值，<span class="literal">NULL</span></span><br><span class="line">            - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码  (<span class="type">void</span>* - 万能指针，可以传递任意参数)</span><br><span class="line"> 注：在c++程序中使用pthread_creat时，第<span class="number">3</span>个参数必须指向一个静态函数</span><br><span class="line">            - arg : 给第三个参数使用，传参</span><br><span class="line">             </span><br><span class="line">        - 返回值：</span><br><span class="line">            成功：<span class="number">0</span></span><br><span class="line">            失败：返回错误号errnum。</span><br><span class="line">            这个错误号和之前errno不太一样。</span><br><span class="line">            获取错误号的信息：  <span class="type">char</span> * <span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br><span class="line"></span><br><span class="line">注：编译时需要加 -lpthread (因为线程属于第三方库)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pthread-exit-pthread-self-pthread-equal"><a href="#pthread-exit-pthread-self-pthread-equal" class="headerlink" title="pthread_exit()  pthread_self()  pthread_equal()"></a>pthread_exit()  pthread_self()  pthread_equal()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">    功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span><br><span class="line">    参数：</span><br><span class="line">        retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</span><br><span class="line">      注意返回值不要是局部变量</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    功能：获取当前的线程的线程ID</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">    功能：比较两个线程ID是否相等</span><br><span class="line">    不同的操作系统，<span class="type">pthread_t</span>类型的实现不一样，有的是无符号的长整型，有的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>**retval)</span>;</span><br><span class="line">        - 功能：和一个已经终止的线程进行连接</span><br><span class="line">                回收子线程的资源</span><br><span class="line">             	阻塞函数，调用一次只能回收一个子线程</span><br><span class="line">                一般在主线程中使用</span><br><span class="line">        - 参数：</span><br><span class="line">            - thread：需要回收的子线程的ID</span><br><span class="line">            - retval: 接收子线程退出时的返回值</span><br><span class="line"><span class="type">void</span>** 二级指针： 用二级地址存储一级地址，一级地址指向内存</span><br><span class="line">（如果用一级指针，相当于一个地址指向的内存存储了另一个地址，而不是那个地址指向的内存/内容）</span><br><span class="line">        - 返回值：</span><br><span class="line">            <span class="number">0</span> : 成功</span><br><span class="line">            非<span class="number">0</span> : 失败，返回的错误号</span><br></pre></td></tr></table></figure>

<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line">    - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span><br><span class="line">      <span class="number">1.</span>不能多次分离，会产生不可预料的行为。</span><br><span class="line">      <span class="number">2.</span>不能去连接一个已经分离的线程，会报错。</span><br><span class="line">    - 参数：需要分离的线程的ID</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号</span><br></pre></td></tr></table></figure>

<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel()"></a>pthread_cancel()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：取消线程（让线程终止）</span><br><span class="line">        取消某个线程，可以终止某个线程的运行，</span><br><span class="line">        但并不是立马终止，而是当子线程执行到一个取消点，线程才会终止</span><br><span class="line">        取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点</span><br></pre></td></tr></table></figure>

<h2 id="3-3-线程同步"><a href="#3-3-线程同步" class="headerlink" title="3.3 线程同步"></a>3.3 线程同步</h2><p>◼ 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：<strong>必须确保多个线程不会同时修改同一变量</strong>，或者某一线程不会读取正在由其他线程修改的变量</p>
<p>◼ 临界区是指访问某一共享资源的代码片段，这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应中断该片段的执行</p>
<p>◼ <strong>线程同步：当有一个线程在对内存进行操作时，其他线程都不可以对这个内存进行操作，直到该线程完成操作，其他线程才能对该内存进行操作（其他线程处于等待状态）</strong></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240124224829624.png" alt="image-20240124224829624"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">互斥量的类型 <span class="type">pthread_mutex_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">       - 初始化互斥量</span><br><span class="line">       - 参数 ：</span><br><span class="line">           - mutex ： 需要初始化的互斥量变量</span><br><span class="line">           - attr ： 互斥量相关的属性，<span class="literal">NULL</span></span><br><span class="line">       - <span class="keyword">restrict</span> : C语言的修饰符（被修饰的指针所指向的对象，不能再被另外的指针引用或操作）</span><br><span class="line">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex = xxx;</span><br><span class="line">           <span class="type">pthread_mutex_t</span> * mutex1 = mutex;</span><br><span class="line">	返回值：</span><br><span class="line">           <span class="number">0</span>，成功</span><br><span class="line">		</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 释放互斥量的资源</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 解锁</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>◼ 死锁的几种场景：</p>
<p>​	 忘记释放锁</p>
<p>​	 重复加锁 （常见于调用的两个函数都有加锁动作）</p>
<p>​	 多线程多锁，抢占锁资源</p>
<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件；</li>
<li>持有并等待条件；</li>
<li>不可剥夺条件；</li>
<li>环路等待条件；</li>
</ul>
<h3 id="互斥条件"><a href="#互斥条件" class="headerlink" title="#互斥条件"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/4_process/deadlock.html#%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6">#</a>互斥条件</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁的特点：</p>
<p>​	 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操		作</p>
<p>​	 如果有其它线程写数据，则其它线程都不允许读、写操作</p>
<p>​	 写是独占的，写的优先级高</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">读写锁的类型 <span class="type">pthread_rwlock_t</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   条件变量的类型 <span class="type">pthread_cond_t</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">       - 调用该函数，线程会阻塞，等待唤醒</span><br><span class="line"><span class="comment">// 当这个函数阻塞时，会对互斥锁解锁，当不阻塞时，会重新加锁</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">       - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span><br><span class="line">           </span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">       - 唤醒一个或多个等待（cond_wait）的线程</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">       - 唤醒所有的等待的线程</span><br></pre></td></tr></table></figure>

<p>信号量</p>
<p>为了防止多进程竞争共享资源，使得共享的资源，在任意时刻只能被一个进程访问</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存</p>
<p>信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">信号量的类型 <span class="type">sem_t</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">        - 初始化信号量</span><br><span class="line">        - 参数：</span><br><span class="line">            - sem : 信号量变量的地址</span><br><span class="line">            - pshared : <span class="number">0</span> 用在线程间 ，非<span class="number">0</span> 用在进程间</span><br><span class="line">            - value : 记录信号量中的值</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">        - 释放信号量资源</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">      - 对信号量加锁：调用一次对信号量的值<span class="number">-1</span>，如果值为<span class="number">0</span>，就阻塞</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">        - 对信号量解锁：调用一次对信号量的值+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者消费者模型</span></span><br><span class="line">    <span class="type">sem_t</span> psem;</span><br><span class="line">    <span class="type">sem_t</span> csem;</span><br><span class="line">    init(psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    init(csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    producer() &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        sem_post(&amp;csem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    customer() &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        sem_post(&amp;psem)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-Linux网络编程"><a href="#第四章-Linux网络编程" class="headerlink" title="第四章 Linux网络编程"></a>第四章 Linux网络编程</h1><h2 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h2><p>进程间网络通信的特殊文件类型（本质为内核借助缓冲区形成的伪文件）</p>
<p>上联应用进程，下联网络协议栈</p>
<p>由 IP 地址和端口结合</p>
<p>读写套接字和读写文件的操作一致，多用于网络进程间数据的传递</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>大端字节序：</p>
<ul>
<li>高位存在低地址，低位存在高地址</li>
<li>存放时顺序不变</li>
</ul>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240128114213324.png" alt="image-20240128114213324"></p>
<p>小端字节序：</p>
<ul>
<li>高位存放高地址，低位存放低地址</li>
<li>存放时顺序相反</li>
</ul>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240128114151163.png" alt="image-20240128114151163"></p>
<p>注：大多数机器是小端</p>
<p><strong>如何判断大小端？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> value ; <span class="comment">// 2bytes</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)]; <span class="comment">// char[2]</span></span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>]==<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);  <span class="comment">//高位在低地址处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节序转换函数</strong></p>
<p>不同字节序的主机之间传递数据：统一使用网络字节序–大端</p>
<p>发送端总是将数据转换成大端字节序发送，接受端根据自身情况决定是否需要转换（小端机转换）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序-网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序-主机字节序 </span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序-网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序-主机字节序 </span></span><br></pre></td></tr></table></figure>

<h2 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h2><p>本质是一个结构体，封装IP和端口号等信息（客户端与服务器通信，需要服务器的IP和Port）</p>
<ul>
<li>通用socket地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<p>sa_family 成员</p>
<p>​	用于指定协议类型</p>
<table>
<thead>
<tr>
<th><strong>协议族</strong></th>
<th><strong>地址族</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<p>sa_data 成员</p>
<p>​	用于存放socket地址</p>
<table>
<thead>
<tr>
<th><strong>协议族</strong></th>
<th><strong>地址值含义和长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达到108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16 bit 端口号和 32 bit IPv4 地址，共 6 字节</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID，共 26 字节</td>
</tr>
</tbody></table>
<p>Linux 定义了下面这个新的通用的 socket 地址结构体,这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">	<span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>专用socket地址</li>
</ul>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240131170102250.png" alt="image-20240131170102250"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin_family; <span class="comment">/*__SOCKADDR_COMMON(sin_) */</span></span><br><span class="line">	<span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line">	<span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -<span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ypedef <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure>

<p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</p>
<h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面(传出参数)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure>

<h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">				UDP 		TCP</span><br><span class="line">是否创建连接 		无连接 面向连接</span><br><span class="line">是否可靠 		不可靠 可靠的</span><br><span class="line">连接的对象个数 	一对一、一对多、多对一、多对多 支持一对一</span><br><span class="line">传输的方式 		面向数据报 面向字节流</span><br><span class="line">首部开销 		8个字节 最少20个字节</span><br><span class="line">适用场景 		实时应用（视频会议，直播） 可靠性高的应用（文件传输）</span><br><span class="line"></span><br><span class="line">UDP：面向无连接，不可靠，一对一、一对多和多对多，面向数据报，首部8个字节，适用于实时应用（如视频、直播）</span><br><span class="line">TCP：面向连接，可靠传输、一对一，基于字节流，首部至少20个字节，适用于可靠性高的场景（如文件传输）</span><br></pre></td></tr></table></figure>

<p><img src="Blog\source_posts\webserver\image-20240210121918330.png" alt="image-20240210121918330"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//tcp通信流程</span><br><span class="line">服务器端（被动接受）</span><br><span class="line">1、创建一个用于监听的套接字</span><br><span class="line">	-监听：是否有客户端连接</span><br><span class="line">	-fd：该套接字的文件描述符</span><br><span class="line">2、绑定IP和端口号（服务器自己的）</span><br><span class="line">	-客户端发起连接时需要知道这个IP和端口号</span><br><span class="line">3、设置监听，监听的fd开始工作</span><br><span class="line">4、阻塞等待，当有客户端发起连接时解除阻塞；服务器接受客户端的连接，返回一个用于通信的fd套接字</span><br><span class="line">5、通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line">6、通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">客户端（主动建立连接）</span><br><span class="line">1、创建一个用于通信的socket套接字（返回一个fd）</span><br><span class="line">2、连接服务器（指定服务器的IP和端口号）</span><br><span class="line">3、连接建立</span><br><span class="line">	-发送数据</span><br><span class="line">	-接收数据</span><br><span class="line">4、通信结束，断开连接</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>用来控制传输数据的吞吐量，解决发送方发送的数据量太大，而接收方接收的速度较慢，从而导致的丢包问题（实现流量控制、拥塞控制）</p>
<ul>
<li>窗口大小就是接收缓冲区的大小</li>
<li>窗口大小会不断变化</li>
<li>通信双方都有发送缓冲区和接收缓冲区</li>
</ul>
<h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">参数：</span><br><span class="line">- sockfd : 要操作的文件描述符</span><br><span class="line">- level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">- optname : 选项的名称</span><br><span class="line">	- SO_REUSEADDR</span><br><span class="line">	- SO_REUSEPORT</span><br><span class="line">- optval : 端口复用的值（整形）</span><br><span class="line">	- <span class="number">1</span> : 可以复用</span><br><span class="line">	- <span class="number">0</span> : 不可以复用</span><br><span class="line">- optlen : optval参数的大小</span><br><span class="line"></span><br><span class="line">端口复用设置的时机：在服务器绑定端口之前</span><br><span class="line">setsockop（）；</span><br><span class="line">bind（）；</span><br></pre></td></tr></table></figure>

<p>为什么需要端口复用:</p>
<p>​	服务器重启时，之前绑定的<strong>端口还未释放</strong> </p>
<p>​	程序突然退出，而系统没有释放端口</p>
<p>查看网络相关信息</p>
<p>netstat -apn</p>
<p>-a 所有的socket</p>
<p>-p 显示正在使用socket的程序名</p>
<p>-n 直接使用ip地址，而不通过域名服务器</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a><strong>IO多路复用</strong></h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>1 构造一个文件描述符列表（添加将要监听的文件描述符）</p>
<p>2 调用系统函数监听此列表，直到进行IO操作时函数返回</p>
<p>​	a 此函数阻塞</p>
<p>​	b 函数对文件描述符的检测操作由内核完成</p>
<p>3 返回时告诉进程有多少描述符要进行IO操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//sizeof(fd_set) =128字节  1024位</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);</span><br><span class="line">- 参数：</span><br><span class="line">	- nfds ： 需要检测的描述符数量+1</span><br><span class="line">	- readfds : 要检测的读文件描述符集合</span><br><span class="line">	- writefds : 要检测的写文件描述符集合</span><br><span class="line">		一般只检测读操作，对应对方发送过来的数据，传入传出参数</span><br><span class="line">	- exceptfds ：检测发生异常的文件描述符</span><br><span class="line">	- timeout : 设置的超时时间</span><br><span class="line">		struct timeval &#123;</span><br><span class="line">			long tv_sec;	/* seconds */</span><br><span class="line">			long tv_usec;	/* microseconds */</span><br><span class="line">		&#125;</span><br><span class="line">		NULL : 永久阻塞，直到检测到文件描述符变化</span><br><span class="line">		tv_sec = 0 tv_usec = 0 ： 不阻塞</span><br><span class="line">		tv_sec &gt; 0 tv_usec &gt; 0 : 阻塞相应的时间</span><br><span class="line">	- 返回值：</span><br><span class="line">		-1：失败</span><br><span class="line">		 n : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line">// 将fd对应的标志位 置为0</span><br><span class="line">void FD_CLR(int fd,fd_set *set);</span><br><span class="line"></span><br><span class="line">//将fd对应的标志位 置为1</span><br><span class="line">void FD_SET(int fd,fd_set *set);</span><br><span class="line"></span><br><span class="line">//判断fd对应的标志位是0（返回0），还是1（返回1） </span><br><span class="line">int FD_ISSET(int fd, fd_set *set); </span><br><span class="line"></span><br><span class="line">//将fd_set的1024bit，全部初始化为0</span><br><span class="line">void FD_ZERO（fd_set *set）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240225123554728.png" alt="image-20240225123554728"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 设置监听文件描述符集合 reads</span></span><br><span class="line">fd_set reads;</span><br><span class="line"><span class="comment">//2 将已建立连接的fd标志位 置1（3，4,100,101）</span></span><br><span class="line">FD_SET(<span class="number">3</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">4</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">100</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">101</span>,&amp;reads);</span><br><span class="line"></span><br><span class="line">select(<span class="number">101</span> +<span class="number">1</span> ,&amp;reads,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="number">3</span> 将reads从用户态拷贝到内核态</span><br><span class="line"><span class="number">4</span> 在内核中遍历reads，看哪些fd为<span class="number">1</span>，并检测这些fd是否有数据</span><br><span class="line"><span class="number">5</span> 如果没有数据，重新将其置为<span class="number">0</span>，有数据仍保持<span class="number">1</span></span><br><span class="line"><span class="number">6</span> 将reads从内核态拷贝回用户态</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span> 在用户态遍历哪些fd为<span class="number">1</span>，说明有数据可读（有事件发生）</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    read.../recv...</span><br><span class="line">&#125;</span><br><span class="line">判断是否为<span class="number">1</span></span><br><span class="line">    FD_ISSET(<span class="number">3</span>,&amp;reads);</span><br><span class="line"><span class="number">100</span>断开连接</span><br><span class="line">    FD_CLR(<span class="number">100</span>,&amp;reads);</span><br></pre></td></tr></table></figure>

<p>注：内核对传入的文件描述符表全部遍历，只有判断值为1的才会去检测这个文件描述符是否有数据</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240225144746090.png" alt="image-20240225144746090"></p>
<p>select的缺点：</p>
<p>1.每次调用select，都需要把fd集合从用 户态拷贝到内核态，这个开销在fd很多时 会很大 </p>
<p>2.同时每次调用select都需要在内核遍历 传递进来的所有fd，这个开销在fd很多时 也很大 </p>
<p>3.select支持的文件描述符数量太小了， 默认是1024 </p>
<p>4.fds集合不能重用，每次都需要重置</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240225155110793.png" alt="image-20240225155110793"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">	<span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line">举例：</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">	myfd.fd = <span class="number">5</span>;</span><br><span class="line">	myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- fds : <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>结构体数组，需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">		- <span class="title">nfds</span> :</span> fds数组中最大有效元素的索引 + <span class="number">1</span></span><br><span class="line">		- timeout : 阻塞时长</span><br><span class="line">			<span class="number">0</span> : 不阻塞</span><br><span class="line">			<span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">			&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">	- 返回值：	</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure>

<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，<strong>取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制</strong>，当然还会受到系统文件描述符限制。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240225164741522.png" alt="image-20240225164741522"></p>
<p>epoll通过两个方面，很好的解决了select&#x2F;poll的问题</p>
<p>1 epoll在内核里使用<strong>红黑树</strong>来跟踪进程所有待检测的文件描述符，把需要监控的socket通过<strong>epoll_ctl(</strong>)函数加入内核的红黑树中（a.增删改高效，O（logn）b.减少了内核和用户态之间的数据拷贝和内存分配）</p>
<p>2 epoll是<strong>事件驱动机制</strong>，<strong>内核里维护一个链表来记录就绪事件</strong>，当某个socket有事件发生时，通过回调函数将其加入到就绪事件列表中（当用户调用epoll_wait()函数时，只返回有事件发生的文件描述符的个数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发生改变的文件描述符的信息（双向链表）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">	size : 目前没有意义了，随便写一个大于<span class="number">0</span>的数</span><br><span class="line">- 返回值：</span><br><span class="line">	<span class="number">-1</span> : 失败</span><br><span class="line">	&gt; <span class="number">0</span> : 文件描述符，用来操作epoll实例</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,<span class="type">int</span> op,<span class="type">int</span> fd,<span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">-参数 ：</span><br><span class="line">    - epfd：epoll_create的返回值，epoll实例对应的文件描述符</span><br><span class="line">    - op ：需要进行的操作</span><br><span class="line">    	EPOLL_CTL_ADD: 添加</span><br><span class="line">        EPOLL_CTL_MOD: 修改</span><br><span class="line">        EPOLL_CTL_DEL: 删除</span><br><span class="line">    - fd : 要检测的文件描述符</span><br><span class="line">    - event : 检测文件描述符什么事情</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">        <span class="type">void</span>  *ptr;</span><br><span class="line">        <span class="type">int</span>  fd;</span><br><span class="line">        <span class="type">uint32_t</span> u32</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">    &#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">	- EPOLLIN</span><br><span class="line">	- EPOLLOUT</span><br><span class="line">	- EPOLLERR</span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">	- epfd : epoll实例对应的文件描述符</span><br><span class="line">	- events : 传出参数，保存了发生变化的文件描述符的信息</span><br><span class="line">	- maxevents : 第二个参数结构体数组的大小</span><br><span class="line">	- timeout : 阻塞时间</span><br><span class="line">		 <span class="number">0</span> : 不阻塞</span><br><span class="line">		 <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">		 &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">- 返回值：</span><br><span class="line">	- 成功，返回发生变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">    - 失败，返回 <span class="number">-1</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>Epoll 的工作模式：</p>
<p> LT 模式 （水平触发）</p>
<p> 假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知 </p>
<p>​	a.用户不读数据，数据一直在缓冲区，epoll 会一直通知</p>
<p>​	 b.用户只读了一部分数据，epoll会通知 </p>
<p>​	c.缓冲区的数据读完了，不通知 </p>
<p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这 种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操 作。如果你不作任何操作，内核还是会继续通知你的。</p>
<p>ET 模式（边沿触发） </p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p>
<p> a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</p>
<p> b.用户只读了一部分数据，epoll不通知</p>
<p> c.缓冲区的数据读完了，不通知 </p>
<p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述 符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成 未就绪），内核不会发送更多的通知（only once）。 </p>
<p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写 操作把处理多个文件描述符的任务饿死。</p>
<h1 id="第五章-项目实战"><a href="#第五章-项目实战" class="headerlink" title="第五章 项目实战"></a>第五章 项目实战</h1><h2 id="阻塞和非阻塞、同步-异步"><a href="#阻塞和非阻塞、同步-异步" class="headerlink" title="阻塞和非阻塞、同步&#x2F;异步"></a>阻塞和非阻塞、同步&#x2F;异步</h2><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\阻塞、非阻塞、同步、异步.png" alt="阻塞、非阻塞、同步、异步"></p>
<p>同步io和异步io：本质是针对用户区层面而言的，阻塞io和非阻塞io都是同步io，当使用aio_read（）函数才是异步io；从数据角度看，同步io需要等待数据从内核拷贝到用户，异步io完全不需要等待，全程由内核自动完成，应用程序不需要主动发起拷贝动作</p>
<p>阻塞io：阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程<br>非阻塞io：不需要等待「内核数据准备好」，但需要等待「数据从内核态拷贝到用户态」</p>
<p>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。</p>
<h2 id="Unix-Linux上的五种IO模型"><a href="#Unix-Linux上的五种IO模型" class="headerlink" title="Unix&#x2F;Linux上的五种IO模型"></a>Unix&#x2F;Linux上的五种IO模型</h2><p>1 阻塞 blocking</p>
<p>2 非阻塞 non-blocking</p>
<p>3 IO复用 IO multiplexing</p>
<p>4 信号驱动 signal-driven</p>
<p>​	Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进 程收到SIGIO 信号，然后处理 IO 事件。</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240226220202694.png" alt="image-20240226220202694"></p>
<p>​	内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需 要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。 </p>
<p>5 异步 asynchronous</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240226220315579.png" alt="image-20240226220315579"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> aio_fildes; <span class="comment">/* File desriptor. */</span></span><br><span class="line">	<span class="type">int</span> aio_lio_opcode; <span class="comment">/* Operation to be performed. */</span></span><br><span class="line">	<span class="type">int</span> aio_reqprio; <span class="comment">/* Request priority offset. */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">void</span> *aio_buf; <span class="comment">/* Location of buffer. */</span></span><br><span class="line">	<span class="type">size_t</span> aio_nbytes; <span class="comment">/* Length of transfer. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* Signal number and value. */</span></span><br><span class="line">	<span class="comment">/* Internal members. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> *__<span class="title">next_prio</span>;</span></span><br><span class="line">	<span class="type">int</span> __abs_prio;</span><br><span class="line">	<span class="type">int</span> __policy;</span><br><span class="line">	<span class="type">int</span> __error_code;</span><br><span class="line">	<span class="type">__ssize_t</span> __return_value;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">	<span class="type">__off_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line">	<span class="type">char</span> __pad[<span class="keyword">sizeof</span> (<span class="type">__off64_t</span>) - <span class="keyword">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">__off64_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>工作原理</p>
<p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客 户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方 法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版 本、成功或者错误代码、服务器信息、响应头部和响应数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">以下是 HTTP 请求/响应的步骤：</span><br><span class="line">1. 客户端连接到 Web 服务器</span><br><span class="line">一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接</span><br><span class="line">字连接。例如，http://www.baidu.com。（URL）</span><br><span class="line">2. 发送 HTTP 请求</span><br><span class="line">通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求</span><br><span class="line">头部、空行和请求数据 4 部分组成。</span><br><span class="line">3. 服务器接受请求并返回 HTTP 响应</span><br><span class="line">Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个</span><br><span class="line">响应由状态行、响应头部、空行和响应数据 4 部分组成。</span><br><span class="line">4. 释放连接 TCP 连接</span><br><span class="line">若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连</span><br><span class="line">接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</span><br><span class="line">5. 客户端浏览器解析 HTML 内容</span><br><span class="line">客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应</span><br><span class="line">头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据</span><br><span class="line">HTML 的语法对其进行格式化，并在浏览器窗口中显示。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在浏览器地址栏键入URL，按下回车之后会经历以下流程：</span><br><span class="line">1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</span><br><span class="line">2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</span><br><span class="line">3. 浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三</span><br><span class="line">次握手的第三个报文的数据发送给服务器;</span><br><span class="line">4. 服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</span><br><span class="line">5. 释放 TCP 连接;</span><br><span class="line">6. 浏览器将该 HTML 文本并显示内容。</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240226232931128.png" alt="image-20240226232931128"><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240226232940914.png" alt="image-20240226232940914"></p>
<p>HTTP请求方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副</span><br><span class="line">作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访</span><br><span class="line">问。</span><br><span class="line">2. HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文</span><br><span class="line">部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该</span><br><span class="line">资源的信息”（元信息或称元数据）。</span><br><span class="line">3. POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含</span><br><span class="line">在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</span><br><span class="line">4. PUT：向指定资源位置上传其最新内容。</span><br><span class="line">5. DELETE：请求服务器删除 Request-URI 所标识的资源。</span><br><span class="line">6. TRACE：回显服务器收到的请求，主要用于测试或诊断。</span><br><span class="line">7. OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用&#x27;*&#x27;来代替资源名称，</span><br><span class="line">向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</span><br><span class="line">8. CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服</span><br><span class="line">务器的链接（经由非加密的 HTTP 代理服务器）。</span><br></pre></td></tr></table></figure>

<h2 id="reactor和proactor"><a href="#reactor和proactor" class="headerlink" title="reactor和proactor"></a>reactor和proactor</h2><p>服务器程序通常需要处理三类事件：IO、信号、定时</p>
<p>有两种高效的事件处理模式：Reactor和Proactor</p>
<p>同步IO模型实现Reactor，异步IO模型实现Proactor</p>
<p>reactor：主线程只负责监听，有事件就立即通知工作线程，将socket事件放入请求队列，交给工作线程处理。读写数据、接受新连接以及处理事件都在工作线程中完成。</p>
<p>proactor：所有IO操作都交给主线程和内核来处理（包括读和写），工作线程仅负责业务逻辑。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>将每个定时事件分别封装成定时器，并使用某种容器类数据结构， 比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理</p>
<p>Linux提供了三种定时方法，它们是：</p>
<p> ❑socket选项SO_RCVTIMEO和SO_SNDTIMEO</p>
<p>❑SIGALRM信号</p>
<p>❑I&#x2F;O复用系统调用的超时参数</p>
<h3 id="socket选项SO-RCVTIMEO和-SO-SNDTIMEO"><a href="#socket选项SO-RCVTIMEO和-SO-SNDTIMEO" class="headerlink" title="socket选项SO_RCVTIMEO和 SO_SNDTIMEO"></a>socket选项SO_RCVTIMEO和 SO_SNDTIMEO</h3><p>设置socket接收数据超时时间和发送数据超时时间</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240303162229015.png" alt="image-20240303162229015"></p>
<p>根据系统调用（send、 sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断 超时时间是否已到，进而决定是否开始处理定时任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec=time;</span><br><span class="line">    timeout.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(timeout);</span><br><span class="line">    ret = setsockopt(sockfd,SOL_SOCKET,SO_SNDTIMEO,&amp;timeout,len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINPROGRESS)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; connecting timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SIGALARM信号"><a href="#SIGALARM信号" class="headerlink" title="SIGALARM信号"></a>SIGALARM信号</h3><p>由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来处理定时任务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\discuss_1682656246568.jpeg" alt="discuss_1682656246568"></p>
<p>Linux下有三种IO复用方式：epoll，select和poll，为什么用epoll，它和其他两个有什么区别呢？（参考StackOverflow上的一个问题：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select">Why is epoll faster than select?</a>）</p>
<p><strong>文件描述符的添加地点、存储方式，检测事件发生的工作方式、文件描述符的操作模式（LT和ET模式）</strong></p>
<ul>
<li>对于select和poll来说，所有文件描述符都是<strong>在用户态被加入</strong>其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；<strong>epoll则将整个文件描述符集合维护在内核态</strong>，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，由于这些大量的系统调用开销epoll可能会慢于select和poll。</li>
<li><strong>select使用线性表</strong>描述文件描述符集合，文件描述符有上限；<strong>poll使用链表</strong>来描述；<strong>epoll底层通过红黑树</strong>来描述，并且<strong>维护一个ready list</strong>，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。</li>
<li>select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，<strong>当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符</strong>，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。</li>
<li>select和poll都只能工作在相对低效的LT模式下，而<strong>epoll同时支持LT和ET模式。</strong></li>
<li>综上，当监测的<strong>fd数量较小</strong>，且<strong>各个fd都很活跃的情况</strong>下，建议<strong>使用****select和poll</strong>；当监听的<strong>fd数量较</strong>多，且单位时间仅<strong>部分fd活跃</strong>的情况下，<strong>使用epoll</strong>会明显提升性能。</li>
</ul>
<p>c++程序中使用pthread_creat时，该函数的第3个参数必须指向一个静态函数</p>
<p>当调用一个对象的成员函数（非静态成员函数）时，系统会把该对象的起始地址赋给成员函数的this指针，非静态成员函数实际上都是包含了调用他们对象的this指针，经编译器优化，变为： void *worker(this，void *args); 线程函数worker函数形式规定为 void *worker(void *args)，少了this，所以必须为静态函数。而静态成员函数因为不属于某一个对象，和任何对象无关，所以没有this指针。</p>
<hr>
<h1 id="linux高性能服务器编程（游双）笔记"><a href="#linux高性能服务器编程（游双）笔记" class="headerlink" title="linux高性能服务器编程（游双）笔记"></a>linux高性能服务器编程（游双）笔记</h1><p><strong>服务器主要有两种并发编程模式：半同步&#x2F;半异步（half-sync&#x2F;halfasync）模式和领导者&#x2F;追随者（Leader&#x2F;Followers）模</strong></p>
<p><strong>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指 的是程序的执行需要由系统事件来驱动</strong>（中断、信号等）</p>
<p><img src="D:\Blog\source_posts\基于http的Linux高性能并发服务器\image-20240303130817904.png" alt="image-20240303130817904"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/01/13/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" rel="next" title="TCP可靠传输机制">
      TCP可靠传输机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">第一章 Linux系统编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-gcc"><span class="nav-number">1.1.</span> <span class="nav-text">1 gcc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">1.2.</span> <span class="nav-text">2 静态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">1.3.</span> <span class="nav-text">3 动态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.</span> <span class="nav-text">4 静态库和动态库对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Makefile"><span class="nav-number">1.5.</span> <span class="nav-text">5 Makefile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-GDB"><span class="nav-number">1.6.</span> <span class="nav-text">6 GDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%96%87%E4%BB%B6io"><span class="nav-number">1.7.</span> <span class="nav-text">7 文件io</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open"><span class="nav-number">1.7.1.</span> <span class="nav-text">open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write"><span class="nav-number">1.7.2.</span> <span class="nav-text">write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lseek"><span class="nav-number">1.7.3.</span> <span class="nav-text">lseek</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stat-lstat"><span class="nav-number">1.7.4.</span> <span class="nav-text">stat lstat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access"><span class="nav-number">1.7.5.</span> <span class="nav-text">access</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chmod"><span class="nav-number">1.7.6.</span> <span class="nav-text">chmod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate"><span class="nav-number">1.7.7.</span> <span class="nav-text">truncate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mkdir"><span class="nav-number">1.7.8.</span> <span class="nav-text">mkdir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chdir-getcwd"><span class="nav-number">1.7.9.</span> <span class="nav-text">chdir getcwd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#opendir-readdir-closedir"><span class="nav-number">1.7.10.</span> <span class="nav-text">opendir readdir closedir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup-dup2"><span class="nav-number">1.7.11.</span> <span class="nav-text">dup  dup2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fcntl"><span class="nav-number">1.7.12.</span> <span class="nav-text">fcntl</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="nav-number">2.</span> <span class="nav-text">第二章 Linux多进程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 进程概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 进程状态转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 进程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.4.</span> <span class="nav-text">2.4  父子进程虚拟地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-GDB%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 GDB多进程调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 exec函数族</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">2.7.1.</span> <span class="nav-text">进程退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.7.2.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.7.3.</span> <span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-number">2.7.4.</span> <span class="nav-text">进程回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%EF%BC%88%EF%BC%89"><span class="nav-number">2.7.5.</span> <span class="nav-text">wait（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#waitpid%EF%BC%88%EF%BC%89"><span class="nav-number">2.7.6.</span> <span class="nav-text">waitpid（）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1IPC"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 进程间通信IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">2.8.1.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">2.8.2.</span> <span class="nav-text">内存映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.8.3.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.8.4.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.8.5.</span> <span class="nav-text">共享内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 守护进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="nav-number">3.</span> <span class="nav-text">第三章  Linux多线程开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 线程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">3.1.1.</span> <span class="nav-text">线程的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">3.1.2.</span> <span class="nav-text">线程共享和非共享资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-create"><span class="nav-number">3.2.1.</span> <span class="nav-text">pthread_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-exit-pthread-self-pthread-equal"><span class="nav-number">3.2.2.</span> <span class="nav-text">pthread_exit()  pthread_self()  pthread_equal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-join"><span class="nav-number">3.2.3.</span> <span class="nav-text">pthread_join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-detach"><span class="nav-number">3.2.4.</span> <span class="nav-text">pthread_detach()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cancel"><span class="nav-number">3.2.5.</span> <span class="nav-text">pthread_cancel()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.3.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">3.3.2.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.3.3.</span> <span class="nav-text">互斥条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">3.3.4.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.5.</span> <span class="nav-text">条件变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">第四章 Linux网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SOCKET"><span class="nav-number">4.1.</span> <span class="nav-text">SOCKET</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">4.2.</span> <span class="nav-text">字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket%E5%9C%B0%E5%9D%80"><span class="nav-number">4.3.</span> <span class="nav-text">socket地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.</span> <span class="nav-text">IP地址转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">4.5.</span> <span class="nav-text">TCP通信流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">4.6.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="nav-number">4.7.</span> <span class="nav-text">端口复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.8.</span> <span class="nav-text">IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">4.8.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">4.8.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">4.8.3.</span> <span class="nav-text">epoll</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="nav-number">5.</span> <span class="nav-text">第五章 项目实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5"><span class="nav-number">5.1.</span> <span class="nav-text">阻塞和非阻塞、同步&#x2F;异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unix-Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">Unix&#x2F;Linux上的五种IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">5.3.</span> <span class="nav-text">HTTP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reactor%E5%92%8Cproactor"><span class="nav-number">5.4.</span> <span class="nav-text">reactor和proactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">5.5.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E9%80%89%E9%A1%B9SO-RCVTIMEO%E5%92%8C-SO-SNDTIMEO"><span class="nav-number">5.5.1.</span> <span class="nav-text">socket选项SO_RCVTIMEO和 SO_SNDTIMEO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGALARM%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.5.2.</span> <span class="nav-text">SIGALARM信号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%88%E6%B8%B8%E5%8F%8C%EF%BC%89%E7%AC%94%E8%AE%B0"><span class="nav-number">7.</span> <span class="nav-text">linux高性能服务器编程（游双）笔记</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小白"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">小白</p>
  <div class="site-description" itemprop="description">月下惊鸿影，疑是画中仙</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1909414208&auto=1&height=66"></iframe>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小白</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">114k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:44</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动-->
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
