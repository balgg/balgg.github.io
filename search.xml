<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/03/08/6.s081%E9%A1%B9%E7%9B%AE%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h2 id="1-RISC-V和ARM架构的关系？"><a href="#1-RISC-V和ARM架构的关系？" class="headerlink" title="1 RISC-V和ARM架构的关系？"></a>1 RISC-V和ARM架构的关系？</h2><p>risc-v是一种基于精简指令集risc的开放架构，可以自由使用和定制，例如阿里的玄铁910就是risc-v处理器</p>
<p>arm也是精简指令集的cpu架构，它在嵌入式、移动设备和服务器领域广泛使用，但它是专有的</p>
<h2 id="2-这个项目的运行环境是什么？"><a href="#2-这个项目的运行环境是什么？" class="headerlink" title="2 这个项目的运行环境是什么？"></a>2 这个项目的运行环境是什么？</h2><p>xv6 操作系统运⾏在 qemu 模拟的硬件环境中，qemu通过模拟硬件设备的行为来实现对硬件设备的支持，例如硬盘、网卡、串口等</p>
<h2 id="3-risv-v是几级流水？"><a href="#3-risv-v是几级流水？" class="headerlink" title="3 risv-v是几级流水？"></a>3 risv-v是几级流水？</h2><p>五级流水</p>
<p>取指（Fetch）：从内存中取出指令。 </p>
<p>译码（Decode）：解码指令，确定要执⾏的操作和操作数。 </p>
<p>执⾏（Execute）：执⾏指令的操作，可能涉及算术逻辑运算、内存访问等。 </p>
<p>访存（Memory）：如果指令需要访问内存（如加载或存储指令），则在这个阶段进⾏内存访问。 </p>
<p>写回（Write Back）：将执⾏阶段计算的结果写回寄存器⽂件</p>
<h2 id="4-进程的上下文切换？"><a href="#4-进程的上下文切换？" class="headerlink" title="4 进程的上下文切换？"></a>4 进程的上下文切换？</h2><p><strong>用户级上下文：正文、数据、用户堆栈和共享存储区</strong></p>
<p><strong>寄存器上下文：程序计数器PC、处理器状态寄存器、通用寄存器、栈指针</strong></p>
<p><strong>系统级上下文：进程控制块、内存管理信息、内核堆栈等</strong></p>
<p>注：</p>
<p><strong>cpu上下文：cpu寄存器和程序计数器PC</strong></p>
<p>cpu执行不同的任务，需要上下文切换，而根据任务的不同，可以分为三类：<strong>进程上下文切换、线程上下文切换、中断上下文切换</strong></p>
<p>线程上下文切换：如果属于同一个进程：只切换私有数据，如栈和寄存器，对于共享的内存和全局变量等不需要修改；如果属于不同进程，与进程切换一样。</p>
<p>中断上下文切换：<strong>不涉及到进程的用户态，对同一个 CPU 来说，中断处理比进程拥有更高的优先级</strong>。包括：CPU 寄存器、内核堆栈、硬件中断参数等。</p>
<p>一次系统调用，发生了两次cpu上下文切换（系统调用是在同一个进程中发生的）</p>
<h2 id="5-用户态陷入内核态的三种方式？"><a href="#5-用户态陷入内核态的三种方式？" class="headerlink" title="5 用户态陷入内核态的三种方式？"></a>5 用户态陷入内核态的三种方式？</h2><p>系统调用、中断、异常</p>
<h2 id="6-为什么要有虚拟内存？"><a href="#6-为什么要有虚拟内存？" class="headerlink" title="6 为什么要有虚拟内存？"></a>6 为什么要有虚拟内存？</h2><p>（什么是虚拟内存？为什么要进行内存管理？）</p>
<p>操作系统提供的一种内存管理机制，它将不同进程的虚拟地址和不同内存的物理地址映射起来（ 通过CPU 芯片中的内存管理单元（MMU））。</p>
<p>1、内存隔离：直接使用物理地址可能导致多个程序之间有干扰和冲突，虚拟地址为每一个进程提供一个独立的、一致的地址空间，这种隔离提高了程序运行时的安全和稳定</p>
<p>2、更大的地址空间：程序运行符合局部性原理，cpu访问内存有明显的重复性，对于不经常使用的内存，可以把它先换出到物理内存之外，如硬盘上的swap空间</p>
<p>3、内存映射和文件共享：可以将⽂件映射到进程的地址空间中，不用到磁盘中操作文件，还可以在多个进程间共享</p>
<p>4、内存分配：使用虚拟地址编程时无需考虑底层硬件的实际物理地址，简化了内存管理和分配</p>
<h3 id="引申：为什么有更大的地址空间？"><a href="#引申：为什么有更大的地址空间？" class="headerlink" title="引申：为什么有更大的地址空间？"></a>引申：为什么有更大的地址空间？</h3><p>​	操作系统利用缺页异常机制，实现了写时复制、内存懒分配和磁盘交换等技术，为进程提供了许多‘虚假’的虚拟内存，它们可能没有对应的物理内存，也可能对应的物理内存被交换到了磁盘中，从而在进程视角中拥有远超物理内存的虚拟内存量</p>
<h2 id="7、虚拟内存怎么实现？"><a href="#7、虚拟内存怎么实现？" class="headerlink" title="7、虚拟内存怎么实现？"></a>7、虚拟内存怎么实现？</h2><p>（操作系统如何管理虚拟地址与物理地址之间的关系？）</p>
<p>内存分段和内存分页</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>​	分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong></p>
<p>​	段选择因子里面最重要的是<strong>段号</strong>，用作段表的索引</p>
<p>​	<strong>虚拟地址通过段表与物理地址进行映射，有了段号和段内偏移量就可以找到物理内存中的地址</strong></p>
<p>**	分段产生的问题：（外部）内存碎片和内存交换效率低**</p>
<p>​	内存分段可以根据实际需求分配内存，每个段内部是连续的，不会产生内部内存碎片，但各段之间会产生外部内存碎片（例如有三个段，中间那个段的程序结束，内存释放后就会产生碎片）</p>
<p>​	解决外部内存碎片的方式就是内存交换，把内存上的一部分内存先写到硬盘上，再从硬盘读回来，把碎片的位置占满</p>
<p>​	但如果交换的内存很大，就会有卡顿，因为硬盘访问速度比内存慢的多。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页解决了分段的外部内存碎片和内存交换效率低的问题，</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>，通过页表映射</p>
<p>（linux页的大小为4KB）</p>
<p><strong>为什么要有多级页表？</strong>减少页表所占空间，前一级的页表可以用更少的空间覆盖全部的虚拟地址，后一级的页表在需要时创建即可（局部性原理）</p>
<p><strong>多级页表的效率怎么解决？</strong>TLB快表（页表缓存），把最常访问的几个页表项存储到访问速度更快的硬件缓存中</p>
<p><strong>谁来管理虚拟内存？</strong>CPU的内存管理单元MMU，他负责完成地址映射和TLB的访问与交互</p>
<p><strong>缺页异常（中断）？进程要访问的物理地址在页表中查不到</strong>，需要进入内核分配物理内存，更新进程页表，再返回用户空间，恢复进程运行</p>
<p><strong>页面置换算法？</strong>如果触发缺页异常时，物理内存已满，需要【页面置换算法】选择一个物理页换出到磁盘，并把需要访问的页面放到这个物理页中</p>
<p>算法原则：尽可能减少页面的换入换出次数</p>
<ul>
<li>最佳页面置换算法（<em>OPT</em>）</li>
<li>先进先出置换算法（<em>FIFO</em>）</li>
<li>最近最久未使用的置换算法（<em>LRU</em>）–时间</li>
<li>时钟页面置换算法（<em>Lock</em>）</li>
<li>最近最不常用置换算法（<em>LFU</em>）–频率</li>
</ul>
<p><strong>系统抖动？</strong>页刚被换出，根据请求又马上被换入，这种反复频繁的页面置换就被称为系统抖动。解决方法：选取合适的置换算法</p>
<h2 id="8-内存分配的过程是怎样的？（内存回收）"><a href="#8-内存分配的过程是怎样的？（内存回收）" class="headerlink" title="8 内存分配的过程是怎样的？（内存回收）"></a>8 内存分配的过程是怎样的？（内存回收）</h2><p>​	malloc申请的是虚拟内存，一开始并不会分配物理内存，当应用程序读写了这块虚拟内存，cpu就会去访问它，发现没有映射到实际的物理内存，cpu就会产生缺页中断，进程切换到内核态，交给缺页中断函数处理。</p>
<p>​	缺页中断函数会看是否有空闲的物理内存，如果有，直接分配，并建立映射；如果没有内核就会开始回收内存，有两种方式：后台内存回收和直接内存回收</p>
<ul>
<li>后台内存回收（kswapd）：在物理内存紧张时，会唤醒kswaped内核线程来回收内存（异步，不阻塞进程执行）</li>
<li>直接内存回收：如果后台内存回收跟不上进程内存申请的速度，就会开始直接回收（同步，会阻塞进程执行）</li>
</ul>
<p>如果直接内存回收后仍不满足物理内存的申请，就会触发OOM机制（Out of Memory）：OOM Killer机制会根据算法选择一个物理内存占用较高的进程将其杀死，以便释放内存资源（这个过程会重复，直到有足够内存）</p>
<p><strong><img src="D:\Blog\source_posts\6.s081项目八股\image-20240309180738654.png" alt="image-20240309180738654"></strong></p>
<h2 id="9-哪些内存可以被回收？（释放）"><a href="#9-哪些内存可以被回收？（释放）" class="headerlink" title="9 哪些内存可以被回收？（释放）"></a>9 哪些内存可以被回收？（释放）</h2><p><strong>文件页：</strong>内核缓存的磁盘数据和文件数据。</p>
<p>​	回收干净页可以直接释放内存，回收脏页需要先写回磁盘后再释放内存（脏页：被修改过，但还没被写入磁盘）</p>
<p><strong>匿名页：</strong>没有实际载体，如堆、栈数据等。</p>
<p>​	通过linux的Swap机制，把不常访问的内存先换到磁盘，然后释放这些内存，等再访问时重新从磁盘读入</p>
<p>内存回收基于LRU算法（最久不使用）</p>
<h3 id="注：内存回收有性能影响吗？"><a href="#注：内存回收有性能影响吗？" class="headerlink" title="注：内存回收有性能影响吗？"></a>注：内存回收有性能影响吗？</h3><p>对于文件页的回收，如果是干净页，不会影响；如果是脏页，会发生磁盘IO，会影响系统性能</p>
<p>对于匿名页的回收，Swap机制是换到磁盘中，有IO操作，影响性能</p>
<p>基于此，我们可以减少匿名页的回收：Linux提供了一个<code> swappiness</code>的选项，0-100数值越大越倾向于使用Swap，可以将其调小一点（默认60）</p>
<h2 id="10-malloc申请的内存，free释放内存会归还给操作系统吗？"><a href="#10-malloc申请的内存，free释放内存会归还给操作系统吗？" class="headerlink" title="10 malloc申请的内存，free释放内存会归还给操作系统吗？"></a>10 malloc申请的内存，free释放内存会归还给操作系统吗？</h2><ul>
<li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>（程序结束时归还）</li>
<li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong></li>
</ul>
<h3 id="注：为什么brk（）申请内存更好？"><a href="#注：为什么brk（）申请内存更好？" class="headerlink" title="注：为什么brk（）申请内存更好？"></a>注：为什么brk（）申请内存更好？</h3><p>brk（）在堆中申请内存，由于堆是连续的，可以直接预分配更大的内存缓存在内存池中，等下次再申请内存时，直接取已经有映射的内存块就行，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，降低了cpu的消耗</p>
<h3 id="注：那为什么不全部用brk（）？"><a href="#注：那为什么不全部用brk（）？" class="headerlink" title="注：那为什么不全部用brk（）？"></a>注：那为什么不全部用brk（）？</h3><p>会产生很多不可用的内存碎片，导致内存泄漏</p>
<h2 id="11-如何避免预读失效和缓存污染？"><a href="#11-如何避免预读失效和缓存污染？" class="headerlink" title="11 如何避免预读失效和缓存污染？"></a>11 如何避免预读失效和缓存污染？</h2><p><strong>预读机制：</strong>Linux基于Page Cache的读缓存机制，根据空间局部性原理，在将磁盘数据加载到内存时会往后多读一些page，下次在往后读时就可以直接在Page Cache中命中，减少了磁盘IO的次数</p>
<p><strong>预读失效：</strong>如果被提前加载进来的页并没有被访问，就是预读失效</p>
<p>预读失效的问题主要体现在传统LRU算法上，它会把没被访问的预读页添加到链表头部，可能会把热点数据挤到链表尾部，甚至是淘太，这就大大降低了缓存命中率</p>
<p><strong>如何避免：</strong>改进LRU算法，采用<strong>活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）</strong>，将预读页加入到非活跃LRU链表，只有当页真正被访问时，才将其插入活跃LRU链表头部，这样就不会影响活跃链表中的热点数据。</p>
<p>（MySql的Innodb存储引擎将LRU链表划分为young区域和old区域，分别有各自的头尾节点，改进原理跟linux的一样）</p>
<p><strong>缓存污染：</strong>在批量读取数据时，由于这些数据被访问了一次，会将其加入到活跃LRU链表，而之前缓存在活跃LRU链表上的热点数据都会被淘太，如果新加入的这些数据并不是热点数据（很久都不会再访问），那整个LRU链表就相当于被污染了</p>
<p>这会导致，当这些被淘汰的热点数据再次被访问时，由于缓存未命中，就会产生大量的磁盘IO，系统性能会急剧下降</p>
<p><strong>如何避免：</strong>提高进入LRU活跃链表的门槛。linux在内存页被访问第二次时，才将其加入到活跃链表；Mysql不仅要内存页被访问第二次，还要判断两次访问的时间间隔是否达到要求（在非活跃LRU链表中停留时间是否够长）</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2024/01/13/HTTP/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>超文本传输协议（在计算机世界里专门在 <strong>两点之间</strong> 传输 <strong>文字、图片、音频和视频</strong>等超文本数据的 <strong>约定和规范</strong>）</p>
<h1 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h1><p><img src="https://uploader.shimo.im/f/dceIyQvRA2nAilEW.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzIzNDIsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjA0MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.NfcEh5GsSntz9PTzP3GrthIzXWPCldkTU6OjdZZnaQg" alt="img"></p>
<ul>
<li>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
<li><code>5xx</code> 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</li>
</ul>
<h1 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h1><p><em><strong>Host字段</strong></em></p>
<p>客户端发送请求时，用来指定服务器的域名（有了Host字段，就可以将请求发往同一服务器上的不同网站）</p>
<p><img src="https://uploader.shimo.im/f/tyCeIwo1lZOxMVNm.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI1MTMsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjIxMywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.Mf2LO68QOLRs2BaQvz7qySMRZ0J_KpRSFomzwGdIGno" alt="img"></p>
<p><em><strong>Content-Length 字段</strong></em></p>
<p>服务器在返回数据时，表明本次回应的数据长度</p>
<p>（作为 HTTP body 的边界解决“粘包”的问题）</p>
<p><img src="https://uploader.shimo.im/f/k7FAQCMKrQvYNloJ.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI1NjIsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjI2MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.VC6_SMgF0TFgPhXOGsh1SXS2SNdtxkatnuA-KyiUkpw" alt="img"></p>
<p><em><strong>Connection 字段</strong></em></p>
<p>常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用（HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。）</p>
<p><img src="https://uploader.shimo.im/f/PAHYAqxJxFdgS3U7.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI2MTYsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjMxNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.LATFDsceK3vgmPduHDFQvR4t00zRwCO585x_U6CCVf8" alt="img"></p>
<p><em><strong>Content-Type 字段</strong></em></p>
<p>服务器响应时，告诉客户端本次数据的格式</p>
<p><img src="https://uploader.shimo.im/f/21X8kwthQKqlesUX.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI2MzUsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjMzNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.Ha4t5SgwHyigXeiwDBCIA9hPkSXQJv3HnifD4QFa8dk" alt="img"></p>
<p><em><strong>Content-Encoding 字段</strong></em></p>
<p>说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p>
<p><img src="https://uploader.shimo.im/f/OYDSteGj2OhMvUKP.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI2NTAsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjM1MCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.O1xD5FnzBj4K790bCIWggZYYd2d8SBY7DwZzhjtbtlg" alt="img"></p>
<h1 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h1><p>GET 的语义是从服务器获取指定的资源</p>
<p><img src="https://uploader.shimo.im/f/vGs0nvTdg9acDNrE.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI3MDQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjQwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0._UloSkNApzUSUoOv7aMbhpXb95nk081theBjcRpAvbU" alt="img"></p>
<p><img src="https://uploader.shimo.im/f/vGs0nvTdg9acDNrE.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI3MDQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjQwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0._UloSkNApzUSUoOv7aMbhpXb95nk081theBjcRpAvbU" alt="img">POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</p>
<p><img src="https://uploader.shimo.im/f/MS9cZKUxBnbrpJc5.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI3MDQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjQwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0._UloSkNApzUSUoOv7aMbhpXb95nk081theBjcRpAvbU" alt="img"></p>
<ul>
<li><p><strong>GET对数据长度有限制</strong>（因为URL的限制），POST无限制</p>
</li>
<li><p><strong>GET只允许 ASCII 字符</strong>，<strong>POST无限制</strong></p>
</li>
<li><p><strong>GET安全</strong>（不修改服务器资源，只读）、<strong>幂等</strong>（重复操作结果相同）、<strong>可被缓存</strong>；<strong>POST不安全</strong>（修改服务器数据），<strong>不幂等</strong>，（大部分实现）<strong>不可缓存</strong></p>
</li>
<li><p><strong>GET 显示在 URL 上，POST 通过表单提交不显示在 URL 上</strong></p>
<p>（有敏感数据使用POST，但并不能说 GET 不如 POST 安全，因为HTTP 传输的内容都是明文的，要避免传输过程中数据被窃取，就要使用 HTTPS ，这样所有 HTTP 的数据都会被加密传输）</p>
</li>
</ul>
<p>注：get请求可以带body（通常不需要所以才不带）</p>
<h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>强制缓存和协商缓存</p>
<p><strong>强制缓存</strong>：</p>
<p>​	只要<strong>浏览器判断</strong>缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<p>利用下面这两个 HTTP 响应头部（Response Header）字段实现</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p><strong>协商缓存</strong>：</p>
<p>​	<strong>与服务端协商</strong>之后，通过协商结果来判断是否使用本地缓存</p>
<p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<h1 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h1><p>常见到版本有 HTTP&#x2F;1.1，HTTP&#x2F;2.0，HTTP&#x2F;3.0</p>
<p><strong>HTTP&#x2F;1.1</strong></p>
<ul>
<li>优点：<ul>
<li>简单（报文格式header+body）</li>
<li>灵活和易于扩展（HTTPS、HTTP&#x2F;2.0、HTTP&#x2F;3.0）</li>
<li>应用广泛和跨平台（台式机上的浏览器到各种手机app）</li>
</ul>
</li>
<li>缺点：<ul>
<li>无状态（双刃剑）—服务器不会去记忆 HTTP 的状态<ul>
<li>优点：不需要额外资源记录，减轻服务器负担</li>
<li>缺点：完成有关联性的操作时很麻烦（购物每次都要认证身份）<ul>
<li>解决方式： Cookie 技术（在请求和响应报文中写入 Cookie 信息来控制客户端的状态）。客户端第一次请求后，会保存服务器在响应中添加的cookie，再次请求时服务器就会检查cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://uploader.shimo.im/f/29V0Jb1dmNHZp6Hg.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzQ2MDUsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczNDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.RquSuhiCxSxVNmXVGgTUAJtrLr29lrIuNbYDx60VeiM" alt="img"></p>
<ul>
<li>明文传输（双刃剑）<ul>
<li>方便调试，抓包可直接查看</li>
<li>信息裸奔</li>
</ul>
</li>
<li>不安全<ul>
<li>可以用 HTTPS 方式解决，引入SSL&#x2F;TLS层</li>
</ul>
</li>
</ul>
<p>性能方面：基于 TCP&#x2F;IP，并且使用了「请求 - 应答」的通信模式，采用长连接，减少了TCP连接的重复建立和断开的额外开销，减轻服务器的负载（HTTP1.0是短连接）</p>
<h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><h2 id="有哪些区别？"><a href="#有哪些区别？" class="headerlink" title="有哪些区别？"></a>有哪些区别？</h2><ul>
<li>HTTPS 更安全，解决了HTTP明文传输的缺陷，在TCP和HTTP之间加入了SSL&#x2F;TLS安全协议，使报文能加密传输</li>
<li>HTTPS在三次握手后，还需要进行SSL&#x2F;TLS的握手过程</li>
<li>HTTP端口号80，HTTPS端口号443</li>
<li>HTTPS需要申请数字证书（保证服务器身份可信）</li>
</ul>
<h2 id="HTTPS解决了HTTP哪些问题？"><a href="#HTTPS解决了HTTP哪些问题？" class="headerlink" title="HTTPS解决了HTTP哪些问题？"></a>HTTPS解决了HTTP哪些问题？</h2><p>1）通过<strong>混合加密</strong>方式，实现信息机密性，防止被窃听</p>
<p>​	非对称加密（公钥和私钥）–通信建立前</p>
<p>​	对称加密（一个密钥）–通信过程中</p>
<p>2）通过<strong>摘要算法+数字签名</strong>的校验机制，防止数据被篡改</p>
<p>​	摘要算法：比对哈希值</p>
<p>​	数字签名：非对称加密（私钥加密，公钥解密）</p>
<p>3）通过<strong>数字证书</strong>的身份认证机制，防止被冒充</p>
<p>​	将公钥放在CA数字证书中，保证公钥身份可靠</p>
<h2 id="HTTPS一定安全可靠吗？"><a href="#HTTPS一定安全可靠吗？" class="headerlink" title="HTTPS一定安全可靠吗？"></a>HTTPS一定安全可靠吗？</h2><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的。</strong></p>
<p>存在这种情况：如果有假基站将信息转发给【中间人服务器】，客户端和【中间人】完成TLS握手，【中间人】和服务器完成TLS握手，中间人不就能获取全部信息？</p>
<p>理论上可以，但前提是在TLS握手时，客户端的用户要点击继续访问【中间人】伪造的证书，因为浏览器是能够识别出【中间人】伪造的证书是非法的，会提醒用户。</p>
<p><strong>如何避免被【中间人抓取数据】？</strong></p>
<p>不中病毒（被恶意导入了中间人的根证书）；不点击任何证书非法网站；采用HTTPS双向认证（增加了服务端对客户端的验证）</p>
<h1 id="HTTP1-1-HTTP2-HTTP3-的优化"><a href="#HTTP1-1-HTTP2-HTTP3-的优化" class="headerlink" title="HTTP1.1 HTTP2 HTTP3 的优化"></a>HTTP1.1 HTTP2 HTTP3 的优化</h1><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p><strong>HTTP1.1</strong>相比HTTP1.0的改进：</p>
<ul>
<li>长连接：减少短连接的性能开销</li>
<li>管道网络传输：可以连续发送请求，不用等待响应后再发送（解决了请求的队头阻塞，但仍然有响应的队头阻塞问题）</li>
</ul>
<p>缺陷（性能瓶颈）：</p>
<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送</li>
<li>队头阻塞</li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端发出，服务器只能被动响应</li>
</ul>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><ul>
<li><p>基于HTTPS，安全性较高</p>
</li>
<li><p>头部压缩：HPACK算法</p>
</li>
<li><p>二进制格式：（原先是纯文本形式）提高了数据传输效率</p>
</li>
<li><p>并发传输：stream（多个stream复用一个TCP连接）</p>
</li>
<li><p>服务器可主动推送资源</p>
<p>缺陷：</p>
<p>HTTP2基于 TCP 协议来传输数据，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，因此，当TCP层出现丢包，需要等待重传，就还会出现<strong>队头阻塞</strong>问题</p>
</li>
</ul>
<h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><p>把 HTTP 下层的 TCP 协议改成了 <strong>UDP</strong></p>
<p>基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输</p>
<p>（QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议）</p>
<p>QUIC 有以下 3 个特点</p>
<ul>
<li><strong>无队头阻塞</strong>：stream相互独立</li>
<li><strong>更快的连接建立</strong>：QUIC的三次握手（内部包含了TLS）取代了 TCP三次握手+TLS1.2四次握手  （TLS1.3三次握手）</li>
<li><strong>连接迁移</strong>：通过连接 ID 来标记通信的两个端点（TCP是四元组）</li>
</ul>
<p><img src="https://uploader.shimo.im/f/TsETyOBpdpZXySxB.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3NDIxOTQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzc0MTg5NCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.yrEY353STJ43LXfT7h7U7Fr5bRKQ6igZvuCzKnz5lVE" alt="img"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>TCP可靠传输机制</title>
    <url>/2024/01/13/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>发送数据时设定一个定时器，在规定时间内没有收到对方的ACK，就重发该数据</p>
<p>两种情况触发</p>
<ul>
<li>数据包丢失（接收方没有收到数据）</li>
<li>ACK丢失（发送方没有收到ACK）</li>
</ul>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong></p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时的间隔加倍。</strong></p>
<p>问题：超时周期可能相对较长</p>
<p>解决：快速重传</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>不以时间为驱动，而是以数据为驱动</p>
<p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段</p>
<p>（第一个报文丢失，后续发送过来的报文都回复同样的ACK）</p>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109095831996.png" alt="image-20240109095831996" style="zoom: 67%;" />

<p>问题：发送方不清楚重传的时候，是重传一个（seq2），还是重传所有（因为后续接收方都回ACK2，不知道seq3、4、5报文是否也丢失）</p>
<p>解决：SACK方法</p>
<h2 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h2><p><code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong></p>
<p>实现：在TCP头部【选项】字段加一个SACK，它可以将已收到的数据信息发给发送方（发送方知道了哪些数据没收到，就只重传丢失的数据）</p>
<h2 id="D-SACK方法"><a href="#D-SACK方法" class="headerlink" title="D-SACK方法"></a>D-SACK方法</h2><p><strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong></p>
<p>应用于两个场景：</p>
<ul>
<li>ACK丢包</li>
<li>网络延时</li>
</ul>
<p>区分上面两种（第一种发送方没有收到ACK，第二种发送方连续收到重复ACK）</p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul>
<li><p>引入原因：</p>
<p>TCP是每发一个数据，都要一次确认应答，上一个数据包收到应答后，再发送下一个。数据包的往返时间越长，通信效率越低。</p>
</li>
<li><p>窗口：实质是操作系统开辟的一个缓存空间（发送方）</p>
<p>（收到确认应答前，在缓存空间中保留已发送的数据，如果按期收到确认应答，就将数据从缓存空间清除）</p>
</li>
<li><p>窗口大小：无需等待确认应答，而可以继续发送数据的最大值</p>
</li>
<li><p>累计确认：后面的ACK可以确认前面的数据已被接收，即使前一个ACK丢失也没关系</p>
</li>
</ul>
<p>窗口大小由哪一方决定？</p>
<p>​	接收方</p>
<p>​	因为发送方发送的数据大小不能超过接收方的窗口大小，否则接收方会处理不过来导致丢包</p>
<p>​	TCP有一个Window字段，是接收端告诉发送端自己还有多少缓冲区可以接收数据</p>
<p><img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109105354734.png" alt="image-20240109105354734"></p>
<p><strong>注：发送窗口&lt;&#x3D;接收窗口</strong></p>
<h2 id="缓存区与滑动窗口的关系"><a href="#缓存区与滑动窗口的关系" class="headerlink" title="缓存区与滑动窗口的关系"></a>缓存区与滑动窗口的关系</h2><p>如果发生了先减少缓存，再收缩窗口，<strong>就会出现丢包的现象</strong></p>
<p>*<em>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</em></p>
<h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<p>如果通告窗口非0的 ACK 报文在网络中丢失，会造成死锁（双方都在等待对方发送数据）</p>
<p>解决：<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><p>现象：接收方腾出几个字节就立即告诉发送方窗口有几个空闲的位置，发送方会义无反顾地发送这几个字节。</p>
<p>（头部开销很大，实际传输数据量很小）</p>
<p>糊涂窗口综合症的现象发生在发送方和接收方：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>发送方可以发送小数据</li>
</ul>
<p>解决：</p>
<ul>
<li><p>发送方使用Nagle算法，满足以下条件之一才可以发送数据</p>
<ul>
<li>条件1：窗口大小&gt;&#x3D;MSS 且 可发送的数据大小&gt;&#x3D;MSS</li>
<li>条件2：收到之前发送数据的 <code>ack</code> 回包</li>
</ul>
</li>
<li><p>接收方的 窗口大小 &gt;&#x3D; MSS 或 缓存空间有一半可以使用，再通知发送方窗口大小非0</p>
</li>
</ul>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p><strong>避免「发送方」的数据填满整个网络</strong></p>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个状态变量，<strong>它会根据网络的拥塞程度动态变化的</strong></p>
<p>发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值</p>
<p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<p>拥塞控制四种算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>TCP 在刚建立连接完成后，首先是有个【慢启动】的过程，这个慢启动的意思就是<strong>一点一点的提高发送数据包的数量</strong></p>
<p>规则：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</strong>（<strong>指数性的增长</strong>）</p>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109171932406.png" alt="image-20240109171932406" style="zoom:80%;" />

<p>发包数量不能无限增长，什么时候停止呢？</p>
<p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用【拥塞避免算法】。</li>
</ul>
<h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法</p>
<p>规则：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd</strong></p>
<p>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109172659680.png" alt="image-20240109172659680" style="zoom: 67%;" />

<p>一直增长，网络慢慢进入拥堵状态，出现丢包，<strong>触发重传机制，进入【拥塞发生算法】</strong></p>
<h2 id="拥塞发生算法"><a href="#拥塞发生算法" class="headerlink" title="拥塞发生算法"></a>拥塞发生算法</h2><p>【超时重传时的拥塞发生算法】</p>
<ul>
<li>慢启动门限ssthresh 设为 拥塞窗口cwnd的1&#x2F;2（<code>ssthresh=cwnd/2</code>）</li>
<li>cwnd 初始化</li>
</ul>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109173748452.png" alt="image-20240109173748452" style="zoom: 80%;" />

<p>【快速重传时的拥塞发生算法】</p>
<ul>
<li><code>ssthresh = cwnd/2</code> </li>
<li><code>cwnd = ssthresh</code></li>
<li>进入<strong>快速恢复算法</strong></li>
</ul>
<h2 id="快速恢复算法"><a href="#快速恢复算法" class="headerlink" title="快速恢复算法"></a>快速恢复算法</h2><p>快速重传和快速恢复算法一般同时使用</p>
<ul>
<li>让拥塞窗口 <code> cwnd=ssthresh+3</code>  (3 的意思是确认有 3 个数据包被收到了–三次重复ACK)</li>
<li>重传丢失的数据包</li>
<li>如果再收到重复的ACK，那么cwnd增加1（说明此时又有别的数据包被收到了，跟前面+3一个道理）</li>
<li>当收到新数据的ACK，令<code> cwnd=ssthresh</code>（恢复过程结束，再次进入【拥塞避免状态】）</li>
</ul>
<p><img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109175652172.png" alt="image-20240109175652172"></p>
<p>注：<strong>cwnd逐渐加1</strong>的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>c++语法糖</title>
    <url>/2024/02/27/c++%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="c-给vector去重的两种方法"><a href="#c-给vector去重的两种方法" class="headerlink" title="c++给vector去重的两种方法"></a>c++给vector去重的两种方法</h1><p>1、利用set的特性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(res.begin(),res.end())</span></span>;</span><br><span class="line">	res.<span class="built_in">assign</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::set会自动去除重复元素并排序，使用assign函数将集合中的元素重新存回res</p>
<p>2、结合sort、unique、erase函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	vector&lt;int&gt; res&#123;1,2,3,1,2&#125;;</span><br><span class="line">	sort(res.begin(),res.end());</span><br><span class="line">	res.erase(unique(res.begin(),res.end()),res.end());</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先sort排序，再利用unique()将相邻且重复的元素放到vector尾部（返回指向第一个重复元素的迭代器），最后用erase擦除从这个元素到最后的所有元素</p>
<h1 id="basename-提取文件名"><a href="#basename-提取文件名" class="headerlink" title="basename() 提取文件名"></a>basename() 提取文件名</h1><p>用于从一个路径字符串中提取文件名部分（不包括目录路径），并返回提取的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;libgen.h&gt;</span><br><span class="line"></span><br><span class="line">char *basename(char *path);</span><br><span class="line">- path ：路径</span><br></pre></td></tr></table></figure>

<p>注：<code>basename()</code> 函数会修改 <code>path</code> 字符串，将路径名截断为文件名。因此，如果需要保留原始路径字符串，在调用 <code>basename()</code> 函数之前创建副本</p>
<h1 id="strpbrk-检索包含字符串"><a href="#strpbrk-检索包含字符串" class="headerlink" title="strpbrk() 检索包含字符串"></a>strpbrk() 检索包含字符串</h1><p>C 库函数 <strong>char *strpbrk(const char *str1, const char *str2)</strong> 检索字符串 <strong>str1</strong> 中第一个匹配字符串 <strong>str2</strong> 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *strpbrk(const char *str1, const char *str2)</span><br><span class="line">    str1 -- 待检索的字符串</span><br><span class="line">    str2 -- 要搜索的字符串内容</span><br><span class="line">    返回值：返回指针，指向搜索到的字符在str1中的索引位置</span><br></pre></td></tr></table></figure>

<h1 id="vector初始化"><a href="#vector初始化" class="headerlink" title="vector&lt;&gt;初始化"></a>vector&lt;&gt;初始化</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p><strong>vector &lt; int &gt; v;</strong></p>
<p>这时候v的size为0，如果直接进行访问 v[i] 会报错。<br>这里可以使用 v.resize(n)，或者v.resize(n, m) 来初始化<br>前者是使用n个0来初始化，后者是使用n个m来初始化</p>
<p><strong>vector &lt; int &gt; v &#x3D; {1,2,3,4,5};</strong></p>
<p>可以使用初始化数组的方式来初始化vector，如例子所示，此时v.size() &#x3D;&#x3D; 5<br>如果这时候使用v.resize(3)，将会丢弃最后的4和5</p>
<p><strong>vector &lt; int &gt; v(n); vector &lt; int &gt; v(n,m);</strong></p>
<p>n：数量，m：取值</p>
<p><strong>vector &lt; int &gt; v(v0);</strong></p>
<p>使用另外一个数组来初始化v，注意，这里的v0也必须是vector<br>也可以写作vector &lt; int &gt; v &#x3D; v0;</p>
<p>**vector &lt; int &gt; v(<em>p, <em>q);</em></em></p>
<p>使用另外一个数组的指针来初始化v，这里即可以使用vector的指针，也可以使用普通数组的指针</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>vector &lt; vector &lt; int &gt; &gt; v</strong></p>
<p>可以先初始化二维数组的第一维，然后使用一个for循环再初始化第二维。此时myVector中的元素都是0，不是空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector &lt; vector &lt; int &gt; &gt; myVector(m);</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		myVector[i].resize(n);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>vector &lt; vector &lt; int &gt; &gt; myVector(n, testVector);</strong></p>
<p>可以直接使用n和testVector来初始化myVector，但是testVector需要是vctor类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; v(m, vector&lt;int&gt;(n,-1));</span><br></pre></td></tr></table></figure>

<h1 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set&lt;&gt;"></a>unordered_set&lt;&gt;</h1><h2 id="set-find-x"><a href="#set-find-x" class="headerlink" title="set.find(x)"></a>set.find(x)</h2><p>查找set中是否有值为x的元素（本质是查找键，unordered_set中键和值一样）</p>
<p><strong>返回值：</strong>值为x的键迭代器。若找不到这种元素，则返回尾后 end()迭代器</p>
<h2 id="set-insert-x"><a href="#set-insert-x" class="headerlink" title="set.insert(x)"></a>set.insert(x)</h2><p>插入值为x的元素（x不重复才插入）</p>
<p><strong>返回值：</strong>返回一个pair对象，pair::first指向该元素的迭代器；pair::second插入成功为true，插入失败为false（已有重复元素）</p>
<h1 id="max-element"><a href="#max-element" class="headerlink" title="max-element()"></a>max-element()</h1><p>求容器中的最大元素的位置、</p>
<p>接收参数：迭代器（区间）</p>
<p>返回值：最值元素的地址（迭代器） –  减去序列头就是元素下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(n.<span class="built_in">begin</span>(),n.<span class="built_in">end</span>()) - n.<span class="built_in">begin</span>(); <span class="comment">//最大值下标</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> minPosition = <span class="built_in">min_element</span>(n.<span class="built_in">begin</span>(),n.<span class="built_in">end</span>()) - n.<span class="built_in">begin</span>();<span class="comment">//最小值下标</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）普通数组</span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(a,a+<span class="number">2</span>) - a; <span class="comment">//最大值下标</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> minPosition = <span class="built_in">min_element</span>(a,a+<span class="number">2</span>) - a;<span class="comment">//最小值下标</span></span><br></pre></td></tr></table></figure>

<p>*<strong>max_element（）与*min_element（）</strong>分别用来求最大元素和最小元素的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	<span class="type">int</span> b = a[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> c = a[<span class="number">1</span>];</span><br><span class="line">	cout&lt;&lt;	<span class="built_in">max_element</span>(a, a+<span class="number">6</span>) - a	&lt;&lt;endl;		<span class="comment">// 输出为3 </span></span><br><span class="line">	cout&lt;&lt;	*<span class="built_in">max_element</span>(a, a+<span class="number">6</span>)	&lt;&lt;endl;		<span class="comment">//输出为 6 </span></span><br><span class="line">	cout&lt;&lt;	<span class="built_in">min_element</span>(a, a+<span class="number">6</span>) - a	&lt;&lt;endl;		<span class="comment">// 输出为4 </span></span><br><span class="line">	cout&lt;&lt;	*<span class="built_in">min_element</span>(a, a+<span class="number">6</span>)	&lt;&lt;endl;	 	<span class="comment">//输出为1 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="string内置函数翻转"><a href="#string内置函数翻转" class="headerlink" title="string内置函数翻转"></a>string内置函数翻转</h1><p>1 strrev函数（cstring）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;abcd&quot;;</span><br><span class="line"> </span><br><span class="line">    strrev(s);</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 reverse函数（algorithm）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s = &quot;abcd&quot;;</span><br><span class="line"> </span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.利用string构造函数（string）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string s = &quot;hello&quot;;</span><br><span class="line">    cout&lt;&lt;string(s.rbegin(),s.rend())&lt;&lt;endl;//通过string构造函数，传入原字符串的逆向迭代器。</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
  <entry>
    <title>webserver实战</title>
    <url>/2024/02/27/webserver%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="webserver-问题记录"><a href="#webserver-问题记录" class="headerlink" title="webserver 问题记录"></a>webserver 问题记录</h1><h2 id="mysql-安装与使用"><a href="#mysql-安装与使用" class="headerlink" title="mysql 安装与使用"></a>mysql 安装与使用</h2><p>系统环境：ubuntu 18.04</p>
<p>mysql版本号：5.7.42</p>
<h3 id="如何检查Mysql到底哪里出现了问题？"><a href="#如何检查Mysql到底哪里出现了问题？" class="headerlink" title="如何检查Mysql到底哪里出现了问题？"></a>如何检查Mysql到底哪里出现了问题？</h3><p>对源代码中<code>CGImysql\sql_connection_pool.cpp</code>的<code>void connection_pool::init函数</code>进行改进，将源代码改进为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_url = url;</span><br><span class="line">	m_Port = Port;</span><br><span class="line">	m_User = User;</span><br><span class="line">	m_PassWord = PassWord;</span><br><span class="line">	m_DatabaseName = DBName;</span><br><span class="line">	m_close_log = close_log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)</span><br><span class="line">&#123;</span><br><span class="line">	MYSQL* con = <span class="literal">NULL</span>;</span><br><span class="line">	MYSQL* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">mysql_init</span>(con);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">      <span class="comment">// 如果mysql_init()返回空，那就打印该信息</span></span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error: mysql_init() returns NULL&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		con = ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">      <span class="comment">// 如果mysql_real_connect()返回空，那就使用mysql_errorh和mysql_errno打印具体的出错信息</span></span><br><span class="line">		<span class="function">string <span class="title">err_info</span><span class="params">( mysql_error(con) )</span></span>;</span><br><span class="line">		err_info = (<span class="built_in">string</span>(<span class="string">&quot;MySQL Error[errno=&quot;</span>)</span><br><span class="line">			+ std::<span class="built_in">to_string</span>(<span class="built_in">mysql_errno</span>(con)) + <span class="built_in">string</span>(<span class="string">&quot;]: &quot;</span>) + err_info);</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>( err_info.<span class="built_in">c_str</span>() );</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		con = ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">	++m_FreeConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reserve = <span class="built_in">sem</span>(m_FreeConn);</span><br><span class="line">m_MaxConn = m_FreeConn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	<strong>改进后可以根据日志信息获取具体错误信息</strong></p>
<h3 id="安装配置mysql"><a href="#安装配置mysql" class="headerlink" title="安装配置mysql"></a><strong>安装配置mysql</strong></h3><p><strong>问题1：日志显示</strong></p>
<p><strong>Mysql Error</strong></p>
<p><strong>改进后显示如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024-02-27 11:01:30.474898 [erro]: MySQL Error[errno=2002]: Can&#x27;t connect to local MySQL server through socket &#x27;/var/run/mysqld/mysqld.sock&#x27; (2)</span><br></pre></td></tr></table></figure>

<p><strong>原因：起初安装MYSQL时只安装了<code>mysql-server</code>而没有安装<code>mysql-client</code></strong></p>
<p><strong>解决方法：重新安装<code>mysql-client</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br></pre></td></tr></table></figure>

<p><strong>问题2：日志显示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024-02-27 11:21:10.517526 [erro]: MySQL Error[errno=1045]: Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)</span><br></pre></td></tr></table></figure>

<p><strong>原因：没有服务器与mysql没有连接上</strong></p>
<p><strong>解决方法：确认main.cpp里的数据库和你mysql数据库配置相同</strong></p>
<p><strong>查看数据库名称和密码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/mysql</span><br><span class="line">sudo vim debian.cnf</span><br></pre></td></tr></table></figure>

<p><strong><img src="D:\Blog\source_posts\webserver问题记录\image-20240227115816973.png" alt="image-20240227115816973"></strong></p>
<p><strong>打开main.cpp修改对应配置</strong></p>
<p><img src="D:\Blog\source_posts\webserver问题记录\image-20240227115911433.png" alt="image-20240227115911433"></p>
<p><strong>重新编译运行即可</strong></p>
<hr>
<p><strong>服务器程序通常需要处理三类事件：I&#x2F;O事件、信号及定时事件。</strong></p>
<h2 id="1、简单介绍一下你的项目"><a href="#1、简单介绍一下你的项目" class="headerlink" title="1、简单介绍一下你的项目"></a>1、简单介绍一下你的项目</h2><p>本项目是一个基于Linux平台的轻量级HTTP高并发服务器，使用线程池+Epoll实现高效的IO多路复用，采用Reactor高并发模型进行事件处理，在业务逻辑部分利用状态机解析HTTP请求报文，可以访问数据库完成web端用户注册和登录功能，同时还制作了异步日志系统来监控和记录服务器的运行状态，最终达到的效果可以实现上万的并发连接数据交换。</p>
<p><img src="D:\Blog\source_posts\webserver问题记录\image-20240227140903054.png" alt="image-20240227140903054"></p>
<h2 id="2、项目中的难点？"><a href="#2、项目中的难点？" class="headerlink" title="2、项目中的难点？"></a>2、项目中的难点？</h2><p>项目中主要的工作可以分为两部分：</p>
<p>1 一部分是服务器网络框架、日志系统、存储引擎等一些基本系统的搭建，这部分的难点主要就是技术本身的理解和模型的选择，以及如何将开源的框架调整后应用到我的项目中。</p>
<p>2 另一部分是考虑如何提高服务器的性能所做的优化，比如缓存机制、内存池等一些额外系统的搭建。这部分的难点主要是找出服务器的性能瓶颈，然后去寻找方法去突破这个瓶颈，提高服务器的性能。</p>
<h2 id="3、项目中遇到的困难？如何解决的？"><a href="#3、项目中遇到的困难？如何解决的？" class="headerlink" title="3、项目中遇到的困难？如何解决的？"></a>3、项目中遇到的困难？如何解决的？</h2><p>1 一方面是对很多技术的理解不够深刻，难以选出最合适的技术框架，代码实现起来也遇到了很多问题，比如。。。这部分的话我主要是反复阅读相关的技术文献，先学习别人的框架和源码，再去总结不同技术之间的差异性和内在关联，需要多去尝试和摸索。</p>
<p>2 另一方面是由于工程能力的不足，程序总会遇到一些bug。这部分的话我首先是会通过日志或错误信息去定位bug，然后推断bug出现的原因并尝试修复，如果是自己目前水平无法修复的bug，就会去网上查资料，看有没有类似问题的解决方法，如果实在解决不了的就只能摇人了，比如去stackoverflow等一些知名论坛上求助。</p>
<h2 id="4、针对项目做了哪些优化？"><a href="#4、针对项目做了哪些优化？" class="headerlink" title="4、针对项目做了哪些优化？"></a>4、针对项目做了哪些优化？</h2><p>1、程序本身</p>
<ul>
<li>减少程序等待IO的事件：非阻塞IO+IO多路复用</li>
<li>设计高性能网络框架，同步IO（主从reactor+线程池）和异步IO（proactor）</li>
<li>减少系统调用：通过线程池、内存池和缓存机制，避免频繁申请和释放内存</li>
<li>减少系统调用：对于文件发送，使用零拷贝函数sendfile（），避免拷贝数据到用户态</li>
<li>尽量减少锁的使用，如果需要，尽量减小临界区（日志系统和线程池）</li>
</ul>
<p>2、系统参数调优</p>
<ul>
<li>最大文件描述符数（用户级和系统级）</li>
<li>tcp连接的参数（半连接&#x2F;连接队列的长度、tcp syncookies）</li>
</ul>
<h2 id="5、项目中用到哪些设计模式？"><a href="#5、项目中用到哪些设计模式？" class="headerlink" title="5、项目中用到哪些设计模式？"></a>5、项目中用到哪些设计模式？</h2><p>单例模式：在线程池、内存池中都有用到</p>
<p>单例模式分为懒汉式和饿汉式，两者之间的区别在于创建实例的时间不同：</p>
<ul>
<li>懒汉式：系统运行中，实例不存在，只有当需要使用该实例时，才会去创建（需要考虑线程安全）</li>
<li>饿汉式：系统一运行，就初始化创建实例，当需要时直接调用（本身就线程安全）</li>
</ul>
<h2 id="6、从数据流的角度分析此项目？"><a href="#6、从数据流的角度分析此项目？" class="headerlink" title="6、从数据流的角度分析此项目？"></a>6、从数据流的角度分析此项目？</h2><h2 id="7、项目都有哪些模块？"><a href="#7、项目都有哪些模块？" class="headerlink" title="7、项目都有哪些模块？"></a>7、项目都有哪些模块？</h2><p>首先按照服务器编程的基本框架，分为IO处理单元、逻辑单元和数据存储单元，通过请求队列来进行内部调度。</p>
<p>本项目采用的是epoll+非阻塞socket实现的同步IO，</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>半同步&#x2F;半反应堆线程池</p>
<p>（半同步&#x2F;半异步并发模型下结合考虑IO模型和事件处理模式的变体）</p>
<p>使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程（异步）往工作队列中插入任务，工作线程（同步）通过竞争来取得任务并执行它。</p>
<blockquote>
<ul>
<li>同步I&#x2F;O模拟proactor模式</li>
<li>半同步&#x2F;半反应堆</li>
<li>线程池</li>
</ul>
</blockquote>
<h2 id="1、介绍一下线程池"><a href="#1、介绍一下线程池" class="headerlink" title="1、介绍一下线程池"></a>1、介绍一下线程池</h2><p>首先为什么要使用线程池？</p>
<p>如果不使用线程池，最大的一个缺陷是线程不能复用，这将导致两个问题：</p>
<p>​	第一，任务的执行则伴随着一个新线程的创建，而动态创建新线程是比较耗费时间的，任务需要等待线程创建完后再执行，这将导致较慢的客户响应；</p>
<p>​	第二，动态创建的线程通常只为一个客户服务，这将导致系统上产生大量细微线程，资源消耗较大</p>
<p>此外，大量的线程会降低系统的稳定性，系统资源的分配和管理会变得困难。</p>
<p>而线程池可以在服务器启动之初，就被完全创建好并初始化，成为静态资源，这就将线程的创建和任务的执行解耦开来，它可以在任务需要时复用线程，不仅避免了频繁创建和销毁线程所带来的时间和资源的消耗，还方便监控和管理。</p>
<p>线程池本质上是一个空间换时间的做法，利用服务器的硬件资源换取运行效率</p>
<p>注：</p>
<p>线程创建的消耗：分配内存、列入调度、内存换页、清空缓存和重新读取</p>
<p>时间:纳秒级 </p>
<p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间</p>
<h2 id="2、线程池怎么实现的？"><a href="#2、线程池怎么实现的？" class="headerlink" title="2、线程池怎么实现的？"></a>2、线程池怎么实现的？</h2><h2 id="3、线程池中的线程数量怎么确定？"><a href="#3、线程池中的线程数量怎么确定？" class="headerlink" title="3、线程池中的线程数量怎么确定？"></a>3、线程池中的线程数量怎么确定？</h2><p>最直接的限制因素是cpu的cores数，对于cpu密集型的任务，线程数一般与核数保持一致或+1，这样可以减少上下文切换导致的开销;对于io密集型的任务，线程数一般要多于cpu的核数，因为IO一般较慢，线程间竞争的是IO，在处理IO的过程中，多于核数的线程能为cpu争取更多任务，不至于造成cpu空闲导致资源浪费。</p>
<p>注：为什么要考虑这个问题？线程多一些不好吗？</p>
<p>过多的线程意味着大量线程间的切换，这将占用大量的cpu时间，服务器真正处理业务逻辑的cpu时间比重不足。</p>
<h2 id="4、如何选择哪个进程-线程去执行新任务？"><a href="#4、如何选择哪个进程-线程去执行新任务？" class="headerlink" title="4、如何选择哪个进程&#x2F;线程去执行新任务？"></a>4、如何选择哪个进程&#x2F;线程去执行新任务？</h2><p><u>知识点：进程的通信和调度；线程的同步</u></p>
<p>具体选择哪个工作线程来为新的客户请求服务，取决于请求队列的设计（游双）</p>
<p>这里主要涉及到进程&#x2F;线程的一些分配原则，可以从以下几个方面考虑：</p>
<p>第一，根据调度策略主动选择线程，例如Round Robin（时间片轮转）、FCFS（先来先服务）等常见调度算法；第二，考虑负载均衡，尽量保持各个线程的负载均衡，以提高整体的性能和资源利用率；第三，线程池具有一些参数，如核心线程数、最大线程数、线程存活时间等，这些参数也会影响任务的分配方式。</p>
<p>本项目采用的方式是：所有线程通过一个共享的工作队列来进行同步，当有新任务到来时，主线程将任务添加到工作队列中，唤醒一个等待任务的子线程，它会从工作队列中取出任务并执行，采用的是Round Robin算法，设置了核心线程数和最大线程数，当任务数量超过核心线程数时，线程池可能会根据需要创建新的线程，但数量不能超过最大线程数限制。</p>
<h3 id="注-：1-进程-线程的调度算法？"><a href="#注-：1-进程-线程的调度算法？" class="headerlink" title="注 ：1 进程&#x2F;线程的调度算法？"></a>注 ：1 进程&#x2F;线程的调度算法？</h3><p>先来先服务、最短作业优先、高响应比优先、时间片轮转、最高优先级、多级反馈队列</p>
<p><a href="https://xiaolincoding.com/os/4_process/process_base.html#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">5.1 进程、线程基础知识 | 小林coding (xiaolincoding.com)</a></p>
<h3 id="注-：2-怎么通知子进程-子线程有新任务？（进程间通信）"><a href="#注-：2-怎么通知子进程-子线程有新任务？（进程间通信）" class="headerlink" title="注 ：2 怎么通知子进程&#x2F;子线程有新任务？（进程间通信）"></a>注 ：2 怎么通知子进程&#x2F;子线程有新任务？（进程间通信）</h3><p>进程间通信方式有管道、消息队列、共享内存、信号量、信号和socket。</p>
<p>线程间由于共享内存，可以把数据定义成全局的，不需要特别考虑数据通信的问题，但需要考虑线程安全。</p>
<h3 id="注3：怎么去解决多线程竞争的问题？（线程互斥与同步）"><a href="#注3：怎么去解决多线程竞争的问题？（线程互斥与同步）" class="headerlink" title="注3：怎么去解决多线程竞争的问题？（线程互斥与同步）"></a>注3：怎么去解决多线程竞争的问题？（线程互斥与同步）</h3><p>本项目采用互斥锁、信号量和条件变量来实现线程安全，在创建线程池前就把它们事先封装成一个模块，后续直接调用。</p>
<p>几种典型的锁：互斥锁、读写锁、自旋锁、条件变量</p>
<p><strong>互斥锁</strong>加锁失败后，线程<strong>释放 CPU</strong> ，给其他线程（线程切换）</p>
<p><strong>自旋锁</strong>加锁失败后，线程会<strong>占用cpu忙等待</strong>，直到它拿到锁</p>
<p><strong>读写锁</strong>适用于能明确区分读操作和写操作的场景，<strong>读写锁在读多写少的场景，能发挥出优势</strong></p>
<p><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-07-basic.html#_131%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81">基础语法-121-140 | 阿秀的学习笔记 (interviewguide.cn)</a></p>
<p>死锁：死锁产生的条件、如何避免死锁</p>
<p>悲观锁：互斥锁、自旋锁、读写锁都是悲观锁（<strong>访问共享资源前，先要上锁</strong>。）</p>
<p>乐观锁：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成；如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。(也叫无锁编程)–例：在线文档</p>
<p><strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁</strong></p>
<p><a href="https://xiaolincoding.com/os/4_process/pessim_and_optimi_lock.html#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81">5.5 什么是悲观锁、乐观锁？ | 小林coding (xiaolincoding.com)</a></p>
<p>信号量：协调共享资源访问<img src="D:\Blog\source_posts\webserver问题记录\image-20240302142613500.png" alt="image-20240302142613500"></p>
<h2 id="5-怎么预先分配池的资源？"><a href="#5-怎么预先分配池的资源？" class="headerlink" title="5 怎么预先分配池的资源？"></a>5 怎么预先分配池的资源？</h2><p>池在服务器启动之初就被完全创建好并初始化，称为静态资源分配</p>
<p>我们无法预期应该分配多少资源，最简单的解决方法是分配足够多的资源（针对每个可能的客户连接都分配必要的资源），但任一时刻的客户数量可能都远远没到极限，这会导致资源的浪费（可接受）；还有一种解决方案是预先分配一定资源，当不够用时再动态分配一些并加入池中。（核心线程数、最大线程数）</p>
<h1 id="事件处理模式（网络框架）"><a href="#事件处理模式（网络框架）" class="headerlink" title="事件处理模式（网络框架）"></a>事件处理模式（网络框架）</h1><p>先准备一个线程池threadpool.h</p>
<p>需要线程安全同步机制 ，封装一个locker.h（包含锁、信号量和条件变量） </p>
<p>在线程池中将任务添加到请求队列，并分配线程去获取请求队列中的任务</p>
<p>获取到任务后执行（process）</p>
<p>线程池在程序开始时就被创建并初始化</p>
<h2 id="模拟proactor模式"><a href="#模拟proactor模式" class="headerlink" title="模拟proactor模式"></a><strong>模拟proactor模式</strong></h2><p>主线程（main）负责监听和IO操作，采用epoll实现io多路复用，首先将socket返回的监听文件描述符添加到epoll对象中，开始循环监听事件，epoll在内核中监听到有事件后先判断事件的类型：<strong>如果是新的客户端请求连接</strong>，我们调用accept接受请求，建立连接，（proactor模式下）并将返回的通信文件描述符connfd也添加到epoll实例对象中进行监听，后续它将作为客户端与服务器的通信通道；<strong>如果是读写数据的事件类型</strong>，直接全部取出，并将数据封装成一个任务类（http_conn类），再交给工作线程（threadpool里的子线程）进行处理。这个取数据的过程如果是在主线程里进行，工作线程只负责处理业务逻辑，就是模拟的proactor模式，因为从工作线程的角度看，它们直接获得了IO操作后的结果</p>
<p><u>（实际的proactor是需要调用aio系列函数的，它可以在内核里完成异步i&#x2F;o操作后，再将数据传给不同的handler进行业务处理，我们在主线程的io操作其实是模拟了proactor在内核的这一过程）</u></p>
<h2 id="reactor模式"><a href="#reactor模式" class="headerlink" title="reactor模式"></a><strong>reactor模式</strong></h2><p>主线程只负责监听，只有在监听到有新连接建立的时候，才去调用accept获取连接，然后它将新的连接直接分配给某个子线程，在子线程中再将这个连接加入epoll继续监听，并去创建一个Handler，用于处理后续可能发生的响应事件。当子线程监听到此连接上有新的事件发生时，就调用这个Handler进行处理，包括读写数据、业务逻辑和发送数据，也就是说整个IO操作是在子线程（工作线程）中完成的，并且是由应用进程主动发起read&#x2F;write来读写数据的。</p>
<p>（proactor由操作系统完成读写数据的工作，然后通知应用进程直接处理数据）</p>
<p>总结一下，<strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>，<strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong></p>
<p><strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong></p>
<p><strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong></p>
<p><strong>注：这里又涉及到阻塞IO和非阻塞IO、同步IO和异步IO的知识点，往后引申一下</strong></p>
<h2 id="阻塞io、非阻塞io、同步-异步"><a href="#阻塞io、非阻塞io、同步-异步" class="headerlink" title="阻塞io、非阻塞io、同步&#x2F;异步"></a>阻塞io、非阻塞io、同步&#x2F;异步</h2><p>阻塞IO是指用户调用read&#x2F;write等函数时，线程会被阻塞，一直等到数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区后，函数才会返回。其中需要注意的是，阻塞等待的是<strong>「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</strong></p>
<p>非阻塞IO是指，调用read&#x2F;write函数后，在数据没有准备好的情况下立即返回，程序可以继续往下执行，但它还是会不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区后，read调用才获取到结果。注意最后一次read调用获取数据时，需要等待<strong>内核态的数据拷贝到用户程序的缓冲区</strong>，这实际上是一个同步的过程。</p>
<p>因此，无论是阻塞IO和非阻塞IO都是同步的，因为它们在<strong>数据从内核空间拷贝到应用程序空间的过程都是需要等待的</strong>，也就是说这个过程是同步的。如果内核实现的拷贝效率不高，函数调用就会在这个同步过程中等待较长时间。</p>
<p>只有当我们调用aio系列函数（如aio_read）时，刚才说的数据准备和数据拷贝的过程都将由内核自动完成，我们全程不需要等待，也不需要主动发起拷贝动作，这才是真正的异步。</p>
<p>（举例：食堂打饭）</p>
<p><strong>注：由非阻塞IO的轮询机制，引出IO多路复用技术</strong></p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="IO多路复用技术主要改进的问题有两个："><a href="#IO多路复用技术主要改进的问题有两个：" class="headerlink" title="IO多路复用技术主要改进的问题有两个："></a>IO多路复用技术主要改进的问题有两个：</h3><p>​	一是为了改进非阻塞IO轮询机制下频繁的系统调用；</p>
<p>​	二是在服务多用户时，操作系统无法在高并发场景下维护大量的进程或线程，每个进程或线程又都是用来维护socket连接的，既然为每一个请求分配一个进程&#x2F;线程的做法不合适，那有没有可能只使用一个进程&#x2F;线程来维护多个 Socket 呢？这就引出了IO多路复用技术。</p>
<p>​	（再提一句，基于非阻塞的IO多路复用也是同步的）</p>
<h3 id="IO多路复用的实现原理："><a href="#IO多路复用的实现原理：" class="headerlink" title="IO多路复用的实现原理："></a>IO多路复用的实现原理：</h3><p>​	IO多路复用通过select&#x2F;poll&#x2F;epoll 系统调用实现，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。总的实现方式是：有网络事件时，先把所有连接传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些请求。<strong>它用更少的资源完成更多的事</strong></p>
<h3 id="select-poll-epoll-分别是怎样实现的（区别）："><a href="#select-poll-epoll-分别是怎样实现的（区别）：" class="headerlink" title="select&#x2F;poll&#x2F;epoll 分别是怎样实现的（区别）："></a>select&#x2F;poll&#x2F;epoll 分别是怎样实现的（区别）：</h3><p>​	select将已连接的socket都放到一个文件描述符集合，然后全部拷贝到内核中去检查，检查方式很粗暴，就是通过遍历的方式检查是否有事件产生，并将其标记为1或0，接着再把整个文件描述符集合拷贝回用户态，用户还要再遍历去找哪些事件发生，再进行处理。</p>
<p>​	select的缺点很明显，一是2次遍历和2次拷贝既浪费资源又影响效率，二是用固定长度的BitsMap表示文件描述符集合，有数量限制。</p>
<p>​	poll改进了select，它用动态数组来存储文件描述符，以链表形式来组织，突破了文件描述符的限制。但在其它方面本质上没有太大区别，都需要遍历和拷贝操作文件描述符集合，这种方式随着并发数上来，性能损耗会呈指数级增长（遍历的时间复杂度都是O（n））</p>
<p>​	epoll通过两个方面，很好的解决了select和epoll的问题：</p>
<p>一是在内核里使用<strong>红黑树</strong>来跟踪所有待检测的文件描述符，二是采用<strong>事件驱动机制</strong>，在内核里<strong>维护一个链表</strong>来记录就绪事件。</p>
<p>​	使用场景：当监测的<strong>fd数量较小</strong>，且<strong>各个fd都很活跃的情况</strong>下，建议<strong>使用****select和poll</strong>；当监听的<strong>fd数量较</strong>多，且单位时间仅<strong>部分fd活跃</strong>的情况下，<strong>使用epoll</strong>会明显提升性能。</p>
<p>注：epoll支持两种事件触发模式ET和LT</p>
<p>回答：<a href="">ET模式和LT模式分别适用什么场景？</a></p>
<p>注：EPOLLONESHOT事件</p>
<p>回答：<a href="">EPOLLONESHOT事件</a></p>
<h2 id="EPOLL拓展"><a href="#EPOLL拓展" class="headerlink" title="EPOLL拓展"></a>EPOLL拓展</h2><h3 id="ET模式和LT模式分别适用什么场景？"><a href="#ET模式和LT模式分别适用什么场景？" class="headerlink" title="ET模式和LT模式分别适用什么场景？"></a><a href="">ET模式和LT模式分别适用什么场景？</a></h3><p>首先区别一下它们：对于ET模式，只有一个事件从无到有才会触发，对于LT模式，一个事件只要有就会一直触发</p>
<p>ET模式：</p>
<p>优点：适用于高并发、实时性要求高的场景，它可以减少频繁的事件通知而带来的性能开销，并且可以更及时的响应事件。</p>
<p>缺点：</p>
<p>​	1 ET模式需要确保一次性读写完整数据包，否则会导致数据丢失，因此，在不能保证接受数据完整性的场景下不适用</p>
<p>​	2 需要更复杂精确的处理逻辑</p>
<p><strong>LT模式：</strong></p>
<p>优点：适用于简单的IO任务，不要求应用程序实时处理文件描述符的变化，是默认的工作模式，与旧有代码兼容性更好。</p>
<p>缺点：</p>
<p>​	1 需要额外检查，应用程序在每次epoll_wait后都要再次检查文件描述状态，以确保及时处理就绪事件</p>
<p>​	2 容易出现“惊群效应”，可能会导致多线程同时竞争同一个文件描述符，造成性能损耗</p>
<h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a><a href="">EPOLLONESHOT事件</a></h3><p>即使在ET模式下，一个socket上的某个事件也可能被多次触发，会导致多个线程同时操作一个socket。</p>
<p>使用epoll的EPOLLONESHOT可以保证该文件描述符上的事件，只触发一个且只触发一次，再用epoll_ctl重置EPOLLONESHOT就能被再次触发。</p>
<h2 id="为什么不使用异步io？"><a href="#为什么不使用异步io？" class="headerlink" title="为什么不使用异步io？"></a>为什么不使用异步io？</h2><p>在linux下，异步IO是不完善的，aio系列函数是由POSIX定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅支持基于本地文件的aio异步操作，对于网络编程中的socket是不支持的。可以使用一个线程模拟Proactor模式，专门负责IO的处理。</p>
<p>Windows里实现了一套完整的支持socket的异步编程接口，在 Windows ⾥实现⾼性能⽹络程序可以使⽤效率更⾼的 Proactor ⽅案。</p>
<h2 id="为什么选择模拟proactor-reactor-线程池的模式？"><a href="#为什么选择模拟proactor-reactor-线程池的模式？" class="headerlink" title="为什么选择模拟proactor&#x2F;reactor+线程池的模式？"></a>为什么选择模拟proactor&#x2F;reactor+线程池的模式？</h2><p>从程序的角度来看是为了将IO操作和业务处理解耦，从功能实现的角度看是为了提高服务器的性能</p>
<p>具体来说 </p>
<p>1 为什么选择proactor&#x2F;reactor这个网络框架？</p>
<p>reactor模式是非阻塞同步IO网络框架，它通过IO多路复用实现一个线程中的多并发连接，非常适合构建高并发的网络服务器，它采用了事件驱动方式，将事件的处理与业务逻辑分离开来，使代码更清晰、更易于维护和扩展，此外它具有很好的跨平台性，可以在各种操作系统和编程语言上实现。</p>
<p>reactor模式分为单reactor单线程、单reactor多线程、多reactor多线程。</p>
<p>（reacto模式有 <strong>Reactor、Acceptor、Handler</strong> 这三个对象，Reactor 对象的作用是监听和分发事件，Acceptor 对象的作用是获取连接，Handler 对象的作用是处理业务。）</p>
<p>2 为什么使用线程池?</p>
<p>本项目采用的是单reactor多线程模式的网络框架，需要创建多个线程，这就用到了线程池。线程池可以实现线程的复用，能够避免频繁创建线程和线程切换所带来的资源消耗和时间开销。（看情况说如果不用会有哪些问题）</p>
<hr>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>数据库目前主要用来存储用户登录的账户和密码</p>
<h2 id="项目中用到了那些设计模式？"><a href="#项目中用到了那些设计模式？" class="headerlink" title="项目中用到了那些设计模式？"></a>项目中用到了那些设计模式？</h2><p>单例模式：数据库连接池</p>
<p>确保只有一个连接池实例，通过statc关键字，使得对象只有在首次调用时被创建，以后每次调用都返回同一个对象的指针。</p>
<p>单例模式可以分为懒汉式和饿汉式，两者之间的区别在于创建实例的时间不同： </p>
<ul>
<li>懒汉式：指系统运⾏中，实例并不存在，只有当需要使⽤该实例时，才会去创建并使⽤实例。（这种⽅式要考 虑线程安全） </li>
<li>饿汉式：指系统⼀运⾏，就初始化创建实例，当需要时，直接调⽤即可。（本身就线程安全，没有多线程的问 题）</li>
</ul>
<h2 id="还做了哪些优化？"><a href="#还做了哪些优化？" class="headerlink" title="还做了哪些优化？"></a>还做了哪些优化？</h2><p>使用RAII思想设计连接池和线程池，<strong>资源获取要通过构造函数初始化，然后析构函数负责释放资源</strong>，利用了C++语言局部对象自动销毁的特性来控制连接资源的生命周期，避免了内存泄漏（智能指针本质上就是RAII思想）</p>
<h1 id="定时器处理非活动连接"><a href="#定时器处理非活动连接" class="headerlink" title="定时器处理非活动连接"></a>定时器处理非活动连接</h1><p>本项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。</p>
<p>具体的，利用<code>alarm</code>函数周期性地触发<code>SIGALRM</code>信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。</p>
<p>主要实现分三部分：</p>
<p>1 定时器和信号通知流程</p>
<p>2 定时器容器设计</p>
<p>3 定时任务的处理</p>
<h2 id="tcp的心跳机制（keepalive）"><a href="#tcp的心跳机制（keepalive）" class="headerlink" title="tcp的心跳机制（keepalive）"></a>tcp的心跳机制（keepalive）</h2><p>为了维持长连接</p>
<ul>
<li>在网络故障对端崩溃时，tcp发送的探测包无法的到回应，会认为连接已经失效</li>
<li>对端拒绝keepalive请求</li>
<li>配置超时时间</li>
</ul>
<p>定时器处理非活跃连接可以提供更好的保障：</p>
<p>1 某些网络环境会阻止心跳机制</p>
<p>2 由于网络流量控制或其他原因，心跳包的发送频率可能受到限制</p>
<p>3 定时器可以提供更精确和可靠的连接状态监测</p>
<p>4 定时器可以用于实现除了检测连接是否活跃外，监测其他连接状态，例如带宽、延迟等</p>
<p>可以综合使用这两种机制</p>
<h2 id="信号通知流程？"><a href="#信号通知流程？" class="headerlink" title="信号通知流程？"></a>信号通知流程？</h2><p>linux下的信号采用的是异步处理机制（中断），信号处理函数和当前进程是两条不同的执行路线。具体来说，当进程收到信号时，操作系统会中断进程当前的正常流程，转而执行信号处理函数，完成后再返回中断的地方继续执行。</p>
<p>为避免信号处理函数执行时间过长，导致信号被屏蔽太久，本项目的信号处理函数仅用于发送信号通知主循环，将相应的处理逻辑放在主循环中执行。</p>
<p>这样做还有一个好处，就是统一事件源，信号事件其它事件一样都可以在主循环中使用epoll来监测，从而实现统一处理。</p>
<h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><h2 id="异步日志系统是怎么实现的？"><a href="#异步日志系统是怎么实现的？" class="headerlink" title="异步日志系统是怎么实现的？"></a>异步日志系统是怎么实现的？</h2><ul>
<li>本项目中，使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，可以根据实际情况分别使用同步或异步两种写入方式</li>
<li>其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件</li>
<li>日志系统大致可以分成两部分，其一是单例模式与阻塞队列的定义，其二是日志类的定义与使用</li>
</ul>
<p>单例模式与阻塞队列实现异步的日志系统</p>
<p>将生产出来的日志信息存储到阻塞队列之中，在后台开辟一个线程专门用于数据的输出，异步写日志的公有方法调用私有方法async_write，不断的从阻塞队列之中取出数据进行写入操作，若无数据可写，则等待通知</p>
<p><img src="D:\Blog\source_posts\webserver问题记录\image-20240305183004020.png" alt="image-20240305183004020"></p>
<p>阻塞队列：在多线程编程中常用于实现<strong>生产者和消费者模型</strong>的数据结构，其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；当队列满时，往队列里存放元素的操作也会被阻塞，直到有元素被从队列中取出</p>
<p>单例模式：在内存中会<strong>创建且仅创建一次</strong>对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p>
<p>（懒汉式、饿汉式）</p>
<p>经典的线程安全懒汉模式，使用双检测锁</p>
<img src="D:\Blog\source\_posts\webserver问题记录\image-20240305192215231.png" alt="image-20240305192215231" style="zoom: 50%;" />

<p>本项目使用局部静态变量优雅的实现懒汉模式（c++11以后要求编译器保证内部静态变量的线程安全性)，这种方式不需要加锁–effective c++</p>
<img src="D:\Blog\source\_posts\webserver问题记录\image-20240305191958198.png" alt="image-20240305191958198" style="zoom:67%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">局部静态变量是指在函数内部声明的静态变量。与普通的局部变量不同，局部静态变量在函数每次被调用时不会重新初始化，而是在程序的生命周期内保持其值，直到程序结束。</span><br><span class="line"></span><br><span class="line">具体来说，局部静态变量有以下特点：</span><br><span class="line"></span><br><span class="line">1. 它们只能在声明它们的函数内部访问</span><br><span class="line">2. 它们在程序执行到声明处时被初始化，且只会被初始化一次</span><br><span class="line">3. 它们在函数调用结束后并不被销毁，而是保留其值供下次调用使用</span><br><span class="line"></span><br><span class="line">使用局部静态变量通常是为了实现一种“记忆”的效果，例如在函数中保存某些状态信息或者统计信息。</span><br></pre></td></tr></table></figure>

<p>饿汉模式在程序运行时就定义了对象，并对其初始化，之后，不管哪个线程调用成员函数getinstance（），都返回该对象的指针，因此不需要锁，就可以实现线程安全。</p>
<p>饿汉模式虽好，但其存在隐藏的问题：非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>
<h2 id="为什么要使用异步日志？"><a href="#为什么要使用异步日志？" class="headerlink" title="为什么要使用异步日志？"></a>为什么要使用异步日志？</h2><p>同步写日志等待磁盘 IO 的完成对于高性能服务器的快速执行和及时响应性会造成一定的性能损失，为了减小这种损失，我们可以采用异步日志。</p>
<p>异步日志在记录时不直接将消息写入到文件中，而是先将日志消息存储在缓冲区或队列中，然后用另外的线程负责将日志写入到文件中。</p>
<p>它的优点是记录日志时不会阻塞当前线程，可以提高程序性能，尤其是在高并发的场景下，对QPS的影响比较小</p>
<h2 id="如果服务器崩溃，你的日志系统会发生什么？"><a href="#如果服务器崩溃，你的日志系统会发生什么？" class="headerlink" title="如果服务器崩溃，你的日志系统会发生什么？"></a>如果服务器崩溃，你的日志系统会发生什么？</h2><p>第一，未写入文件的日志可能会丢失，造成日志信息的不完整性</p>
<p>第二，日志文件在写入过程被截断或部分写入，可能导致文件格式损坏</p>
<p>解决：</p>
<p>1、采取日志回滚和恢复机制，如事务日志，系统可以根据日志中的信息重新执行或回滚操作，从而确保数据一致性和完整性</p>
<p>2、定期备份，确保将日志写入持久化存储介质，如磁盘</p>
<p>3、使用负载均衡、故障转移、集群等技术，即使某个服务器崩溃，系统仍然可以继续提供服务并保持日志系统的可用性。</p>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
  </entry>
  <entry>
    <title>如何实现高性能？</title>
    <url>/2024/03/01/%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="D:\Blog\source_posts\高性能的技术和方法\640.jpeg" alt="640"></p>
<p>提高服务器性能的建议：</p>
<p>1 硬件资源，如cpu个数、速度、内存等</p>
<p>2 软件资源，如最大文件描述符数量</p>
<p>3 程序本身</p>
<p>锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源</p>
<p>尽量无锁化编程</p>
<p>必须使用锁：考虑减小锁的粒度、采用读写锁等</p>
<p>读写锁优点：当所有工作线程都只读取一块共享内存的内容时，读写锁并不会 增加系统的额外开销。只有当其中某一个工作线程需要写这块内存 时，系统才必须去锁住这块区域</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
  </entry>
  <entry>
    <title>mit 6.s081项目</title>
    <url>/2024/03/08/6.s081%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="1-RISC-V和ARM架构的关系？"><a href="#1-RISC-V和ARM架构的关系？" class="headerlink" title="1 RISC-V和ARM架构的关系？"></a>1 RISC-V和ARM架构的关系？</h2><p>risc-v是一种基于精简指令集risc的开放架构，可以自由使用和定制，例如阿里的玄铁910就是risc-v处理器</p>
<p>arm也是精简指令集的cpu架构，它在嵌入式、移动设备和服务器领域广泛使用，但它是专有的</p>
<h2 id="2-这个项目的运行环境是什么？"><a href="#2-这个项目的运行环境是什么？" class="headerlink" title="2 这个项目的运行环境是什么？"></a>2 这个项目的运行环境是什么？</h2><p>xv6 操作系统运⾏在 qemu 模拟的硬件环境中，qemu通过模拟硬件设备的行为来实现对硬件设备的支持，例如硬盘、网卡、串口等</p>
<h2 id="3-risv-v是几级流水？"><a href="#3-risv-v是几级流水？" class="headerlink" title="3 risv-v是几级流水？"></a>3 risv-v是几级流水？</h2><p>五级流水</p>
<p>取指（Fetch）：从内存中取出指令。 </p>
<p>译码（Decode）：解码指令，确定要执⾏的操作和操作数。 </p>
<p>执⾏（Execute）：执⾏指令的操作，可能涉及算术逻辑运算、内存访问等。 </p>
<p>访存（Memory）：如果指令需要访问内存（如加载或存储指令），则在这个阶段进⾏内存访问。 </p>
<p>写回（Write Back）：将执⾏阶段计算的结果写回寄存器⽂件</p>
<h2 id="4-进程的上下文切换？"><a href="#4-进程的上下文切换？" class="headerlink" title="4 进程的上下文切换？"></a>4 进程的上下文切换？</h2><p><strong>用户级上下文：正文、数据、用户堆栈和共享存储区</strong></p>
<p><strong>寄存器上下文：程序计数器PC、处理器状态寄存器、通用寄存器、栈指针</strong></p>
<p><strong>系统级上下文：进程控制块、内存管理信息、内核堆栈等</strong></p>
<p>注：</p>
<p><strong>cpu上下文：cpu寄存器和程序计数器PC</strong></p>
<p>cpu执行不同的任务，需要上下文切换，而根据任务的不同，可以分为三类：<strong>进程上下文切换、线程上下文切换、中断上下文切换</strong></p>
<p>线程上下文切换：如果属于同一个进程：只切换私有数据，如栈和寄存器，对于共享的内存和全局变量等不需要修改；如果属于不同进程，与进程切换一样。</p>
<p>中断上下文切换：<strong>不涉及到进程的用户态，对同一个 CPU 来说，中断处理比进程拥有更高的优先级</strong>。包括：CPU 寄存器、内核堆栈、硬件中断参数等。</p>
<p>一次系统调用，发生了两次cpu上下文切换（系统调用是在同一个进程中发生的）</p>
<h2 id="5-用户态陷入内核态的三种方式？"><a href="#5-用户态陷入内核态的三种方式？" class="headerlink" title="5 用户态陷入内核态的三种方式？"></a>5 用户态陷入内核态的三种方式？</h2><p>系统调用、中断、异常</p>
<h2 id="6-为什么要有虚拟内存？"><a href="#6-为什么要有虚拟内存？" class="headerlink" title="6 为什么要有虚拟内存？"></a>6 为什么要有虚拟内存？</h2><p>（什么是虚拟内存？为什么要进行内存管理？）</p>
<p>操作系统提供的一种内存管理机制，它将不同进程的虚拟地址和不同内存的物理地址映射起来（ 通过CPU 芯片中的内存管理单元（MMU））。</p>
<p>1、内存隔离：直接使用物理地址可能导致多个程序之间有干扰和冲突，虚拟地址为每一个进程提供一个独立的、一致的地址空间，这种隔离提高了程序运行时的安全和稳定</p>
<p>2、更大的地址空间：程序运行符合局部性原理，cpu访问内存有明显的重复性，对于不经常使用的内存，可以把它先换出到物理内存之外，如硬盘上的swap空间</p>
<p>3、内存映射和文件共享：可以将⽂件映射到进程的地址空间中，不用到磁盘中操作文件，还可以在多个进程间共享</p>
<p>4、内存分配：使用虚拟地址编程时无需考虑底层硬件的实际物理地址，简化了内存管理和分配</p>
<h3 id="引申：为什么有更大的地址空间？"><a href="#引申：为什么有更大的地址空间？" class="headerlink" title="引申：为什么有更大的地址空间？"></a>引申：为什么有更大的地址空间？</h3><p>​	操作系统利用缺页异常机制，实现了写时复制、内存懒分配和磁盘交换等技术，为进程提供了许多‘虚假’的虚拟内存，它们可能没有对应的物理内存，也可能对应的物理内存被交换到了磁盘中，从而在进程视角中拥有远超物理内存的虚拟内存量</p>
<h2 id="7、虚拟内存怎么实现？"><a href="#7、虚拟内存怎么实现？" class="headerlink" title="7、虚拟内存怎么实现？"></a>7、虚拟内存怎么实现？</h2><p>（操作系统如何管理虚拟地址与物理地址之间的关系？）</p>
<p>内存分段和内存分页</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>​	分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong></p>
<p>​	段选择因子里面最重要的是<strong>段号</strong>，用作段表的索引</p>
<p>​	<strong>虚拟地址通过段表与物理地址进行映射，有了段号和段内偏移量就可以找到物理内存中的地址</strong></p>
<p>**	分段产生的问题：（外部）内存碎片和内存交换效率低**</p>
<p>​	内存分段可以根据实际需求分配内存，每个段内部是连续的，不会产生内部内存碎片，但各段之间会产生外部内存碎片（例如有三个段，中间那个段的程序结束，内存释放后就会产生碎片）</p>
<p>​	解决外部内存碎片的方式就是内存交换，把内存上的一部分内存先写到硬盘上，再从硬盘读回来，把碎片的位置占满</p>
<p>​	但如果交换的内存很大，就会有卡顿，因为硬盘访问速度比内存慢的多。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页解决了分段的外部内存碎片和内存交换效率低的问题，</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>，通过页表映射</p>
<p>（linux页的大小为4KB）</p>
<p><strong>为什么要有多级页表？</strong>减少页表所占空间，前一级的页表可以用更少的空间覆盖全部的虚拟地址，后一级的页表在需要时创建即可（局部性原理）</p>
<p><strong>多级页表的效率怎么解决？</strong>TLB快表（页表缓存），把最常访问的几个页表项存储到访问速度更快的硬件缓存中</p>
<p><strong>谁来管理虚拟内存？</strong>CPU的内存管理单元MMU，他负责完成地址映射和TLB的访问与交互</p>
<p><strong>缺页异常（中断）？进程要访问的物理地址在页表中查不到</strong>，需要进入内核分配物理内存，更新进程页表，再返回用户空间，恢复进程运行</p>
<p><strong>页面置换算法？</strong>如果触发缺页异常时，物理内存已满，需要【页面置换算法】选择一个物理页换出到磁盘，并把需要访问的页面放到这个物理页中</p>
<p>算法原则：尽可能减少页面的换入换出次数</p>
<ul>
<li>最佳页面置换算法（<em>OPT</em>）</li>
<li>先进先出置换算法（<em>FIFO</em>）</li>
<li>最近最久未使用的置换算法（<em>LRU</em>）–时间</li>
<li>时钟页面置换算法（<em>Lock</em>）</li>
<li>最近最不常用置换算法（<em>LFU</em>）–频率</li>
</ul>
<p><strong>系统抖动？</strong>页刚被换出，根据请求又马上被换入，这种反复频繁的页面置换就被称为系统抖动。解决方法：选取合适的置换算法</p>
<h2 id="8-内存分配的过程是怎样的？（内存回收）"><a href="#8-内存分配的过程是怎样的？（内存回收）" class="headerlink" title="8 内存分配的过程是怎样的？（内存回收）"></a>8 内存分配的过程是怎样的？（内存回收）</h2><p>​	malloc申请的是虚拟内存，一开始并不会分配物理内存，当应用程序读写了这块虚拟内存，cpu就会去访问它，发现没有映射到实际的物理内存，cpu就会产生缺页中断，进程切换到内核态，交给缺页中断函数处理。</p>
<p>​	缺页中断函数会看是否有空闲的物理内存，如果有，直接分配，并建立映射；如果没有内核就会开始回收内存，有两种方式：后台内存回收和直接内存回收</p>
<ul>
<li>后台内存回收（kswapd）：在物理内存紧张时，会唤醒kswaped内核线程来回收内存（异步，不阻塞进程执行）</li>
<li>直接内存回收：如果后台内存回收跟不上进程内存申请的速度，就会开始直接回收（同步，会阻塞进程执行）</li>
</ul>
<p>如果直接内存回收后仍不满足物理内存的申请，就会触发OOM机制（Out of Memory）：OOM Killer机制会根据算法选择一个物理内存占用较高的进程将其杀死，以便释放内存资源（这个过程会重复，直到有足够内存）</p>
<p><strong><img src="D:\Blog\source_posts\6.s081项目八股\image-20240309180738654.png" alt="image-20240309180738654"></strong></p>
<h2 id="9-哪些内存可以被回收？（释放）"><a href="#9-哪些内存可以被回收？（释放）" class="headerlink" title="9 哪些内存可以被回收？（释放）"></a>9 哪些内存可以被回收？（释放）</h2><p><strong>文件页：</strong>内核缓存的磁盘数据和文件数据。</p>
<p>​	回收干净页可以直接释放内存，回收脏页需要先写回磁盘后再释放内存（脏页：被修改过，但还没被写入磁盘）</p>
<p><strong>匿名页：</strong>没有实际载体，如堆、栈数据等。</p>
<p>​	通过linux的Swap机制，把不常访问的内存先换到磁盘，然后释放这些内存，等再访问时重新从磁盘读入</p>
<p>内存回收基于LRU算法（最久不使用）</p>
<h3 id="注：内存回收有性能影响吗？"><a href="#注：内存回收有性能影响吗？" class="headerlink" title="注：内存回收有性能影响吗？"></a>注：内存回收有性能影响吗？</h3><p>对于文件页的回收，如果是干净页，不会影响；如果是脏页，会发生磁盘IO，会影响系统性能</p>
<p>对于匿名页的回收，Swap机制是换到磁盘中，有IO操作，影响性能</p>
<p>基于此，我们可以减少匿名页的回收：Linux提供了一个<code> swappiness</code>的选项，0-100数值越大越倾向于使用Swap，可以将其调小一点（默认60）</p>
<h2 id="10-malloc申请的内存，free释放内存会归还给操作系统吗？"><a href="#10-malloc申请的内存，free释放内存会归还给操作系统吗？" class="headerlink" title="10 malloc申请的内存，free释放内存会归还给操作系统吗？"></a>10 malloc申请的内存，free释放内存会归还给操作系统吗？</h2><ul>
<li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>（程序结束时归还）</li>
<li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong></li>
</ul>
<h3 id="注：为什么brk（）申请内存更好？"><a href="#注：为什么brk（）申请内存更好？" class="headerlink" title="注：为什么brk（）申请内存更好？"></a>注：为什么brk（）申请内存更好？</h3><p>brk（）在堆中申请内存，由于堆是连续的，可以直接预分配更大的内存缓存在内存池中，等下次再申请内存时，直接取已经有映射的内存块就行，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，降低了cpu的消耗</p>
<h3 id="注：那为什么不全部用brk（）？"><a href="#注：那为什么不全部用brk（）？" class="headerlink" title="注：那为什么不全部用brk（）？"></a>注：那为什么不全部用brk（）？</h3><p>会产生很多不可用的内存碎片，导致内存泄漏</p>
<h2 id="11-如何避免预读失效和缓存污染？"><a href="#11-如何避免预读失效和缓存污染？" class="headerlink" title="11 如何避免预读失效和缓存污染？"></a>11 如何避免预读失效和缓存污染？</h2><p><strong>预读机制：</strong>Linux基于Page Cache的读缓存机制，根据空间局部性原理，在将磁盘数据加载到内存时会往后多读一些page，下次在往后读时就可以直接在Page Cache中命中，减少了磁盘IO的次数</p>
<p><strong>预读失效：</strong>如果被提前加载进来的页并没有被访问，就是预读失效</p>
<p>预读失效的问题主要体现在传统LRU算法上，它会把没被访问的预读页添加到链表头部，可能会把热点数据挤到链表尾部，甚至是淘太，这就大大降低了缓存命中率</p>
<p><strong>如何避免：</strong>改进LRU算法，采用<strong>活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）</strong>，将预读页加入到非活跃LRU链表，只有当页真正被访问时，才将其插入活跃LRU链表头部，这样就不会影响活跃链表中的热点数据。</p>
<p>（MySql的Innodb存储引擎将LRU链表划分为young区域和old区域，分别有各自的头尾节点，改进原理跟linux的一样）</p>
<p><strong>缓存污染：</strong>在批量读取数据时，由于这些数据被访问了一次，会将其加入到活跃LRU链表，而之前缓存在活跃LRU链表上的热点数据都会被淘太，如果新加入的这些数据并不是热点数据（很久都不会再访问），那整个LRU链表就相当于被污染了</p>
<p>这会导致，当这些被淘汰的热点数据再次被访问时，由于缓存未命中，就会产生大量的磁盘IO，系统性能会急剧下降</p>
<p><strong>如何避免：</strong>提高进入LRU活跃链表的门槛。linux在内存页被访问第二次时，才将其加入到活跃链表；Mysql不仅要内存页被访问第二次，还要判断两次访问的时间间隔是否达到要求（在非活跃LRU链表中停留时间是否够长）</p>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
  </entry>
  <entry>
    <title>c++基础知识</title>
    <url>/2024/03/09/c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1、顶层const和底层const？"><a href="#1、顶层const和底层const？" class="headerlink" title="1、顶层const和底层const？"></a>1、顶层const和底层const？</h2><p>顶层const：const修饰的是指针本身（或变量本身）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr； <span class="comment">// 顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i； <span class="comment">// 顶层const</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> i; <span class="comment">// 与上面等价</span></span><br></pre></td></tr></table></figure>

<p>底层const：const修饰的是指针所指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr； <span class="comment">// 底层const</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr;  <span class="comment">// 底层const，与上面等价</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> ptr;  <span class="comment">// 顶层+底层</span></span><br></pre></td></tr></table></figure>

<p>如何快速区别：看*是不是挨着ptr——如果挨着说明ptr就是普通指针，const修饰指针所指的对象；如果不挨着，说明const修饰ptr，指针本身不可变，是常量</p>
<h2 id="2、指针和引用的区别？"><a href="#2、指针和引用的区别？" class="headerlink" title="2、指针和引用的区别？"></a>2、指针和引用的区别？</h2><ol>
<li><p>指针本身是一个变量，占有存储空间，存储所指对象的地址；</p>
<p>引用跟原来的变量是一个东西，是它的别名</p>
</li>
<li><p>指针可以先声明再初始化，引用在声明时就需要初始化</p>
</li>
<li><p>指针初始化后可以改变指向，引用不可以</p>
</li>
<li><p>指针可以为空，引用不可以</p>
</li>
<li><p>有多级指针，没有多级引用</p>
</li>
</ol>
<h3 id="注：函数传参，什么时候使用指针和引用？"><a href="#注：函数传参，什么时候使用指针和引用？" class="headerlink" title="注：函数传参，什么时候使用指针和引用？"></a>注：函数传参，什么时候使用指针和引用？</h3><ul>
<li>引用传递不需要创建临时变量，开销更小，不是非必要场景下尽量使用引用。比如：类对象作为参数传递时使用引用，可以避免拷贝构造和析构的开销</li>
<li>需要在函数内修改所指向的对象，用指针</li>
<li>需要重新动态分配内存，用指针</li>
<li>如果已知参数可能为空，用指针</li>
</ul>
<h3 id="注：区别以下指针类型？"><a href="#注：区别以下指针类型？" class="headerlink" title="注：区别以下指针类型？"></a>注：区别以下指针类型？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p[10]  // p是大小为10的数组，数组存储的元素都是int类型的指针</span><br><span class="line">int (*p)[10]  // p是一个数组指针，数组存储的元素是int类型，大小为10</span><br><span class="line">int *p(int)  // 函数声明，p是函数名，返回值是int*，参数是int</span><br><span class="line">int (*p)(int) // 函数指针，p是指针名，返回值是int，参数是int</span><br></pre></td></tr></table></figure>

<h2 id="3、堆和栈的区别？"><a href="#3、堆和栈的区别？" class="headerlink" title="3、堆和栈的区别？"></a>3、堆和栈的区别？</h2><p>堆和栈是内存中两种不同的数据存储方式。</p>
<ol>
<li>分配方式<ol>
<li>堆是手动分配和释放的，需要调用new或malloc分配，调用delete和free释放</li>
<li>栈是自动分配和释放的</li>
</ol>
</li>
<li>空间大小<ol>
<li>堆的大小比较大，可以根据需要动态调整，但会产生内存碎片</li>
<li>栈的大小固定，一般比较小，在编译时确定，不会产生碎片</li>
</ol>
</li>
<li>存储内容<ol>
<li>堆存储运行时动态分配的数据</li>
<li>栈存储函数的局部变量、函数参数和函数调用的返回地址等</li>
</ol>
</li>
</ol>
<h3 id="注：堆快还是栈快？"><a href="#注：堆快还是栈快？" class="headerlink" title="注：堆快还是栈快？"></a>注：堆快还是栈快？</h3><p>栈快。</p>
<p>因为操作系统底层对栈提供支持，会分配专门的栈寄存器，入栈出栈操作简单，并且有专门的指令执行，因此效率很高；</p>
<p>而堆的操作由c&#x2F;c++函数库提供，需要算法确定内存大小，并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢</p>
<h2 id="4、new-delete和malloc-free的异同？"><a href="#4、new-delete和malloc-free的异同？" class="headerlink" title="4、new&#x2F;delete和malloc&#x2F;free的异同？"></a>4、new&#x2F;delete和malloc&#x2F;free的异同？</h2><p>（有了malloc&#x2F;free，为什么还需要new&#x2F;delete？）</p>
<p>相同点：都是用于内存的动态申请和释放</p>
<p>不同点：</p>
<ul>
<li>new&#x2F;delete是c++中的关键字，是类型安全的；malloc&#x2F;free是c标准库中的函数，需要库文件支持，并且不是类型安全的</li>
<li>new&#x2F;delete会自动调用对象的构造函数和析构函数；malloc&#x2F;free仅仅分配和回收内存空间</li>
<li>new自动计算分配的空间大小；malloc需要手工计算</li>
<li>new返回具体类型指针；malloc返回void*类型的指针，需要类型转换</li>
</ul>
<p>总结：c++中推荐使用new&#x2F;delete，因为它们更安全，更易于使用，并且与对象的生命周期更好的结合</p>
<h3 id="注：malloc如何分配内存？"><a href="#注：malloc如何分配内存？" class="headerlink" title="注：malloc如何分配内存？"></a>注：malloc如何分配内存？</h3><ul>
<li>方式一：通过 brk() 系统调用从堆分配内存（小于128k）</li>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存（大于128k）</li>
</ul>
<p>malloc分配的是虚拟内存，会预分配更大的空间</p>
<h3 id="注：被free回收的内存是立即返还给操作系统吗？"><a href="#注：被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="注：被free回收的内存是立即返还给操作系统吗？"></a>注：被free回收的内存是立即返还给操作系统吗？</h3><ul>
<li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>；</li>
<li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong>。</li>
</ul>
<h2 id="5、宏定义和函数的区别？和typedef的区别？和内联函数的区别？"><a href="#5、宏定义和函数的区别？和typedef的区别？和内联函数的区别？" class="headerlink" title="5、宏定义和函数的区别？和typedef的区别？和内联函数的区别？"></a>5、宏定义和函数的区别？和typedef的区别？和内联函数的区别？</h2><p>与函数的区别：</p>
<ol>
<li>使用时机<ol>
<li>宏定义在预处理阶段展开，单纯进行文本替换，执行起来更快</li>
<li>函数在程序运行时调用，需要跳到具体的执行函数</li>
</ol>
</li>
<li>类型安全<ol>
<li>宏定义没有类型检查</li>
<li>函数有类型检查，更安全</li>
</ol>
</li>
<li>返回值<ol>
<li>宏定义没有返回值</li>
<li>函数有返回值</li>
</ol>
</li>
<li>维护性<ol>
<li>宏定义过多会导致代码难以理解和维护，甚至产生意外错误</li>
<li>函数可以提供更好的封装和复用，提供代码的可读性，方便维护</li>
</ol>
</li>
</ol>
<p>与typedef的区别：</p>
<ol>
<li><p>作用范围</p>
<ol>
<li>宏定义作用于整个文件，对所有在其之后出现的代码都有效</li>
<li>typedef是一种声明已有类型别名的关键字，只在声明的作用域有效</li>
</ol>
</li>
<li><p>类型安全</p>
<ol>
<li>宏定义没有类型检查</li>
<li>typedef有类型检查</li>
</ol>
</li>
<li><p>在有指针的场合下</p>
<ol>
<li>宏只是简单的文体替换</li>
<li>typedef为一个类型起别名，可以同时声明多个指针对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *p1;  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> p2 char *;  </span></span><br><span class="line">p1 s1, s2;  </span><br><span class="line">p2 s3, s4; </span><br><span class="line"><span class="comment">//s1、s2、s3都被定义为char * ，s4则定义成了char</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>内联函数：</p>
<p>编译器会在每个调用内联函数的地方直接将函数体插入，而不是像普通函数一样调用和返回</p>
<ul>
<li>使用宏定义的地方都可以使用 inline 函数</li>
<li>内联函数有类型检测、语法判断等功能，而宏没有</li>
<li>内联函数在调试时更容易理解，因为它们就像普通函数一样，可以单步调试</li>
<li>内联函数的作用域受限于声明的范围，只能在声明的文件中使用</li>
</ul>
<h2 id="6、变量声明和定义的区别？"><a href="#6、变量声明和定义的区别？" class="headerlink" title="6、变量声明和定义的区别？"></a>6、变量声明和定义的区别？</h2><p>声明只是把变量引入，告诉编译器变量名称和类型，但不分配内存和初始化；</p>
<p>定义要为变量分配内存以及初始化，同时也包括了声明的过程</p>
<p>相同变量可以在多处声明，但只能在一处定义</p>
<p>（关键字extern：用于外部声明变量或函数）</p>
<h2 id="7、strlen和sizeof的区别？"><a href="#7、strlen和sizeof的区别？" class="headerlink" title="7、strlen和sizeof的区别？"></a>7、strlen和sizeof的区别？</h2><ul>
<li><p>sizeof是运算符，strlen是库函数</p>
</li>
<li><p>sizeof参数可以是任何数据类型，用于获取数据在内存中的大小；strlen参数只能是字符指针且结尾是’\0’的字符串，用于字符串长度计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="built_in">sizeof</span>(str); <span class="comment">// 取的是str指针的长度，大小为4/8</span></span><br><span class="line"><span class="built_in">strlen</span>(str); <span class="comment">// 取的是str字符串的长度，不包含\0，大小是4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>sizeof的值在编译时确定，不能用来获取动态分配的内存大小</p>
</li>
</ul>
<h2 id="8、c-和c语言的区别？"><a href="#8、c-和c语言的区别？" class="headerlink" title="8、c++和c语言的区别？"></a>8、c++和c语言的区别？</h2><ol>
<li><p>面向对象（本质）</p>
<ol>
<li>c++是一种面向对象的编程语言，支持类、继承和多态等</li>
<li>c语言是面向过程的</li>
</ol>
</li>
<li><p>类和对象</p>
<ol>
<li>c++通过定义类和对象实现数据和方法的封装</li>
<li>c语言没有类和对象，数据和函数之间关系比较松散，只能通过结构体来封装数据</li>
</ol>
</li>
<li><p>重载</p>
<ol>
<li>c++支持函数重载、运算符重载</li>
<li>c语言不支持</li>
</ol>
</li>
<li><p>STL</p>
<ol>
<li>c++提供了STL，包括容器、算法和迭代器等，用于实现通用的数据结构和算法</li>
<li>c语言通常需要自己实现类似功能</li>
</ol>
</li>
<li><p>新增</p>
<ol>
<li>c++在c语言的基础上新增了引用、string类型、命名空间、异常处理机制等</li>
</ol>
<p>总结：c++更适合开发复杂的应用程序和大型项目，c语言更加简单、轻量，适用于嵌入式系统和操作系统等底层开发领域</p>
</li>
</ol>
<h2 id="9、c-中class和struct的区别？"><a href="#9、c-中class和struct的区别？" class="headerlink" title="9、c++中class和struct的区别？"></a>9、c++中class和struct的区别？</h2><ol>
<li>成员访问权限<ol>
<li>class默认成员访问权限是private</li>
<li>struct默认成员访问权限是public</li>
</ol>
</li>
<li>继承方式<ol>
<li>class默认继承方式是private</li>
<li>struct默认继承方式是public</li>
</ol>
</li>
</ol>
<h3 id="注：c-和c的struct区别？"><a href="#注：c-和c的struct区别？" class="headerlink" title="注：c++和c的struct区别？"></a>注：c++和c的struct区别？</h3><ol>
<li>c++中的struct可以包含成员函数，c中struct只有数据成员</li>
<li>c++有访问权限设置，分为public、private和protected</li>
<li>c++中结构体可以实现继承和多态</li>
<li>c++中结构体可以有构造函数和析构函数</li>
</ol>
<p>c++中的struct与class类似，任何可以使用class完成的工作，同样可以用struct完成</p>
<h2 id="10、c-中const关键字的作用？"><a href="#10、c-中const关键字的作用？" class="headerlink" title="10、c++中const关键字的作用？"></a>10、c++中const关键字的作用？</h2><p><strong>const在编译期间告诉编译器被修饰的内容不能被修改</strong></p>
<p>const修饰的内容，都受到强制保护，可以预防其它代码的无意识修改，提高程序的健壮性。，若不初始化，在后面也不能再初始化了</p>
<ol>
<li><strong>const定义一个常量</strong></li>
<li><strong>const修饰变量</strong><ol>
<li><strong>const 全局变量被用来替换一般常量宏定义</strong>，会进行类型检查</li>
<li><strong>会把全局变量的作用范围限制在定义它的源文件中</strong></li>
<li><strong>必须初始化</strong></li>
<li>const修饰局部变量会产生常量折叠现象<br>（想获取修改后的const局部变量真实值可以使用volatile，使得程序每次直接去内存中读取变量值而不是读寄存器值）</li>
</ol>
</li>
<li><strong>const修饰指针和引用</strong><ol>
<li>修饰指针：顶层const和底层const</li>
<li>修饰引用：非const引用只能绑定非const对象，const引用可以绑定任意对象，并且都当做常对象；常引用经常用作形参，防止函数内对象被意外修改</li>
</ol>
</li>
<li><strong>const修饰函数参数</strong><ol>
<li>防止函数体内可能会修改参数原始对象</li>
</ol>
</li>
<li><strong>const修饰函数返回值</strong><ol>
<li>令函数返回一个常量，可以有效防止因用户错误造成的意外</li>
</ol>
</li>
<li><strong>const修饰成员函数和成员变量</strong><ol>
<li>const成员函数为const对象的唯一对外接口（禁止const对象调用类的非const成员函数）</li>
<li>const 成员函数不能修改对象的数据（除非用<code>mutable</code>修饰成员变量）</li>
<li><strong>类的数据成员只能在构造函数中使用初始化列表的方式赋初值</strong></li>
<li>如果为static const数据成员，由于不属于具体对象，不能在构造函数里赋值，应该在类外赋值。特别地，如果静态常量为<strong>整数或枚举</strong>类型，C++允许在类内定义时指定常量值</li>
</ol>
</li>
<li><strong>const修饰类对象</strong><ol>
<li><strong>不能修改任何成员变量，不能调用非const成员函数</strong></li>
</ol>
</li>
</ol>
<h3 id="注：c-11的constexpr？"><a href="#注：c-11的constexpr？" class="headerlink" title="注：c++11的constexpr？"></a>注：c++11的constexpr？</h3><p>常量表达式与非常量表达式的运算时机不同：</p>
<p>常量表达式在编译时计算，非常量表达式在运行时计算，因此用<strong>constexpr</strong>定义的常量表达式可以提高程序运行效率</p>
<p>constexpr也可以定义一个常量（定义常量推荐使用constexper，因为可以直接判断是否为常量表达式）</p>
<p>constexpr不能直接修饰struct或class，可以修饰创建的实例对象</p>
<ul>
<li>constexpr修饰的变量<strong>必须使用常量表达式初始化，必须在编译时初始化</strong>；const修饰的变量<strong>可以使用非常量表达式初始化，可以在运行时初始化</strong></li>
</ul>
<h2 id="11、c-中static的作用？"><a href="#11、c-中static的作用？" class="headerlink" title="11、c++中static的作用？"></a>11、c++中static的作用？</h2><ol>
<li><strong>static修饰局部变量–持久(记忆功能和全局生存期)</strong><ol>
<li>在函数中声明变量时，static 关键字指定变量只初始化一次，并在之后调用该函数时保留其状态</li>
<li>static关键字修饰<strong>局部变量不改变作用域，但是生命周期变长</strong>（改变了局部变量的存储位置，从栈区变为静态区）</li>
<li><strong>static的另一个作用是默认初始化为0</strong></li>
</ol>
</li>
<li><strong>static修饰全局变量和函数–隐藏（避免命名冲突）</strong><ol>
<li>static 关键字指定变量或函数为<strong>内部链接</strong>，即外部文件无法引用该变量或函数<strong>（使全局变量的作用域变小）</strong></li>
</ol>
</li>
<li><strong>static修饰成员变量和成员函数</strong><ol>
<li><strong>静态成员</strong>为所有类对象所共享，<strong>不属于某个具体的实例对象</strong></li>
<li>类的静态非常量成员不允许在类内部直接初始化<br>（只有static没有const）</li>
<li><strong>静态成员函数</strong>没有隐藏的this指针，<strong>不能访问非静态成员</strong>（可以通过传递参数访问）</li>
</ol>
</li>
</ol>
<h3 id="注：静态变量什么时候初始化？"><a href="#注：静态变量什么时候初始化？" class="headerlink" title="注：静态变量什么时候初始化？"></a>注：静态变量什么时候初始化？</h3><p>在程序首次执行到其定义处进行初始化，初始化只有一次，但可以多次赋值，在主程序前，编译器已经为其分配好内存</p>
<h2 id="12、c-的匿名对象？"><a href="#12、c-的匿名对象？" class="headerlink" title="12、c++的匿名对象？"></a>12、c++的匿名对象？</h2><p>“ 匿名对象 “ 指的是 没有 显式指定名称 的 类 的 实例对象 ;</p>
<p>匿名对象 通常用于 临时计算 或 作为函数的 参数 &#x2F; 返回值 传递 ;</p>
<p><strong>“ 匿名对象 “ 通常只在创建它的语句中使用 , 并且在语句结束时会被销毁 ;</strong></p>
<p>作用域仅限于其所在的表达式中 ;</p>
<h2 id="13、数组名和指针（指向数组首元素的指针）的区别？"><a href="#13、数组名和指针（指向数组首元素的指针）的区别？" class="headerlink" title="13、数组名和指针（指向数组首元素的指针）的区别？"></a>13、数组名和指针（指向数组首元素的指针）的区别？</h2><p>数组名是一个常量指针，指向数组的第一个元素，不能被重新赋值，不能自增、自减，sizeof（数组名）返回整个数组大小；</p>
<p>指向数组首元素的指针是一个普通指针，可以被重新赋值，可以自增、自减，sizeof（指针）返回指针的 大小</p>
<h2 id="14、final和override关键字？"><a href="#14、final和override关键字？" class="headerlink" title="14、final和override关键字？"></a>14、final和override关键字？</h2><p>当在父类中使用了虚函数，可能需要在某个子类中对这个虚函数进行重写。override指定了子类的这个虚函数是重写父类的，如果函数名字不小心打错，编译器是不会编译通过的（不加override，编译器认为是新的函数，不会报错）</p>
<p>final表示不希望某个类被继承、某个虚函数被重写。在类名和虚函数后添加final关键字，被继承或重写时编译器会报错。</p>
<h2 id="15、volatile、mutable和explicit关键字？"><a href="#15、volatile、mutable和explicit关键字？" class="headerlink" title="15、volatile、mutable和explicit关键字？"></a>15、volatile、mutable和explicit关键字？</h2><p>volatile：告诉编译器不要优化某些可能会被程序的外部因素更改的变量，确保每次访问该变量都是从内存中读取最新的值，而不是读取寄存器的缓存值</p>
<p>（使用场景：多线程环境、硬件寄存器、信号处理等）</p>
<p>mutable：是为了突破const的限制而设置的，用于修饰类的成员变量。当一个成员变量被声明为 <code>mutable</code> 时，即使该变量所属的对象是 <code>const</code> 类型，也可以在 <code>const</code> 成员函数中修改该变量的值</p>
<p>explicit：修饰类的构造函数，被修饰的类，不能发生相应的隐式类型转换，只能以<strong>显式的方式进行类型转换</strong>（explicit 只能用于类内部的构造函数），可以避免二义性（无法确定使用哪个构造函数）</p>
<h2 id="16、什么情况下会调用拷贝构造函数？"><a href="#16、什么情况下会调用拷贝构造函数？" class="headerlink" title="16、什么情况下会调用拷贝构造函数？"></a>16、什么情况下会调用拷贝构造函数？</h2><ol>
<li>使用一个对象来初始化另一个对象</li>
<li>以值传递的方式作为函数参数（指针和引用传递不拷贝）</li>
<li>函数返回一个对象，需要创建副本（临时对象）</li>
</ol>
<p>默认拷贝构造函数是浅拷贝（如果对象中有指针成员变量，它们将指向相同的内存地址，可能会导致悬空指针或内存泄漏）</p>
<h2 id="17、野指针和悬空指针？"><a href="#17、野指针和悬空指针？" class="headerlink" title="17、野指针和悬空指针？"></a>17、野指针和悬空指针？</h2><p>野指针：未初始化  （为了防止出错，对于指针初始化时都是赋值为 <code>nullptr</code>）</p>
<p>悬空指针：最初指向的内存已被释放，但指针未置空</p>
<p>防范野指针和悬空指针的方法包括：</p>
<ul>
<li>在释放内存后，及时将指针置为 <code>nullptr</code> 或 <code>NULL</code></li>
<li>使用智能指针</li>
</ul>
<h2 id="18、c-提供了哪些机制保障类型安全？"><a href="#18、c-提供了哪些机制保障类型安全？" class="headerlink" title="18、c++提供了哪些机制保障类型安全？"></a>18、c++提供了哪些机制保障类型安全？</h2><ol>
<li>C++编译器在编译时对类型进行严格的检查</li>
<li>const关键字，防止意外修改</li>
<li>引用，减少了指针带来的潜在风险</li>
<li>模板，避免使用“ void* ”等不安全的类型</li>
<li>STL，提供了类型安全的数据结构和算法</li>
<li>new，返回的指针类型严格与对象匹配，而不是void*</li>
<li><strong>dynamic_cast</strong>关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查</li>
</ol>
<h2 id="19、重载、重写（覆盖）和隐藏的区别？"><a href="#19、重载、重写（覆盖）和隐藏的区别？" class="headerlink" title="19、重载、重写（覆盖）和隐藏的区别？"></a>19、重载、重写（覆盖）和隐藏的区别？</h2><p>重载：同一个作用域内定义多个函数名相同，但参数列表不同的函数（不能依靠返回值重载）</p>
<p>重写：在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>（函数参数个数、参数类型和返回值类型都相同）</p>
<p>重载与重写的区别：</p>
<ul>
<li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li>
<li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li>
<li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li>
</ul>
<p>隐藏：派生类中的函数屏蔽了基类中的同名函数</p>
<ul>
<li>两个函数参数相同，但是基类函数不是虚函数（和重写的区别在于基类函数不是虚函数）</li>
<li>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏（和重载的区别在于两个函数不在同一个类中）</li>
</ul>
<h2 id="20、浅拷贝和深拷贝的区别？"><a href="#20、浅拷贝和深拷贝的区别？" class="headerlink" title="20、浅拷贝和深拷贝的区别？"></a>20、浅拷贝和深拷贝的区别？</h2><p>浅拷贝只是将一个对象的值复制到另一个对象，不复制对象所包含的动态分配的内存，没有开辟新的内存空间，两个对象指向同一块内存地址，如果其中一个对象被修改或释放，另一个对象也会受到影响</p>
<p>深拷贝不仅拷贝值，还开辟一块新的空间来存储这个拷贝，也会复制该对象所包含的动态资源，即使原先的内容被修改或释放，也不影响深拷贝得到的对象</p>
<h2 id="21、如何用代码判断大小端存储？"><a href="#21、如何用代码判断大小端存储？" class="headerlink" title="21、如何用代码判断大小端存储？"></a>21、如何用代码判断大小端存储？</h2><p>大端：高字节存储在低地址</p>
<p>小端：低字节存储在低地址</p>
<p><strong>方式一：使用强制类型转换</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0x1234;</span><br><span class="line">    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span><br><span class="line">    char c = (char)(a);</span><br><span class="line">    if (c == 0x12)</span><br><span class="line">        cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;</span><br><span class="line">    else if(c == 0x34)</span><br><span class="line">        cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式二：巧用union联合体</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="line">union endian</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char ch;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = 0x1234;</span><br><span class="line">    //a和ch共用4字节的内存空间</span><br><span class="line">    if (value.ch == 0x12)</span><br><span class="line">        cout &lt;&lt; &quot;big endian&quot;&lt;&lt;endl;</span><br><span class="line">    else if (value.ch == 0x34)</span><br><span class="line">        cout &lt;&lt; &quot;little endian&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22、c-中有几种类型的new？"><a href="#22、c-中有几种类型的new？" class="headerlink" title="22、c++中有几种类型的new？"></a>22、c++中有几种类型的new？</h2><p>（1）<strong>plain new</strong>：普通的new，用于动态分配内存，并返回指向新分配的内存的指针，如果内存分配失败，会抛出<code> std::bad_alloc</code>异常</p>
<p>（2）<strong>nothrow new</strong>：与普通的new类似，唯一不同的是在内存分配失败时不会抛出异常，而是返回nullptr</p>
<p>（3）<strong>placement new</strong>：可以在预先分配的内存地址上创建对象或数组，而不是动态分配新的内存空间（用于特殊内存管理需求，如自定义内存池）</p>
<p>placement new不能用delete，因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误</p>
<h2 id="23、c-的异常处理方法？"><a href="#23、c-的异常处理方法？" class="headerlink" title="23、c++的异常处理方法？"></a>23、c++的异常处理方法？</h2><ol>
<li><strong>try、throw和catch关键字</strong></li>
<li><strong>函数的异常声明列表</strong>（c++11以后被废弃）<ol>
<li>在函数声明或定义中使用throw关键字指定函数可能抛出的异常类型</li>
<li>如果为throw（）或noexcept，表示不会抛出异常</li>
</ol>
</li>
<li><strong>C++标准异常类 exception</strong></li>
</ol>
<h2 id="24、类成员初始化方式？"><a href="#24、类成员初始化方式？" class="headerlink" title="24、类成员初始化方式？"></a>24、类成员初始化方式？</h2><ol>
<li>默认成员初始化<ol>
<li>在定义成员变量时直接指定默认值，未在构造函数中初始化的成员会使用这些默认值</li>
</ol>
</li>
<li>构造函数内赋值初始化<ol>
<li>在构造函数内对成员变量进行初始化，可以实现更复杂的逻辑</li>
</ol>
</li>
<li>构造函数初始化列表<ol>
<li>最常见和推荐</li>
<li>作用：提高效率、确保正确的初始化顺序、确保常量和引用在对象创建时就被初始化</li>
</ol>
</li>
</ol>
<p>区别：构造函数内初始化，是在所有成员变量被分配内存后才进行的；</p>
<p>列表初始化是在给成员变量分配内存空间时就进行初始化，是在未进入函数体之前</p>
<h3 id="注：为什么初始化列表更快？"><a href="#注：为什么初始化列表更快？" class="headerlink" title="注：为什么初始化列表更快？"></a>注：为什么初始化列表更快？</h3><p>赋值操作会产生临时对象，降低效率；初始化列表不会产生临时对象，它在资源创建即初始化</p>
<h3 id="注-哪些情况必须使用初始化列表？"><a href="#注-哪些情况必须使用初始化列表？" class="headerlink" title="注: 哪些情况必须使用初始化列表？"></a>注: 哪些情况必须使用初始化列表？</h3><ol>
<li>常量成员初始化：常量成员必须在对象创建时就被初始化</li>
<li>引用类型成员初始化：引用类型成员必须在对象创建时被初始化为某个对象</li>
</ol>
<h2 id="25、c-中新增的string，与char-有什么区别？它是如何实现的？"><a href="#25、c-中新增的string，与char-有什么区别？它是如何实现的？" class="headerlink" title="25、c++中新增的string，与char*有什么区别？它是如何实现的？"></a>25、c++中新增的string，与char*有什么区别？它是如何实现的？</h2><p>string封装了字符串的操作，例如长度、容量等，并且提供了动态内存管理，可以自动处理字符串的内存分配和释放，避免了内存泄漏、越界等问题；使用char*时需要调用malloc、realloc、free等函数来手动分配和释放内存，容易出现内存泄漏、越界等问题，并且<code>char*</code>作为一个指针，不会记录字符串长度、容量等信息，需要额外的机制来获取</p>
<h2 id="26、c-面向对象的三大特性？"><a href="#26、c-面向对象的三大特性？" class="headerlink" title="26、c++面向对象的三大特性？"></a>26、c++面向对象的三大特性？</h2><p><strong>封装：把客观事物抽象成类</strong>，包括成员函数和成员数据，可以设置访问权限</p>
<p><strong>继承：子类直接获得父类的属性和方法</strong>，包括接口继承<em>（虚函数）–只继承名字</em>和实现继承<em>（普通函数）–继承名字和实现</em></p>
<p><strong>多态：同一事物表现出不同事物的能力</strong>，包括运行时多态（覆盖）和编译时多态（重载）</p>
<h2 id="27、实现多态的方式？"><a href="#27、实现多态的方式？" class="headerlink" title="27、实现多态的方式？"></a>27、实现多态的方式？</h2><p>运行时多态（动态多态、晚绑定）：<strong>覆盖override：虚函数–父子类</strong></p>
<p>​	概括：父类声明或定义了一个虚函数（virtual），子类重写此虚函数</p>
<p>​	关键字：override和final</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象是派生类，就会调用派生类中函数，如果对象类型是基类，就调用基类的函数。</p>
<p>编译时多态（静态多态、早绑定）：<strong>重载overload：参数表不同–同一作用域</strong></p>
<p><em>注意区别：重定义–子类隐藏了父类的函数</em></p>
<h3 id="注：抽象类？（纯虚函数）"><a href="#注：抽象类？（纯虚函数）" class="headerlink" title="注：抽象类？（纯虚函数）"></a>注：抽象类？（纯虚函数）</h3><p>有纯虚函数的类就叫抽象类，也叫接口类，不能实例化出对象</p>
<p>纯虚函数：虚函数后面加<code> =0</code></p>
<p>纯虚函数主要用来定义接口，强制子类重写函数</p>
<p>纯虚函数：只有函数声明，没有默认的函数实现，派生类必须重写该函数，禁止实例化</p>
<h3 id="注：虚函数实现的原理？（多态实现的原理）"><a href="#注：虚函数实现的原理？（多态实现的原理）" class="headerlink" title="注：虚函数实现的原理？（多态实现的原理）"></a>注：虚函数实现的原理？（多态实现的原理）</h3><p>虚函数表vtable和虚函数指针vptr</p>
<p>每个包含虚函数的类都有自己的虚函数表，虚函数表存储所有的虚函数地址（本质上是一个指针数组），在调用时通过虚函数指针在表中找对应的函数实现</p>
<p>当子类覆盖了父类的虚函数时，子类会更新虚函数表，替换对应的虚函数地址</p>
<p>虚函数指针vptr是类对象隐藏的一个成员变量，存储在类的实例化对象中（占内存）</p>
<p><strong>注：构造函数不能是虚函数</strong>：因为虚函数指针是在对象构造完成后才被设置好的</p>
<p>基类的析构函数必须是虚函数：否则，在使用基类指针指向派生类对象，并通过该指针删除这个对象时，只会调用基类的析构函数，不调用派生类的析构函数</p>
<h2 id="28、什么是内存泄漏？如何避免？"><a href="#28、什么是内存泄漏？如何避免？" class="headerlink" title="28、什么是内存泄漏？如何避免？"></a>28、什么是内存泄漏？如何避免？</h2><p>由于疏忽或错误，程序没有释放那些不再使用的内存，导致对那些内存失去控制，无法再被使用，造成内存浪费</p>
<p>例如堆内存泄漏、系统资源泄漏（文件描述符）、没有将基类的析构函数定义为虚函数等</p>
<p>如何避免？</p>
<p>1、将内存的分配封装在类中，构造函数分配内存，析构函数释放内存</p>
<p>2、使用智能指针</p>
<h2 id="29、什么是内存对齐？为什么要考虑内存对齐？"><a href="#29、什么是内存对齐？为什么要考虑内存对齐？" class="headerlink" title="29、什么是内存对齐？为什么要考虑内存对齐？"></a>29、什么是内存对齐？为什么要考虑内存对齐？</h2><p>内存对齐是指数据在内存中的存储起始地址是某个值的整数倍，比如4字节的int型，其起始地址应该能被4整除。</p>
<p>需要内存对齐的根本原因是cpu访问内存数据的效率问题，此外还有计算机硬件要求、提高缓存性能等</p>
<h1 id="c-11新标准"><a href="#c-11新标准" class="headerlink" title="c++11新标准"></a>c++11新标准</h1><h2 id="1、c-11有哪些新特性？"><a href="#1、c-11有哪些新特性？" class="headerlink" title="1、c++11有哪些新特性？"></a>1、c++11有哪些新特性？</h2><ol>
<li>nullptr替代NULL</li>
<li>引入auto和decltype两个关键字实现类型推导</li>
<li>基于范围的for循环–for（auto &amp;i：res）{}</li>
<li>类和结构体的初始化列表</li>
<li>Lambda表达式（匿名函数）</li>
<li>std::forward_list(单向链表)</li>
<li>右值引用和move语义</li>
<li>constexpr修饰常量表达式</li>
<li>字符串原始字面量 R “ xxxx（）xxxx”</li>
<li>委托构造函数、继承构造函数</li>
</ol>
<h2 id="2、auto、decltype和decltype（auto）用法？"><a href="#2、auto、decltype和decltype（auto）用法？" class="headerlink" title="2、auto、decltype和decltype（auto）用法？"></a>2、auto、decltype和decltype（auto）用法？</h2><p>（1）auto</p>
<p><strong>在声明变量时由编译器自动推导其类型</strong></p>
<p><strong><code>auto</code> 推导的类型会根据初始化表达式的类型来确定，而不是变量本身的类型</strong></p>
<p><strong>auto定义的变量必须初始化</strong></p>
<ul>
<li>当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字</li>
<li>当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通；类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;<span class="comment">// c为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i; <span class="comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以k的类型是const int*（取地址，这个指针是可变的）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> l = i; <span class="comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">//z是int型不是int&amp; 型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y; <span class="comment">//p1是int&amp;型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2是指针类型int*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>auto的限制：</strong></p>
<ol>
<li><p>不能作为函数参数使用</p>
<ol>
<li>因为只有在函数调用时才会传递实参，auto要求被修饰的变量已初始化</li>
</ol>
</li>
<li><p>不能用于类的非静态成员变量的初始化</p>
<ol>
<li>类的非静态成员变量不能在类内初始化（除非再加上const）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="number">0</span>;                    <span class="comment">// error</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;             <span class="comment">// error,类的静态非常量成员不允许在类内部直接初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;      <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能使用auto关键字定义数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// 定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t1 = array;        <span class="comment">// ok, t1被推导为 int* 类型</span></span><br><span class="line">    <span class="keyword">auto</span> t2[] = array;      <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">// error, auto无法定义数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无法使用auto推导出模板参数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">    Test&lt;<span class="keyword">auto</span>&gt; t1 = t;           <span class="comment">// error, 无法推导出模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>auto的应用场景：</strong></p>
<ol>
<li><p>用于STL的容器遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    <span class="comment">//map&lt;int, string&gt;::iterator it = person.begin();</span></span><br><span class="line">    <span class="keyword">auto</span> it = person.<span class="built_in">begin</span>();  <span class="comment">// 代码简化</span></span><br><span class="line">    <span class="keyword">for</span> (; it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于泛型编程</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;T1&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;T2&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decltype用于从表达式的类型推导出变量的类型，不会自动忽略引用和const、volatile限定符，一般会严格按照表达式的类型推导</p>
<p>decltype还可以用于获取函数返回值类型或成员变量类型</p>
<p>auto和decltype组合使用：用于泛型编程的返回类型后置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">// 返回类型后置语法</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t+u) </span><br><span class="line">&#123;</span><br><span class="line">    return t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、c-中NULL和nullptr的区别？"><a href="#3、c-中NULL和nullptr的区别？" class="headerlink" title="3、c++中NULL和nullptr的区别？"></a>3、c++中NULL和nullptr的区别？</h2><p>c中NULL被定义为 void*类型</p>
<p>c++中NULL被定义为整数0，无法与真正的0做区分，如果有函数重载，会有二义性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>nullptr能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误</strong></p>
<p>如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
<h2 id="4、智能指针的原理？常用的智能指针有哪些？"><a href="#4、智能指针的原理？常用的智能指针有哪些？" class="headerlink" title="4、智能指针的原理？常用的智能指针有哪些？"></a>4、智能指针的原理？常用的智能指针有哪些？</h2><p>智能指针主要解决的问题：动态分配的内存没有及时释放导致的内存泄漏 或 多次释放同一块内存</p>
<p>shared_ptr：允许多个指针共享同一个对象的所有权，内部使用引用计数来跟踪对象被共享的次数，当计数为0时，自动释放资源</p>
<p>unique_ptr：确保任意时刻只有一个指针可以指向该对象</p>
<p>weak_ptr：用于解决shared_ptr导致的循环引用问题，它可以指向shared_ptr所指向的对象，但不增加其引用计数，不会影响资源的释放</p>
<h3 id="注：如何避免野指针？"><a href="#注：如何避免野指针？" class="headerlink" title="注：如何避免野指针？"></a>注：如何避免野指针？</h3><p>1、在释放内存后将指针置为nullptr</p>
<p>2、避免返回局部变量的指针</p>
<p>3、使用智能指针</p>
<p>4、避免释放函数传递进来的参数指针</p>
<h2 id="5、final关键字、override关键字"><a href="#5、final关键字、override关键字" class="headerlink" title="5、final关键字、override关键字"></a>5、final关键字、override关键字</h2><p>final：限制某个类不能被继承，或者某个虚函数不能被重写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Child final: public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void test()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child class...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// Child类不能被继承</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Child : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void test() final</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child class...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//test函数不能被重写</span><br></pre></td></tr></table></figure>

<p>override：保证派生类中声明的重写函数与基类的虚函数有相同的签名，也保证会重写该虚函数（用于派生类中的函数）</p>
<h2 id="6、using的作用？"><a href="#6、using的作用？" class="headerlink" title="6、using的作用？"></a>6、using的作用？</h2><ol>
<li>using namespace<ol>
<li>将一个命名空间中的所有名称导入到当前作用域，可以不加::（作用域解析运算符）—可能导致命名冲突</li>
</ol>
</li>
<li>定义别名–与typedef作用一样（using更直观）<ol>
<li>基础类型、指针别名  </li>
<li>模板类型别名</li>
<li>函数别名</li>
<li>命名空间别名</li>
</ol>
</li>
</ol>
<h2 id="7、委托构造函数"><a href="#7、委托构造函数" class="headerlink" title="7、委托构造函数"></a>7、委托构造函数</h2><p>允许一个构造函数调用同一个类的另一个构造函数，需要在初始化列表中调用</p>
<p>可以复用另一个构造函数的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)  &#123;&#125;  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">MyClass</span>(x)&#123;&#125;  <span class="comment">// 委托构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8、继承构造函数"><a href="#8、继承构造函数" class="headerlink" title="8、继承构造函数"></a>8、继承构造函数</h2><p>通过继承构造函数，派生类可以继承基类的全部或部分构造函数，在派生类中，只需使用 <code>using</code> 关键字将基类的构造函数引入到派生类的作用域中即可。</p>
<p>派生类中就可以不定义相同的构造函数了，保持代码简洁性</p>
<p><code>using 类名::构造函数名</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) : <span class="built_in">x_</span>(x) &#123;&#125;</span><br><span class="line">    <span class="comment">// 其他构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承 Base 的所有构造函数</span></span><br><span class="line">    <span class="comment">// 其他成员和函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数</p>
<h2 id="9、std-initializer-list"><a href="#9、std-initializer-list" class="headerlink" title="9、std::initializer_list"></a>9、std::initializer_list</h2><p>是一个模板类，定义在 <code>&lt;initializer_list&gt;</code> 头文件中</p>
<p>如果想要自定义一个<strong>函数</strong>并且接收任意个数的参数（变参函数），只需要将函数参数指定为std::initializer_list，使用初始化列表{ }作为实参进行数据传递即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void A(std::initializer_list&lt;int&gt; a)</span><br></pre></td></tr></table></figure>

<p>自定义的<strong>类</strong>如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为std::initializer_list类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(std::initializer_list&lt;string&gt; list) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(&#123; <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;lucy&quot;</span>, <span class="string">&quot;tom&quot;</span> &#125;)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(&#123; <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;shijie&quot;</span> &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：必须保证所有的参数类型一致，传入时放在一个<code>初始化列表&#123;&#125;</code>中</p>
<h2 id="10、可调用对象包装器、绑定器"><a href="#10、可调用对象包装器、绑定器" class="headerlink" title="10、可调用对象包装器、绑定器"></a>10、可调用对象包装器、绑定器</h2><p>可调用对象：</p>
<ol>
<li>函数指针</li>
<li>仿函数（具有operator（）成员函数的类对象）</li>
<li>类成员函数指针或类成员指针</li>
<li>可被转换为函数指针的类对象</li>
</ol>
<h2 id="11、lambda表达式"><a href="#11、lambda表达式" class="headerlink" title="11、lambda表达式"></a>11、lambda表达式</h2><p>定义了一个匿名函数，并且可以捕获一定范围内的变量</p>
<p>不需要额外写一个命名函数或函数对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt;ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure>

<p>其中capture是捕获列表，params是参数列表，opt是函数选项，ret是返回值类型，body是函数体。</p>
<p>1 捕获列表可以捕获一定范围内的变量</p>
<ul>
<li><input disabled="" type="checkbox"> <ul>
<li>不捕捉任何变量</li>
</ul>
</li>
<li>[&amp;] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)</li>
<li>[&#x3D;] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)<br>拷贝的副本在匿名函数体内部是只读的</li>
<li>[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo</li>
<li>[bar] - 按值捕获 bar 变量, 同时不捕获其他变量</li>
<li>[&amp;bar] - 按引用捕获 bar 变量, 同时不捕获其他变量</li>
<li>[this] - 捕获当前类中的this指针<ul>
<li>让lambda表达式拥有和当前类成员函数同样的访问权限</li>
<li>如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项</li>
</ul>
</li>
</ul>
<p>2 参数列表</p>
<p>和普通函数的参数列表一样，如果没有参数，参数列表可以省略不写。</p>
<p>3 opt 选项， 不需要可以省略</p>
<ul>
<li>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li>
<li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li>
</ul>
<p>4 返回值类型</p>
<p>一般可以省略，编译器会根据return语句自动推导返回值类型</p>
<p>但需要注意的是<strong>labmda表达式不能通过列表初始化自动推导出返回值类型</strong>（因为可以推导为很多种类型）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;	<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数本质：lambda表达式在C++中会被看做是一个仿函数，可以使用std::function和std::bind来存储和操作lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure>

<h2 id="12、lock-guard和unique-lock"><a href="#12、lock-guard和unique-lock" class="headerlink" title="12、lock_guard和unique_lock"></a>12、lock_guard和unique_lock</h2><p>lock_guard：用于自动获取互斥锁，并在作用域结束时释放。可以防止忘记释放锁而导致的死锁或资源泄漏</p>
<p>特点：创建即加锁，作用域结束自动析构并解锁，无需手工解锁；不能中途解锁；不能复制 </p>
<p>（通过构造函数获取一个互斥锁，在析构函数中释放该锁）</p>
<p>unique_lock：比lock_guard更灵活，可以延迟获取锁（defer_lock标志），也可以在作用域内手动释放锁，避免锁的粒度太大</p>
<p>特点：可以随时加锁解锁；作用域同lock_guard，析构时自动释放锁；不可复制，可移动；可以与条件变量一起使用</p>
<h2 id="13、右值引用和移动语义"><a href="#13、右值引用和移动语义" class="headerlink" title="13、右值引用和移动语义"></a>13、右值引用和移动语义</h2><p>左值：可以放在等号左边，可以取地址，有名字</p>
<p>右值：不可以放在等号左边，不能取地址，没有名字</p>
<p>++i、–i是左值，i++、i–是右值</p>
<p>移动语义：将资源的所有权转移到另一个对象上，不需要拷贝操作，可以提高程序的性能和效率</p>
<p>移动语义通过使用右值引用和移动构造函数来实现</p>
<p>移动构造函数接受右值引用参数，并将资源从原对象窃取过来</p>
<p>典型应用场景：</p>
<p>1、容器动态调整大小：当容器需要增长或者缩小时，使用移动语义可以避免不必要的数据复制操作</p>
<p>2、对象的返回值优化：当函数返回一个局部对象时，编译器可以使用移动语义来避免拷贝构造函数，直接在调用者的栈空间中构造对象</p>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
  </entry>
  <entry>
    <title>基于跳表结构的KV存储引擎</title>
    <url>/2024/03/20/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84KV%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="基于跳表结构的KV存储引擎"><a href="#基于跳表结构的KV存储引擎" class="headerlink" title="基于跳表结构的KV存储引擎"></a>基于跳表结构的KV存储引擎</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>基于跳表结构的KV存储引擎是一个用于存储和检索键值对数据的高性能、高并发的数据存储引擎。跳表是一种类似于平衡树的数据结构，但更简单且容易实现，并具有良好的平均时间复杂度O（logn）。该项目采用c++语言设计了一个轻量级、可靠的键值存储解决方案，实现了插入数据、删除数据、查询数据、数据展示、生成持久化文件、恢复数据以及数据库大小显示等功能</p>
<p>本项目采用c++语言设计了一个轻量级的基于跳表的键值存储引擎，支持插入、删除、查询、展示、数据持久化和数据恢复等功能，支持多线程并发操作，在多线程随机读写的压力测试下，每秒可处理写请求数（QPS）: 24.39w，每秒可处理读请求数（QPS）: 18.41w</p>
<h2 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h2><p>1、基于跳表结构和面向对象的Node类、SkipList类的开发与封装，提供了简单易用的 API 接口</p>
<p>2、使用互斥锁等机制实现多线程并发访问的支持，防止并发插入数据时发生冲突，保证线程安全</p>
<p>3、 实现了将内存中的数据持久化到磁盘，并在系统重启后进行恢复的功能，确保数据的持久性和可靠性</p>
<h2 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h2><ul>
<li>insertElement(int,string) &#x2F;&#x2F; 插入数据</li>
<li>deleteElement(int) &#x2F;&#x2F; 删除数据</li>
<li>searchElement(int) &#x2F;&#x2F; 查询数据</li>
<li>displayList(int) &#x2F;&#x2F; 显示已存数据</li>
<li>dumpFile(string) &#x2F;&#x2F; 数据落盘</li>
<li>loadFile(string) &#x2F;&#x2F; 加载数据</li>
<li>size() &#x2F;&#x2F; 获取数据规模</li>
</ul>
<h2 id="跳表原理"><a href="#跳表原理" class="headerlink" title="跳表原理"></a>跳表原理</h2><p>跳表的本质是由原始链表经过筛选部分节点构建成的<strong>多级索引链表</strong></p>
<p>因此，跳表可视为多个层级的单链表组合而成</p>
<p><img src="D:\Blog\source_posts\基于跳表的KV存储引擎\20210830155358392.png" alt="img"></p>
<p>跳表中查找的时间复杂度是O(logn)</p>
<p>在上述跳表中，假如查询key&#x3D;12的记录，则可以从第二级索引开始快速定位：</p>
<ul>
<li>遍历第二级索引，从1开始，发现7&lt;12&lt;14，7就是该层要找的索引，通过它跳到下一级索引</li>
<li>遍历第一级索引，从7开始，发现11&lt;12&lt;14，9就是该层要找的索引，通过它跳到下一级索引</li>
<li>遍历原始链表，从11开始，发现12&#x3D;12，12就是该层要找的最终索引</li>
</ul>
<p>相比于直接遍历原始链表，多级索引的存在使跳表查询效率更快，总结：</p>
<p><strong>跳表的优点</strong>： 可以实现高效的插入、删除和查询 ，时间复杂度为O(logn).</p>
<p><strong>跳表的缺点</strong>：需要存储多级索引，增加了额外的存储空间</p>
<p><strong>跳表的用途</strong>：经典的以空间换时间的数据结构，常用于非关系数据库的存储引擎中</p>
<h2 id="跳表实现"><a href="#跳表实现" class="headerlink" title="跳表实现"></a>跳表实现</h2><p>项目整体上拥有一个 skiplist.h 文件</p>
<p>拥有两个核心类：Node 类、SkipList 类</p>
<p>Node 类是存储引擎中用于存放实际数据的类，而 SkipList 则对外提供了组织，访问，操作 Node 类的功能</p>
<h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Node</span>() &#123;&#125; </span><br><span class="line">	<span class="built_in">Node</span>(K k, V v, <span class="type">int</span>); </span><br><span class="line">	~<span class="built_in">Node</span>();</span><br><span class="line">	<span class="function">K <span class="title">get_key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">V <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(V)</span></span>;</span><br><span class="line">	Node&lt;K, V&gt; **forward;  </span><br><span class="line">	<span class="type">int</span> node_level;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Node 类需要包含两个主要私有属性：key 和 value，分别用于存储键和值</p>
<p>还需要一个 node_level 公共属性，用于标识节点在跳表中的层级位置</p>
<ul>
<li>当 node_level &#x3D; 1 时，表示当前的节点只会出现在跳表中的第 1 层</li>
<li>当 node_level &#x3D; 2 时，表示当前的节点会出现在跳表中的第 2 层和第 1 层</li>
<li>以此类推</li>
</ul>
<p>跳表搜索节点时的跳转机制有两方面：</p>
<ol>
<li>同一节点的多层跳转：在相同键值、不同层级节点之间的跳转（垂直）</li>
<li>不同节点的单层跳转：在相同层级、不同键值节点之间的跳转（水平）</li>
</ol>
<p>可以借鉴单链表中访问 next 指针的成员函数，来实现跳表内不同节点的单层跳转</p>
<p>采用数组结构来组织一个节点在不同层级的指针，通过变更数组下标，我们便能够实现同一节点在不同层级之间的跳转功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设一个节点在跳表中的层级为 3，那么这个节点的 forward 指针数组的大小为 3。其 forward[0] 指向该节点在第一层的下一个节点；forward[1] 指向该节点在第二层的下一个节点，forward[2] 指向该节点在第三层的下一个节点</span><br></pre></td></tr></table></figure>

<p>在定义完毕 Node 类关键的属性之后，还需要一些基本的问题需要处理。例如获取 &#x2F; 设置key 对应的 value、构造函数的实现、析构函数的实现等</p>
<p>Node类的代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(K k,V v,<span class="type">int</span> level);</span><br><span class="line">    ~<span class="built_in">Node</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">K <span class="title">get_key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(V val)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> node_level;</span><br><span class="line">    Node&lt;K,V&gt; **forwards;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line">Node&lt;K,V&gt; :: <span class="built_in">Node</span>(K k,V v,<span class="type">int</span> level):<span class="built_in">key</span>(k),<span class="built_in">value</span>(v),<span class="built_in">node_level</span>(level)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;forwards = <span class="keyword">new</span> Node&lt;K,V&gt; * [level+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;forwards,<span class="number">0</span>,<span class="built_in">sizeof</span>(Node&lt;K,V&gt;*) * (level+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line">Node&lt;K,V&gt; :: ~<span class="built_in">Node</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取键</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line">K Node&lt;K,V&gt; :: <span class="built_in">get_key</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line">V Node&lt;K,V&gt; :: <span class="built_in">get_value</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> Node&lt;K,V&gt; :: <span class="built_in">set_value</span>(V val)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;value = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SkipList类"><a href="#SkipList类" class="headerlink" title="SkipList类"></a>SkipList类</h3><p>SkipList 属性</p>
<ol>
<li>头节点：作为跳表中所有节点组织的入口点，类似于单链表</li>
<li>最大层数：跳表中允许的最大层数</li>
<li>当前层数：跳表当前的层数</li>
<li>节点数量：跳表当前的组织的所有节点总数</li>
<li>文件读写：跳表生成持久化文件和读取持久化文件的写入器和读取器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _max_level;              <span class="comment">// 跳表允许的最大层数</span></span><br><span class="line">    <span class="type">int</span> _skip_list_level;        <span class="comment">// 跳表当前的层数</span></span><br><span class="line">    Node&lt;K, V&gt; *_header;         <span class="comment">// 跳表的头节点</span></span><br><span class="line">    <span class="type">int</span> _element_count;          <span class="comment">// 跳表中组织的所有节点的数量</span></span><br><span class="line">    std::ofstream _file_writer;  <span class="comment">// 文件写入器</span></span><br><span class="line">    std::ifstream _file_reader;  <span class="comment">// 文件读取器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SkipList 成员函数</p>
<ol>
<li>节点创建：生成新的节点实例</li>
<li>层级分配：为每个新创建的节点分配一个合适的层数</li>
<li>节点插入：将节点加入到跳表中的适当位置</li>
<li>节点搜索：在跳表中查找特定的节点</li>
<li>节点删除：从跳表中移除指定的节点</li>
<li>节点展示：显示跳表中所有节点的信息</li>
<li>节点计数：获取跳表中当前的节点总数</li>
<li>数据持久化：将跳表的数据保存到磁盘中</li>
<li>数据加载：从磁盘加载持久化的数据到跳表中</li>
<li>垃圾回收：对于删除的节点，需要回收其内存空间</li>
<li>获取节点数量：获取跳表组织的节点个数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SkipList</span>(<span class="type">int</span>);                      <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">SkipList</span>();                        <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_random_level</span><span class="params">()</span></span>;             <span class="comment">// 获取节点的随机层级</span></span><br><span class="line">    <span class="function">Node&lt;K, V&gt; *<span class="title">create_node</span><span class="params">(K, V, <span class="type">int</span>)</span></span>; <span class="comment">// 节点创建</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert_element</span><span class="params">(K, V)</span></span>;           <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_list</span><span class="params">()</span></span>;                <span class="comment">// 展示节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search_element</span><span class="params">(K)</span></span>;             <span class="comment">// 搜索节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_element</span><span class="params">(K)</span></span>;             <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dump_file</span><span class="params">()</span></span>;                   <span class="comment">// 持久化数据到文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">load_file</span><span class="params">()</span></span>;                   <span class="comment">// 从文件加载数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(Node&lt;K, V&gt; *)</span></span>;           <span class="comment">// 递归删除节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;                         <span class="comment">// 跳表中的节点个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="get-random-level"><a href="#get-random-level" class="headerlink" title="get_random_level"></a>get_random_level</h4><p>跳表的层级选择：随机过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">int</span> SkipList&lt;K, V&gt;::<span class="built_in">get_random_level</span>() &#123;</span><br><span class="line">   <span class="comment">// 初始化层级：每个节点至少出现在第一层。</span></span><br><span class="line">   <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// 随机层级增加：使用 rand() % 2 实现抛硬币效果，决定是否升层。</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">rand</span>() % <span class="number">2</span>) &#123;</span><br><span class="line">      k++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 层级限制：确保节点层级不超过最大值 _max_level。</span></span><br><span class="line">   k = (k &lt; _max_level) ? k : _max_level;</span><br><span class="line">   <span class="comment">// 返回层级：返回确定的层级值，决定节点插入的层。</span></span><br><span class="line">   <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>采用随机过程的优点</p>
<ul>
<li>平衡性：随机层级分配自然保持跳表平衡，无需额外操作（如AVL或红黑树的旋转）</li>
<li>效率：随机分配层级保证节点在各层均匀分布，实现对数时间复杂度的查找、插入和删除</li>
<li>简单性：这种方法易于实现且效果显著，使跳表成为性能优异的简洁数据结构</li>
</ul>
<h4 id="search-element"><a href="#search-element" class="headerlink" title="search_element"></a>search_element</h4><p>搜索开始于跳表的顶层 _skip_list_level</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">bool</span> SkipList&lt;K, V&gt;::<span class="built_in">search_element</span>(K key) &#123;</span><br><span class="line">    <span class="comment">// 定义一个指针 current，初始化为跳表的头节点 _header</span></span><br><span class="line">    Node&lt;K, V&gt; *current = _header;</span><br><span class="line">    <span class="comment">// 从跳表的最高层开始搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = _skip_list_level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 遍历当前层级，直到下一个节点的键值大于或等于待查找的键值</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;forward[i] &amp;&amp; current-&gt;forward[i]-&gt;<span class="built_in">get_key</span>() &lt; key) &#123;</span><br><span class="line">            <span class="comment">// 移动到当前层的下一个节点</span></span><br><span class="line">            current = current-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点的下一个节点的键值大于待查找的键值时，进行下沉到下一层</span></span><br><span class="line">        <span class="comment">// 下沉操作通过循环的 i-- 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查当前层（最底层）的下一个节点的键值是否为待查找的键值</span></span><br><span class="line">    current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (current &amp;&amp; current-&gt;<span class="built_in">get_key</span>() == key) &#123;</span><br><span class="line">        <span class="comment">// 如果找到匹配的键值，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到匹配的键值，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="insert-element"><a href="#insert-element" class="headerlink" title="insert_element"></a>insert_element</h4><p>跳表的插入负责构建整个跳表，是跳表中最难的部分</p>
<p>插入过程主要涉及三个关键步骤：</p>
<p><strong>1、确定节点层级</strong></p>
<p>首先，我们需要为新插入的节点随机确定其所在的层级</p>
<p><strong>2、寻找插入位置</strong></p>
<p>通过之前讨论的搜索方法，我们能够定位到了新节点应当插入的具体位置</p>
<p><strong>3、更新指针关系</strong></p>
<p>最关键的步骤是在插入节点时更新各层的指针关系</p>
<p><img src="D:\Blog\source_posts\基于跳表的KV存储引擎\跳表的插入原理.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">int</span> SkipList&lt;K, V&gt;::<span class="built_in">insert_element</span>(<span class="type">const</span> K key, <span class="type">const</span> V value) &#123;</span><br><span class="line">        Node&lt;K, V&gt; *current = <span class="keyword">this</span>-&gt;_header;</span><br><span class="line">    <span class="comment">// 用于在各层更新指针的数组</span></span><br><span class="line">    Node&lt;K, V&gt; *update[_max_level + <span class="number">1</span>];  <span class="comment">// 用于记录每层中待更新指针的节点</span></span><br><span class="line">    <span class="built_in">memset</span>(update, <span class="number">0</span>, <span class="built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最高层向下搜索插入位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = _skip_list_level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 寻找当前层中最接近且小于 key 的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;forward[i] != <span class="literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="built_in">get_key</span>() &lt; key) &#123;</span><br><span class="line">            current = current-&gt;forward[i]; <span class="comment">// 移动到下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存每层中该节点，以便后续插入时更新指针</span></span><br><span class="line">        update[i] = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到最底层的下一节点，准备插入操作</span></span><br><span class="line">    current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 检查待插入的键是否已存在</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;<span class="built_in">get_key</span>() == key) &#123;</span><br><span class="line">        <span class="comment">// 键已存在，取消插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查待插入的键是否已存在于跳表中</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span> || current-&gt;<span class="built_in">get_key</span>() != key) &#123;</span><br><span class="line">        <span class="comment">// 通过随机函数决定新节点的层级高度</span></span><br><span class="line">        <span class="type">int</span> random_level = <span class="built_in">get_random_level</span>();</span><br><span class="line">        <span class="comment">// 如果新节点的层级超出了跳表的当前最高层级</span></span><br><span class="line">        <span class="keyword">if</span> (random_level &gt; _skip_list_level) &#123;</span><br><span class="line">            <span class="comment">// 对所有新的更高层级，将头节点设置为它们的前驱节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = _skip_list_level + <span class="number">1</span>; i &lt;= random_level; i++) &#123;</span><br><span class="line">                update[i] = _header;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新跳表的当前最高层级为新节点的层级</span></span><br><span class="line">            _skip_list_level = random_level;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node&lt;K, V&gt; *inserted_node = <span class="built_in">create_node</span>(key, value, random_level);</span><br><span class="line">        <span class="comment">// 在各层插入新节点，同时更新前驱节点的 forward 指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= random_level; i++) &#123;</span><br><span class="line">            <span class="comment">// 新节点指向当前节点的下一个节点</span></span><br><span class="line">            inserted_node-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">            <span class="comment">// 当前节点的下一个节点更新为新节点</span></span><br><span class="line">            update[i]-&gt;forward[i] = inserted_node;</span><br><span class="line">        &#125;</span><br><span class="line">        _element_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-element"><a href="#delete-element" class="headerlink" title="delete_element()"></a>delete_element()</h4><p>关键步骤：</p>
<ol>
<li>定位待删除节点：通过搜索确定需要删除的节点位置</li>
<li>更新指针关系：调整相关节点的指针，以从跳表中移除目标节点</li>
<li>内存回收：释放被删除节点所占用的资源</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;K, V&gt;::<span class="built_in">delete_element</span>(K key) &#123;</span><br><span class="line">    Node&lt;K, V&gt; *current = <span class="keyword">this</span>-&gt;_header;</span><br><span class="line">    Node&lt;K, V&gt; *update[_max_level + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(update, <span class="number">0</span>, <span class="built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最高层开始向下搜索待删除节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = _skip_list_level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;forward[i] != <span class="literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="built_in">get_key</span>() &lt; key) &#123;</span><br><span class="line">            current = current-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = current; <span class="comment">// 记录每层待删除节点的前驱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 确认找到了待删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;<span class="built_in">get_key</span>() == key) &#123;</span><br><span class="line">        <span class="comment">// 逐层更新指针，移除节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= _skip_list_level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;forward[i] != current) <span class="keyword">break</span>;</span><br><span class="line">            update[i]-&gt;forward[i] = current-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调整跳表的层级</span></span><br><span class="line">        <span class="keyword">while</span> (_skip_list_level &gt; <span class="number">0</span> &amp;&amp; _header-&gt;forward[_skip_list_level] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _skip_list_level--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> current; <span class="comment">// 释放节点占用的内存</span></span><br><span class="line">        _element_count--; <span class="comment">// 节点计数减一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><h4 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h4><p>上述对数据的插入、搜索和删除等操作都是在内存中进行的，一旦程序终止，当前所有的操作都会失效，数据就会丢失，因此，需要实现数据的持久化存储</p>
<p>考虑到键值对数据结构的特点，我们选择将数据保存到文件中，采用 key:value 格式进行存储，每行存储一个键值对。这种格式既简单又易于解析，适合快速的数据存取</p>
<p>在 C++ 中，我们利用 std::ofstream 来打开文件、写入数据，并在数据写入完成后关闭文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;K, V&gt;::<span class="built_in">dump_file</span>() &#123;</span><br><span class="line">    _file_writer.<span class="built_in">open</span>(STORE_FILE); <span class="comment">// 打开文件</span></span><br><span class="line">    Node&lt;K, V&gt;* node = <span class="keyword">this</span>-&gt;_header-&gt;forward[<span class="number">0</span>]; <span class="comment">// 从头节点开始遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _file_writer &lt;&lt; node-&gt;<span class="built_in">get_key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; node-&gt;<span class="built_in">get_value</span>() &lt;&lt; <span class="string">&quot;;\n&quot;</span>; <span class="comment">// 写入键值对</span></span><br><span class="line">        node = node-&gt;forward[<span class="number">0</span>]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _file_writer.<span class="built_in">flush</span>(); <span class="comment">// 刷新缓冲区，确保数据完全写入</span></span><br><span class="line">    _file_writer.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>数据的读取面临两个挑战：一是如何将文件中的key:value字符串解析为键值对；二是如何将读取的数据插入到内存中的跳表并建立索引</p>
<p>首先需要一个工具函数，检验字符串的合法性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">bool</span> SkipList&lt;K, V&gt;::<span class="built_in">is_valid_string</span>(<span class="type">const</span> std::string&amp; str) &#123;</span><br><span class="line">    <span class="keyword">return</span> !str.<span class="built_in">empty</span>() &amp;&amp; str.<span class="built_in">find</span>(delimiter) != std::string::npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于合法的字符串，将其分割为键和值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;K, V&gt;::<span class="built_in">get_key_value_from_string</span>(<span class="type">const</span> std::string &amp;str, std::string *key, std::string *value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_valid_string</span>(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *key = str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(delimiter));</span><br><span class="line">    *value = str.<span class="built_in">substr</span>(str.<span class="built_in">find</span>(delimiter) + <span class="number">1</span>, str.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将数据恢复到跳表结构中，并建立必要的索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;K, V&gt;::<span class="built_in">load_file</span>() &#123;</span><br><span class="line">    _file_reader.<span class="built_in">open</span>(STORE_FILE);</span><br><span class="line">    std::string line;</span><br><span class="line">    std::string *key = <span class="keyword">new</span> std::<span class="built_in">string</span>();</span><br><span class="line">    std::string *value = <span class="keyword">new</span> std::<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(_file_reader, line)) &#123;</span><br><span class="line">        <span class="built_in">get_key_value_from_string</span>(line, key, value);</span><br><span class="line">        <span class="keyword">if</span> (key-&gt;<span class="built_in">empty</span>() || value-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Define key as int type</span></span><br><span class="line">        <span class="built_in">insert_element</span>(<span class="built_in">stoi</span>(*key), *value);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; *key &lt;&lt; <span class="string">&quot;value:&quot;</span> &lt;&lt; *value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> key;</span><br><span class="line">    <span class="keyword">delete</span> value;</span><br><span class="line">    _file_reader.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程并发访问"><a href="#多线程并发访问" class="headerlink" title="多线程并发访问"></a>多线程并发访问</h2><p>在跳表插入和删除数据的过程中，在多线程的情况下，可能会出现数据不一致的问题等</p>
<ul>
<li>对插入节点成员函数和删除节点成员函数进行加锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有在插入和删除的时候，才会进行加锁</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">int</span> SkipList&lt;K, V&gt;::<span class="built_in">insert_element</span>(<span class="type">const</span> K key, <span class="type">const</span> V value) &#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();  <span class="comment">// 在函数第一句加锁</span></span><br><span class="line">    <span class="comment">// ... 算法过程（省略）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;<span class="built_in">get_key</span>() == key) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 在算法流程中有一个验证 key 是否存在的过程</span></span><br><span class="line">        <span class="comment">// 在此处需要提前 return，所以提前解锁</span></span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();  <span class="comment">// 函数执行完毕后解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;K, V&gt;::<span class="built_in">delete_element</span>(K key) &#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// ... 算法过程（省略）</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();  <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>为了验证该存储引擎的性能，开发了一个压力测试程序，主要包括两部分：多线程插入操作和多线程检索操作</p>
<p>多线程检索操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cppCopy codevoid *<span class="title">getElement</span><span class="params">(<span class="type">void</span>* threadid)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> tid; <span class="comment">// 线程ID</span></span><br><span class="line">    tid = (<span class="type">long</span>)threadid; <span class="comment">// 将void*类型的线程ID转换为long型</span></span><br><span class="line">    std::cout &lt;&lt; tid &lt;&lt; std::endl; <span class="comment">// 输出线程ID</span></span><br><span class="line">    <span class="type">int</span> tmp = TEST_COUNT/NUM_THREADS; <span class="comment">// 计算每个线程应该检索的元素数量</span></span><br><span class="line">    <span class="comment">// 循环检索元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=tid*tmp, count=<span class="number">0</span>; count&lt;tmp; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        skipList.<span class="built_in">search_element</span>(<span class="built_in">rand</span>() % TEST_COUNT); <span class="comment">// 随机生成一个键，并尝试从跳表中检索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); <span class="comment">// 退出线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程插入操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cppCopy codevoid *<span class="title">insertElement</span><span class="params">(<span class="type">void</span>* threadid)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> tid; <span class="comment">// 线程ID</span></span><br><span class="line">    tid = (<span class="type">long</span>)threadid; <span class="comment">// 将void*类型的线程ID转换为long型</span></span><br><span class="line">    std::cout &lt;&lt; tid &lt;&lt; std::endl; <span class="comment">// 输出线程ID</span></span><br><span class="line">    <span class="type">int</span> tmp = TEST_COUNT/NUM_THREADS; <span class="comment">// 计算每个线程应该插入的元素数量</span></span><br><span class="line">    <span class="comment">// 循环插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=tid*tmp, count=<span class="number">0</span>; count&lt;tmp; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        skipList.<span class="built_in">insert_element</span>(<span class="built_in">rand</span>() % TEST_COUNT, <span class="string">&quot;a&quot;</span>); <span class="comment">// 随机生成一个键，并插入带有&quot;a&quot;的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); <span class="comment">// 退出线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数负责初始化随机数生成器，并依次创建并管理插入操作的线程和检索操作的线程。</p>
<p>在创建线程后，主函数开始计时，等待所有线程完成操作，并计算整个过程的耗时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span> (<span class="built_in">time</span>(<span class="literal">NULL</span>));  </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">        <span class="type">int</span> rc;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; NUM_THREADS; i++ ) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, insertElement, (<span class="type">void</span> *)i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *ret;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; NUM_THREADS; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pthread_join</span>(threads[i], &amp;ret) !=<span class="number">0</span> )  &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;pthread_create() error&quot;</span>); </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> finish = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); </span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; elapsed = finish - start;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;insert elapsed:&quot;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入操作</p>
<p>跳表树高：18</p>
<p>采用随机插入数据测试：</p>
<table>
<thead>
<tr>
<th>插入数据规模（万条）</th>
<th>耗时（秒）</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>0.316763</td>
</tr>
<tr>
<td>50</td>
<td>1.86778</td>
</tr>
<tr>
<td>100</td>
<td>4.10648</td>
</tr>
</tbody></table>
<p>每秒可处理写请求数（QPS）: 24.39w</p>
<p>取数据操作</p>
<table>
<thead>
<tr>
<th>取数据规模（万条）</th>
<th>耗时（秒）</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>0.47148</td>
</tr>
<tr>
<td>50</td>
<td>2.56373</td>
</tr>
<tr>
<td>100</td>
<td>5.43204</td>
</tr>
</tbody></table>
<p>每秒可处理读请求数（QPS）: 18.41w</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>该项目适用于需要高效存储和检索键值对数据的应用场景，例如缓存系统、简单数据库、搜索引擎等。由于具有高并发性能和可靠的数据持久化功能，可以满足各种对数据存储和检索效率要求较高的场景需求</p>
<p>非关系型数据库redis，以及levedb，rockdb其核心存储引擎的数据结构就是跳表</p>
<p>加上一致性协议，例如raft就构成了分布式存储，再启动一个http server就可以对外提供分布式存储服务</p>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
  </entry>
  <entry>
    <title>序列化和反序列化</title>
    <url>/2024/03/19/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>序列化（Serialization）和反序列化（Deserialization）是指将对象转换为字节流或其他格式的数据，以便于存储、传输或持久化，并在需要时将这些数据重新转换回对象的过程。</p>
<ol>
<li><strong>序列化：</strong> 序列化是指将对象的状态转换为字节流或其他格式的数据的过程。在序列化过程中，对象的各种属性和状态被编码为字节流，以便于存储或传输。序列化后的数据可以保存到文件中、发送到网络上，或者以其他方式进行持久化。</li>
<li><strong>反序列化：</strong> 反序列化是指将序列化后的字节流或其他格式的数据重新转换为对象的状态的过程。在反序列化过程中，字节流被解码，并根据编码的规则恢复对象的属性和状态，使得对象能够重新被程序所使用。</li>
</ol>
<p>序列化和反序列化通常用于以下情况：</p>
<ul>
<li><strong>网络通信：</strong> 在网络通信中，对象的状态需要在不同的计算机之间进行传输，因此需要将对象序列化为字节流进行传输，然后在接收端进行反序列化。</li>
<li><strong>数据持久化：</strong> 在将对象保存到数据库或文件中时，需要将对象序列化为数据格式，以便于持久化存储。反序列化则用于从数据库或文件中读取数据，并将其转换回对象。</li>
<li><strong>进程间通信：</strong> 在多进程或分布式系统中，不同进程之间需要共享数据，因此需要将对象序列化为字节流进行进程间通信。</li>
</ul>
<p>在C++中，可以使用各种技术来进行序列化和反序列化，包括手动编写序列化和反序列化代码、使用C++标准库中的iostream或fstream进行读写、以及使用第三方库如Boost.Serialization等。</p>
<p>下面通过一个简单的示例来说明序列化和反序列化的概念。</p>
<p>假设我们有一个名为<code>Person</code>的类，表示一个人的基本信息，包括姓名和年龄，我们将实现该类的序列化和反序列化功能，以便于将 <code>Person</code> 对象保存到文件中并从文件中重新加载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(filename, std::ios::binary)</span></span>;</span><br><span class="line">        ofs.<span class="built_in">write</span>(name.<span class="built_in">c_str</span>(), name.<span class="built_in">size</span>() + <span class="number">1</span>); <span class="comment">// 写入姓名</span></span><br><span class="line">        ofs.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;age), <span class="built_in">sizeof</span>(age)); <span class="comment">// 写入年龄</span></span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deserialize</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(filename, std::ios::binary)</span></span>;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        ifs.<span class="built_in">read</span>(buffer, <span class="number">256</span>); <span class="comment">// 读取姓名</span></span><br><span class="line">        name = buffer;</span><br><span class="line">        ifs.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;age), <span class="built_in">sizeof</span>(age)); <span class="comment">// 读取年龄</span></span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象序列化到文件中</span></span><br><span class="line">    person.<span class="built_in">serialize</span>(<span class="string">&quot;person.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的 Person 对象</span></span><br><span class="line">    <span class="function">Person <span class="title">newPerson</span><span class="params">(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中反序列化对象</span></span><br><span class="line">    newPerson.<span class="built_in">deserialize</span>(<span class="string">&quot;person.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示反序列化后的对象信息</span></span><br><span class="line">    newPerson.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先定义了一个名为 <code>Person</code> 的类，它包含了姓名和年龄两个成员变量。然后实现了 <code>serialize</code> 和 <code>deserialize</code> 方法，分别用于将 <code>Person</code> 对象序列化为字节流并保存到文件中，以及从文件中读取字节流并反序列化为 <code>Person</code> 对象。最后，在 <code>main</code> 函数中，我们创建了一个 <code>Person</code> 对象并进行了序列化，然后创建了一个新的 <code>Person</code> 对象并进行了反序列化，最终输出了反序列化后的对象信息</p>
]]></content>
      <categories>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2024/02/11/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="D:\Blog\source_posts\算法\image-20240315182824213.png" alt="image-20240315182824213"></p>
<p>思路：先排序（按每组第一个数，从小到大）</p>
<p>如果前一个的右区间比后一个的左区间大，说明两者有重叠，进行合并</p>
<p>合并方式：左区间取最小，右区间取最大</p>
<p>合并完将后一组元素变成合并后的区间，再与后面的比较是否还能合并</p>
<p>注：最后一个区间需要单独加到结果集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &gt;= intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                intervals[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>( intervals[i][<span class="number">0</span>],intervals[i+<span class="number">1</span>][<span class="number">0</span>] );</span><br><span class="line">                intervals[i+<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>( intervals[i][<span class="number">1</span>],intervals[i+<span class="number">1</span>][<span class="number">1</span>] );</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(intervals[intervals.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="和为k的子数组"><a href="#和为k的子数组" class="headerlink" title="和为k的子数组"></a>和为k的子数组</h2><p><img src="D:\Blog\source_posts\算法\image-20240315143017862.png" alt="image-20240315143017862"></p>
<p>思路：遍历，每次新元素出现，sum +&#x3D; 新元素，哈希表记录每个sum，并统计次数，如果 sum-target 能在哈希表中找到，说明有符合要求的子数组，count记录</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hp;  <span class="comment">// 记录前面每个子数组之和</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre_sum=<span class="number">0</span>;  </span><br><span class="line">        hp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 初始：和为0的情况有一次</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            pre_sum += nums[i];  <span class="comment">// 当前最新子数组之和</span></span><br><span class="line">            <span class="keyword">if</span>(hp.<span class="built_in">count</span>(pre_sum-k))&#123;   <span class="comment">// pre_sum + 之前某个子数组的和 == k</span></span><br><span class="line">                count += hp[pre_sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            hp[pre_sum]++;  <span class="comment">// 记录当前最新字数组之和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>思路1：先计算出两个链表的长度，然后让两者从同一起点开始遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA=headA;</span><br><span class="line">        ListNode* curB=headB;</span><br><span class="line">        <span class="type">int</span> len_a=<span class="number">0</span>,len_b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curA)&#123;</span><br><span class="line">            len_a++;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curB)&#123;</span><br><span class="line">            len_b++;</span><br><span class="line">            curB=curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="keyword">if</span>(len_a &gt; len_b)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len_a-len_b;++i)&#123;</span><br><span class="line">                curA=curA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len_b-len_a;++i)&#123;</span><br><span class="line">                curB=curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curA &amp;&amp; curB)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">            curB=curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路2：双指针，指针curA先遍历链表A，再遍历链表B，指针curB先遍历链表B，再遍历链表A</p>
<p>链表A长度为a，链表B长度为b，二者公共结点长度为c</p>
<p>curA和curB相遇时</p>
<p>​	curA走过的路程：  a + （b -c)</p>
<p>​	curB走过的路程： b + （a-c ）     </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        ListNode *A = headA, *B = headB;</span><br><span class="line">        while (A != B) &#123;</span><br><span class="line">            A = A != nullptr ? A-&gt;next : headB;</span><br><span class="line">            B = B != nullptr ? B-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>思路：哈希表</p>
<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p><img src="D:\Blog\source_posts\算法\image-20240322112351360.png" alt="image-20240322112351360"></p>
<p>思路：两个链表按 “个 十 百 …”存放，可以直接从第一个结点依次相加</p>
<p>注意 有进位时记录即可，在下一个结点加上</p>
<p>每次需要创建新的结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* cur=dummyhead;</span><br><span class="line">        <span class="type">int</span> curnum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 !=<span class="literal">nullptr</span> || l2 !=<span class="literal">nullptr</span>)&#123;  <span class="comment">// 逐对结点相加，有进位时记录，在后一对加上</span></span><br><span class="line">            <span class="type">int</span> curnum1= l1 !=<span class="literal">nullptr</span> ? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> curnum2= l2 !=<span class="literal">nullptr</span> ? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            curnum = curnum1+curnum2+carry;</span><br><span class="line"></span><br><span class="line">            carry = curnum / <span class="number">10</span>;</span><br><span class="line">            curnum = curnum % <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            ListNode* node= <span class="keyword">new</span> <span class="built_in">ListNode</span>(curnum);</span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ListNode* newnode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">            cur-&gt;next=newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p><img src="D:\Blog\source_posts\算法\image-20240326225005406.png" alt="image-20240326225005406"></p>
<p>思路：归并排序+合并有序链表</p>
<p>递归将链表拆分，把拆分后的链表分别排序，最后再合并</p>
<p>1、快慢指针：快指针走两步，慢指针走一步，当快指针走到末尾，慢指针恰好走到中间</p>
<p>2、合并两个有序链表：依次比较大小，每次取较小节点，并后移该链表指针</p>
<p>注意点：对上述过程递归，merge参数为两个拆分的链表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        return sortList(head,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* head,ListNode* tail)&#123;</span><br><span class="line">        if(head == nullptr) return head;</span><br><span class="line">        if (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = nullptr;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head; </span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        while(fast != tail)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if(fast != tail)&#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        return merge(sortList(head,mid),sortList(mid,tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1,ListNode* head2)&#123;</span><br><span class="line">        ListNode* dummyhead = new ListNode(0);</span><br><span class="line">        ListNode* prev = dummyhead;</span><br><span class="line">        ListNode* cur1=head1;</span><br><span class="line">        ListNode* cur2=head2;</span><br><span class="line">        while(cur1 != nullptr &amp;&amp; cur2 != nullptr)&#123;</span><br><span class="line">            if(cur1-&gt;val &gt; cur2-&gt;val)&#123;</span><br><span class="line">                prev-&gt;next = cur2;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                prev-&gt;next = cur1;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur1 != nullptr)&#123;</span><br><span class="line">            prev-&gt;next = cur1;</span><br><span class="line">        &#125;else if(cur2 !=nullptr)&#123;</span><br><span class="line">            prev-&gt;next = cur2;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = dummyhead-&gt;next;</span><br><span class="line">        delete dummyhead;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void back(treeNode* cur,vector&lt;int&gt; &amp;vec)&#123;</span><br><span class="line">	if(cur==NULL) return;</span><br><span class="line">	vec.push_back(cur-&gt;val);  // 中</span><br><span class="line">	back(vec-&gt;left,vec); // 左</span><br><span class="line">	back(vec-&gt;right,vec); // 右</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><p>解法：<strong>栈stack</strong></p>
<p>统一写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">treeorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	stack&lt;TreeNode*&gt; stk;</span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="literal">NULL</span>) stk.<span class="built_in">push</span>(root); <span class="comment">// 从根节点开始访问</span></span><br><span class="line">	<span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		TreeNode * cur=stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur = stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//前序遍历，入栈顺序：右左中-&gt;出栈顺序：中左右</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) stk.<span class="built_in">push</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) stk.<span class="built_in">push</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">            stk.<span class="built_in">push</span>(cur); <span class="comment">// 中</span></span><br><span class="line">            stk.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 标记中结点</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯法都可以抽象为N叉树</p>
<p>模版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例: 输入: n &#x3D; 4, k &#x3D; 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</p>
<p>本质：二叉搜索树</p>
<p><img src="D:\Blog\source_posts\算法\image-20240212002404360.png" alt="image-20240212002404360"></p>
<p>每次从集合中选取一个元素，集合大小随之收缩</p>
<p>​	n相当于树的宽度，也就是for循环几次</p>
<p>​	k相当于树的深度，也就是递归几次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//递归函数的返回值和参数</span></span><br><span class="line">	std::vector&lt; std::vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">backtracing</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//终止条件</span></span><br><span class="line">		<span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123; <span class="comment">//如果path中的元素数量为k，说明获取到一个结果</span></span><br><span class="line">			res.<span class="built_in">push_back</span>(path);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//单层搜索</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">			path.<span class="built_in">push_back</span>(i);<span class="comment">//选取一个元素</span></span><br><span class="line">			<span class="built_in">backtracing</span>(n, k, i + <span class="number">1</span>);<span class="comment">//排除选取的元素，并递归选取剩下的元素</span></span><br><span class="line">			<span class="comment">//回溯</span></span><br><span class="line">			path.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)&#123;</span><br><span class="line">		<span class="built_in">backtracing</span>(n, k, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剪枝优化：</p>
<p>如果for循环起始位置后面的元素个数，已经不够选择了，就没必要继续搜索了</p>
<ul>
<li>已经选择的元素个数：path.size()</li>
<li>还需要选择的元素个数：k-path.size()</li>
<li>如果剩余元素个数小于k-path.size()，就剪枝<ul>
<li>当遍历到n-（k-path.size())+1时</li>
</ul>
</li>
</ul>
<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    std::vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracing</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum +=i;</span><br><span class="line">            <span class="built_in">backtracing</span>(k,n,i+<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//回溯</span></span><br><span class="line">            sum-=i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracing</span>(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//数字和字母映射关系--二维数组</span></span><br><span class="line">    <span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> std::string &amp;digits,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">length</span>()==digits.<span class="built_in">length</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> digit=digits[index]-<span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 字符串转数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:letterMap[digit])&#123; </span><br><span class="line">            path.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="built_in">backtracking</span>(digits,index+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>本题与前面的组合总和的解法思路类似，采用回溯算法</p>
<p>组合问题都可以用树形结构抽象出选取元素的流程，方便理解</p>
<p><strong>本题难点在于如何去重（组合里可以有重复元素，但不能有重复的组合）</strong></p>
<p>其实就是使用过的元素不能重复选取</p>
<p>元素重复选取在树形结构上体现在两个维度：树枝（竖直）和树层（水平）</p>
<p><strong>元素在同一组合内可以重复：代表递归时元素可以重复（树枝可以重复）</strong></p>
<p><strong>两个组合不能重复：代表for循环时选的元素每次都不能重复（树层不能重复）</strong></p>
<p><img src="D:\Blog\source_posts\算法\image-20240227224547019.png" alt="image-20240227224547019"></p>
<p>如何判断元素重复？</p>
<p>创建一个bool型的数组used，其中每一个元素都对应着candidates中的一个元素，true代表此元素被使用，false代表此元素未被使用</p>
<p>先对candidates进行排序（<strong>树层去重的话，需要对数组排序！</strong>）</p>
<p>如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：重复元素不在同一树枝上，而是前一个树枝使用了candidates[i - 1]，也就是说同一树层已使用过candidates[i - 1] </p>
<p>如果<code>candidates[i] == candidates[i - 1]</code> 并且<code>used[i - 1] == true</code>，说明此时重复元素是在同一个树枝上，也就是同一树枝上candidates[i - 1]被使用过</p>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>组合问题是选位置不同的数，分割问题是选位置不同的缝插进去，本质是一样的</p>
<p><img src="D:\Blog\source_posts\算法\image-20240228230457954.png" alt="image-20240228230457954"></p>
<p>切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法</p>
<p>切割过的地方不能重复切割，需要startIndex</p>
<p><strong>在递归循环中如何截取子串呢？</strong></p>
<p>[startIndex, i] 就是要截取的子串</p>
<p>startindex是上一次切割线的位置，i是当前切割线的位置</p>
<p>需要切割的长度就是:  i-startindex+1</p>
<p>1代表截取的最小长度，i-startIndex代表又增加截取了几个字符</p>
<p>（纵向递归一开始都是i&#x3D;startIndex，横向for循环时i++）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i)) &#123; <span class="comment">// 是回文子串</span></span><br><span class="line">        <span class="comment">// 获取[startIndex,i]在s中的子串</span></span><br><span class="line">        string str = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 如果不是则直接跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 寻找i+1为起始位置的子串</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯过程，弹出本次已经添加的子串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何判断回文串？</strong></p>
<p>双指针法：前后对比</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p><img src="D:\Blog\source_posts\算法\image-20240229214406029.png" alt="image-20240229214406029"></p>
<p>与分割回文串类似，也可看作切割问题</p>
<p><strong>思路：</strong></p>
<p>1 终止条件：</p>
<p>​	最多切割三次，切割可以看作加 “.” ，设一个变量n记录切割次数</p>
<p>2 递归逻辑：</p>
<p>​	每次分割就是直接在s上加”.” ，回溯时删除”.”</p>
<p>​	在哪里加？在i后面加，也就是i+1的位置（回文串分割也是在i后面插入分隔符）</p>
<p>​	每层递归需要n++，回溯时n–</p>
<p>3 判断是否合法：</p>
<p>​	首先明确判断哪一串字符：从start到i之间的字符，也就是上一次分割点和这一	次分割点之间的字符</p>
<p>​	剩下第四段需要单独判断，可以在终止条件里去判断</p>
<p>​	主要考虑到如下三点：</p>
<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
</ul>
<p><strong>语法技巧总结：</strong></p>
<p>string类型的字符串</p>
<p>1 插入和删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//在s的第i个字符后插入一个字符</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>);  <span class="comment">// 在i的后面插入一个逗点</span></span><br><span class="line"> <span class="comment">//将s的第i个字符后的一个字符删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);         <span class="comment">// 回溯删掉逗点</span></span><br></pre></td></tr></table></figure>

<p>2 判断某个字符是否为数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] &gt; <span class="string">&#x27;9&#x27;</span> || s[i] &lt; <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>3 将一串数字字符转为整型数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">0</span>；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()i++)&#123;</span><br><span class="line">    num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p><img src="D:\Blog\source_posts\算法\image-20240302201027483.png" alt="image-20240302201027483"></p>
<p><strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong></p>
<p><img src="D:\Blog\source_posts\算法\image-20240302201159314.png" alt="image-20240302201159314"></p>
<h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p><img src="D:\Blog\source_posts\算法\image-20240302205517799.png" alt="image-20240302205517799"></p>
<p><img src="D:\Blog\source_posts\算法\image-20240302205501843.png" alt="image-20240302205501843"></p>
<h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p><img src="D:\Blog\source_posts\算法\image-20240303145416632.png" alt="image-20240303145416632"></p>
<p>去重：重复元素不一定相邻（没有排序），不能用used数组去重</p>
<p>利用set的特性，将已使用元素添加到set中自动去重</p>
<p>在每次递归开始时重新定义一个新的set来记录该层（保证同层不重复即可）</p>
<p><img src="D:\Blog\source_posts\算法\image-20240303145536483.png" alt="image-20240303145536483"></p>
<p><strong>同一父节点下的同层上使用过的元素就不能再使用了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;int&gt; uset;</span><br></pre></td></tr></table></figure>

<p><strong>记录本层元素是否重复使用，新的一层uset都会重新定义（清空），uset只负责本层</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; uset; <span class="comment">// 使用set来对本层元素进行去重</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>())</span><br><span class="line">            || uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uset.<span class="built_in">insert</span>(nums[i]); <span class="comment">// 记录这个元素在本层用过了，本层后面不能再用了</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><img src="D:\Blog\source_posts\算法\image-20240303150222838.png" alt="image-20240303150222838"></p>
<p><img src="D:\Blog\source_posts\算法\image-20240303150243406.png" alt="image-20240303150243406"></p>
<p>去重：用used数组，当used[i]&#x3D;&#x3D;true时，说明该元素已使用过</p>
<p>不需要从start开始遍历，因为排列与组合不同，每次都要从0开始，去重即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p><img src="D:\Blog\source_posts\算法\image-20240303152304641.png" alt="image-20240303152304641"></p>
<p>与全排列不同的就是需要多去一次重，类似【组合总和III】的方式</p>
<p>如果 nums[i] &#x3D;&#x3D; nums[i-1]  &amp;&amp;  used[i-1] &#x3D;&#x3D; false，说明同层重复选取，去除；</p>
<p>如果 nums[i] &#x3D;&#x3D; nums[i-1]  &amp;&amp;  used[i-1] &#x3D;&#x3D; true，说明同树枝重复选取，保留</p>
<p><img src="D:\Blog\source_posts\算法\image-20240303152701205.png" alt="image-20240303152701205"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>) || used[i] ==<span class="literal">true</span> )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素</span></span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><p><img src="D:\Blog\source_posts\算法\image-20240228085827075.png" alt="image-20240228085827075"></p>
<p><img src="D:\Blog\source_posts\算法\image-20240228085847400.png" alt="image-20240228085847400"></p>
<p>利用递归，依次比较字符串的最长公共前缀（前面获取的最长公共前缀与后一个字符比较）</p>
<p>递归函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">lcp</span><span class="params">(string &amp; str1,string&amp; str2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len= <span class="built_in">min</span>(str1.<span class="built_in">size</span>(),str2.<span class="built_in">size</span>()); <span class="comment">// 获取较短字符串长度</span></span><br><span class="line">	<span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( index&lt;len &amp;&amp; str1[index]==str2[index])&#123;</span><br><span class="line">		++index;  <span class="comment">// 依次比较对应位置字符是否相同</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>,index);  <span class="comment">// 返回最长公共前缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><img src="D:\Blog\source_posts\算法\image-20240304103910494.png" alt="image-20240304103910494"></p>
<p>从最大的尺寸开始分配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ind = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=g.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ind &gt;=<span class="number">0</span> &amp;&amp;  g[i] &lt;= s[ind])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                ind--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="D:\Blog\source_posts\算法\image-20240304111931057.png" alt="image-20240304111931057"></p>
<h3 id="思路1：贪心"><a href="#思路1：贪心" class="headerlink" title="思路1：贪心"></a>思路1：贪心</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png" alt="376.摆动序列"></p>
<p>局部最优：每个峰值拐点代表一次摆动</p>
<p>全局最优：单调递增或递减之间的点不计入，记录整个序列的峰值拐点</p>
<p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong></p>
<p>如何确定峰值拐点？</p>
<p>比较两次差值是否一正一负</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prediff = nums[i]-nums[i-1]    // 当前的数-上一个数</span><br><span class="line"></span><br><span class="line">curdiff = nums[i+1] - nums[i]   // 下一个数 - 当前的数</span><br></pre></td></tr></table></figure>

<p>如果  <code> (prediff &gt;0 &amp;&amp; curdiff &lt;0)  || (prediff &lt;0 &amp;&amp;curdiff&gt;0)</code>说明nums[ i ]是峰值拐点，count++</p>
<p>本题要考虑三种特殊情况：</p>
<ol>
<li>情况一：上下坡中有平坡</li>
<li>情况二：数组首尾两端</li>
<li>情况三：单调坡中有平坡</li>
</ol>
<p><strong>情况一：上下坡中有平坡</strong></p>
<p>（相邻元素数值相等）</p>
<p><img src="D:\Blog\source_posts\算法\image-20240304113054843.png" alt="image-20240304113054843"></p>
<p>这种情况只需要保留其中一个数即可</p>
<p>我们在前几次出现相同数值时不记录，只在最后一次记录，也就是当<code> prediff == 0 &amp;&amp; curdiff &gt; 0</code>或<code> prediff==0 &amp;&amp; curdiff&lt;0</code>时，算作一次峰值  </p>
<p>（当<code>curdiff==0</code>时，不论prediff什么情况都不算峰值）</p>
<p>所以我们记录峰值的条件应该是：</p>
<p> <code>(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)</code></p>
<p><strong>情况二：数组首尾两端</strong></p>
<p><img src="D:\Blog\source_posts\算法\image-20240304121519424.png" alt="image-20240304121519424"></p>
<p>如果只有两个<strong>不同</strong>的元素，那摆动序列是 2，但如果2个元素相同，摆动序列就是1</p>
<p>diff至少需要三个数，当只有两个数时怎么判断?</p>
<p>我们假设<code>prediff</code>初始为0，这样只需要<code>curdiff != 0</code>，也就满足情况一的判断条件了，就把第一个元素当作峰值统计进来了</p>
<p>另外只要数组中有元素，我们默认至少有一个摆动（全部元素相等时算一个）</p>
<p>因此可以令初始<code>count=1</code>（也可以看作最后一个元素默认为1个摆动）</p>
<p><strong>情况三：单调坡度有平坡</strong></p>
<p><img src="D:\Blog\source_posts\算法\image-20240304121706461.png" alt="image-20240304121706461"></p>
<p>对于这种，我们只需要在记录峰值后再更新<code>prediff</code>的值即可</p>
<p>第一个峰值 1 ：<code>prediff==0,curdiff=1&gt;0</code>,更新<code>prediff=curdiff=1</code></p>
<p>之后<code>curdiff</code>始终&gt;&#x3D;0，不再有峰值，不需要更新<code>prediff</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h3><h2 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h2><p><img src="D:\Blog\source_posts\算法\image-20240305130423240.png" alt="image-20240305130423240"></p>
<p>思路：用count计算当前子序列的和，当count&lt;0时，舍弃当前子序列，并从下一个位置重新开始计算count；在这个过程中用res更新记录最大的count</p>
<p>局部最优：负数加上下一个元素 “连续和”只会越来越小，因此舍弃</p>
<p>全局最优：选取最大的连续和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) &#123; <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) count = <span class="number">0</span>; <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">时间复杂度：<span class="built_in">O</span>(n)</span><br><span class="line">空间复杂度：<span class="built_in">O</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p><img src="D:\Blog\source_posts\算法\image-20240305131100070.png" alt="image-20240305131100070"></p>
<p>思路：每两天为一个周期，计算每天的差值，当差值为正时，我们就相当于做了一次买卖，统计总和即可</p>
<p><img src="D:\Blog\source_posts\算法\image-20240305131349101.png" alt="image-20240305131349101"></p>
<p><strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> keep=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> curdiff=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            curdiff = prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            <span class="keyword">if</span>(curdiff &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum += curdiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><img src="D:\Blog\source_posts\算法\image-20240306104735485.png" alt="image-20240306104735485"></p>
<p>思路：<strong>跳跃覆盖范围究竟可不可以覆盖到终点</strong></p>
<p>i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。</p>
<p>而 cover 每次只取 max(该元素数值补充后的范围, cover 本身范围)。</p>
<p>如果 cover 大于等于了终点下标，直接 return true 就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ind=<span class="number">0</span>;  <span class="comment">// 记录当前最大可达下标</span></span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=ind;i++)&#123;  <span class="comment">// 遍历到当前最大可达下标ind</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]+i &gt; ind)&#123;</span><br><span class="line">                ind = nums[i]+i;</span><br><span class="line">                <span class="keyword">if</span>(ind&gt;=len)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="D:\Blog\source_posts\算法\image-20240307111211482.png" alt="image-20240307111211482"></p>
<p>思路：记录每一步跳跃后，当前可达范围，范围到达终点停止</p>
<p>for循环，更新下一步最大可走范围，如果这一步范围走完，已更新的下一步最大可走范围还没有到达终点，步数增加，更新下下步可走范围，依次循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ind=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lstInd=ind;</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+i &gt; ind)&#123;</span><br><span class="line">                ind = nums[i]+i; <span class="comment">// 更新下一步最大可走范围</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == lstInd)&#123;  <span class="comment">// 如果前一个范围走完，ind还不能到达最后，就需要增加一步</span></span><br><span class="line">                count++;</span><br><span class="line">                lstInd = ind;</span><br><span class="line">                <span class="keyword">if</span>(ind &gt;= len<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h2><p><img src="D:\Blog\source_posts\算法\image-20240307113502501.png" alt="image-20240307113502501"></p>
<p>思路：每次让最小的取反，然后排序</p>
<p>原因：如果最小值是负数，取反后是所有数取反后的最大一个</p>
<p>如果最小值是0，取反后不变</p>
<p>如果最小值是正数，取反后是减的最少的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p><img src="D:\Blog\source_posts\算法\image-20240307100225581.png" alt="image-20240307100225581"></p>
<p><strong>寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置</strong></p>
<p>思路：<strong>用一个栈来记录我们遍历过的元素</strong></p>
<p>栈存放元素下标，从栈顶到栈底元素递增，是找后续更大元素（递减，找更小）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answer</span><span class="params">(temperatures.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;  stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;temperatures.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[stk.<span class="built_in">top</span>()] &gt;= temperatures[i])&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; 			 	temperatures[stk.<span class="built_in">top</span>()] &lt; temperatures[i]) &#123;</span><br><span class="line">                    answer[stk.<span class="built_in">top</span>()]=i-stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大元素I"><a href="#下一个更大元素I" class="headerlink" title="下一个更大元素I"></a>下一个更大元素I</h2><p><img src="D:\Blog\source_posts\算法\image-20240307110703763.png" alt="image-20240307110703763"></p>
<p>思路：利用单调栈，在nums2中找每个元素的下一个更大元素，如果此时元素也在nums1中，就加入结果中</p>
<p>如何判断元素是否在nums1中？</p>
<p>哈希映射，将nums1映射到一个unordered_map中，key是nums1的元素，value是对应下标</p>
<p>结果集res的下标与map中的value对应</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(nums2[<span class="number">0</span>]);</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            map[nums1[i]] = i;  <span class="comment">// 哈希映射，方便找元素下标（对应res下标）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; st.<span class="built_in">top</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>( map.<span class="built_in">find</span>(st.<span class="built_in">top</span>()) !=map.<span class="built_in">end</span>() )&#123;</span><br><span class="line">                    res[ map[st.<span class="built_in">top</span>()] ] = nums2[i]; <span class="comment">// 添加结果</span></span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();  <span class="comment">//每次找到更大值，都要将当前栈顶弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p><img src="D:\Blog\source_posts\算法\image-20240308111447760.png" alt="image-20240308111447760"></p>
<p><strong>思路：单调栈</strong></p>
<p>当新元素小于栈顶时入栈（栈顶到栈底升序）</p>
<p><img src="D:\Blog\source_posts\算法\image-20240308111720385.png" alt="image-20240308111720385"></p>
<p><strong>按水平方向计算</strong></p>
<p>每次需要三个柱子，新来的为右边的柱子right（最高），栈顶为凹槽柱子mid（最低），栈顶下面的为左边的柱子left</p>
<p>（每次判断当前来的柱子是否比栈顶的柱子高）</p>
<p>计算方式：高*宽</p>
<p>其中：</p>
<p>​	高&#x3D;min（left，right）-mid</p>
<p>​	宽&#x3D;right-left</p>
<p><img src="D:\Blog\source_posts\算法\image-20240308112215552.png" alt="image-20240308112215552"></p>
<p><strong>在计算完一个凹槽后，将其弹出，再比较此元素与left的大小</strong>，如果仍然比left大，将left变为新的凹槽，这个过程可以用while循环实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; height[stk.<span class="built_in">top</span>()] &lt; height[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> mid=stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="type">int</span> left=stk.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="type">int</span> right=i;</span><br><span class="line">                        <span class="type">int</span> length=<span class="built_in">min</span>(height[i]-height[mid],height[left]-height[mid]);</span><br><span class="line">                        <span class="type">int</span> wide=right-left<span class="number">-1</span>;</span><br><span class="line">                        count+=length*wide;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>特殊处理：如果遇到相同高度的柱子，需要用最右边（新的）柱子来计算宽度</p>
<p><img src="D:\Blog\source_posts\算法\image-20240308112725441.png" alt="image-20240308112725441"></p>
<p>将前面重复的柱子pop出去</p>
<p>总体需要处理的情况为以下三种：</p>
<ul>
<li>情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 height[i] &lt; height[st.top()]</li>
<li>情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 height[i] &#x3D;&#x3D; height[st.top()]</li>
<li>情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 height[i] &gt; height[st.top()]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">size</span>()&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start+<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[stk.<span class="built_in">top</span>()] == height[i])&#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; height[stk.<span class="built_in">top</span>()] &lt; height[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> mid=stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="type">int</span> left=stk.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="type">int</span> right=i;</span><br><span class="line">                        <span class="type">int</span> length=<span class="built_in">min</span>(height[i]-height[mid],height[left]-height[mid]);</span><br><span class="line">                        <span class="type">int</span> wide=right-left<span class="number">-1</span>;</span><br><span class="line">                        count+=length*wide;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>五部曲：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li><strong>确定递推公式</strong></li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><img src="D:\Blog\source_posts\算法\image-20240309210540426.png" alt="image-20240309210540426"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p><img src="D:\Blog\source_posts\算法\image-20240309215631059.png" alt="image-20240309215631059"></p>
<p>思路：</p>
<p>1、确定dp数组及下标含义</p>
<p>dp[i]的定义：到达第i个楼梯所花费最少的金额为dp[i]</p>
<p>2、确定dp递推公式</p>
<p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p>
<p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p>
<p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p>
<p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p>
<p>3、dp数组初始化</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯</p>
<p> dp[0] &#x3D; 0，dp[1] &#x3D; 0;</p>
<p>4、确定遍历顺序</p>
<p>因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以从前到后遍历cost数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 默认第一步都是不花费体力的</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="完全平方数–完全背包"><a href="#完全平方数–完全背包" class="headerlink" title="完全平方数–完全背包"></a>完全平方数–完全背包</h3><p><img src="D:\Blog\source_posts\算法\image-20240319143447311.png" alt="image-20240319143447311"></p>
<p>思路：完全背包问题</p>
<p>完全平方数就是物品（可以无限使用），整数n就是背包，问凑满这个背包最少有多少个物品？</p>
<p>dp【i】：和为i的完全平方数的最少数量为dp【i】</p>
<p>dp【i】&#x3D; min（dp【i-j*j】+1，dp【i】）</p>
<p>遍历0-n的整数（遍历背包），当完全平方数为j时，用i-j*j取剩余整数，而dp【i-j * j】就是剩余整数的最少完全平方数，加1代表取当前的完全平方数j，比较取j与不取j，哪个的完全平方数更少</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p><img src="D:\Blog\source_posts\算法\image-20240320103413987.png" alt="image-20240320103413987"></p>
<p>思路：dp[i]表示前i个元素的最长递增子序列长度（包括i）</p>
<p>dp[i]&#x3D; max（dp[j]+1，dp[i]）   前提：nums[i] &gt;  nums[j]</p>
<p>初始化：dp(n,1)</p>
<p>每一个元素都至少有一个长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p><img src="D:\Blog\source_posts\算法\image-20240321092525423.png" alt="image-20240321092525423"></p>
<p>思路：从里向外扩充，如果里面的是回文串，扩充左右相等，那扩充后还是回文串</p>
<p><img src="D:\Blog\source_posts\算法\image-20240321092936308.png" alt="image-20240321092936308"></p>
<p>1 dp数组</p>
<p>定义一个二维dp数组，类型为bool</p>
<p>dp[i] [j]：表示区间 【i ， j】 的子串是否为回文串</p>
<p>2 递推公式：</p>
<p>两种情况 s[i]和s[j] 相等或不相等</p>
<p>如果不相等，直接为false</p>
<p>如果相等，要讨论三种类型</p>
<ul>
<li>下标i与j相同，也就是同一个字符，是回文串，dp[i] [j] &#x3D; true</li>
<li>下标i与j相差1，两个相邻字符相等，是回文串，dp[i] [j] &#x3D; true</li>
<li>下标i与j相差大于1，需要根据dp[i+1] [j-1]来判断</li>
</ul>
<p>3 遍历顺序：</p>
<p><img src="D:\Blog\source_posts\算法\image-20240321093921093.png" alt="image-20240321093921093"></p>
<p><strong>从下到上，从左到右遍历，这样保证dp[i + 1] [j - 1]都是经过计算的</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><img src="D:\Blog\source_posts\算法\image-20240321113007202.png" alt="image-20240321113007202"></p>
<p>思路：在回文子串的基础上，每次更新当前最长回文子串的左右下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(),<span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>,end=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i&lt;=<span class="number">1</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span>&gt;end)&#123;</span><br><span class="line">                    end = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p><img src="D:\Blog\source_posts\算法\image-20240321102434894.png" alt="image-20240321102434894"></p>
<p>思路：回文子序列与回文子串不同</p>
<p>子序列可以挑选不相邻字符，子串必须是挨着的</p>
<p>**dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i] [j]**。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>基于http的Linux高性能并发服务器</title>
    <url>/2023/12/27/%E5%9F%BA%E4%BA%8Ehttp%E7%9A%84Linux%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="第一章-Linux系统编程"><a href="#第一章-Linux系统编程" class="headerlink" title="第一章 Linux系统编程"></a>第一章 Linux系统编程</h1><p><img src="D:\Blog\source_posts\webserver\xzuiCU6kQVcQ4IWY.png!thumbnail" alt="img">第一章 Linux系统编程入门</p>
<h2 id="1-gcc"><a href="#1-gcc" class="headerlink" title="1 gcc"></a>1 gcc</h2><p><img src="D:\Blog\source_posts\webserver\ZSfJN5pDVM15eQLV.png!thumbnail" alt="img"><img src="D:\Blog\source_posts\webserver\PzBXwpDP7sNdsDG7.png!thumbnail" alt="img">	-D：相当于在程序中使用 #define  <img src="D:\Blog\source_posts\webserver\RSKrvQWQfVey2eUx.png!thumbnail" alt="img"> </p>
<h2 id="2-静态库"><a href="#2-静态库" class="headerlink" title="2 静态库"></a>2 静态库</h2><p>静态库在程序的链接阶段被复制到了程序中<img src="D:\Blog\source_posts\webserver\eh458JlvXVeL9FOz.png!thumbnail" alt="img">初始状态：<img src="D:\Blog\source_posts\webserver\hzLNWyEaPnwEEhH9.png!thumbnail" alt="img">预处理、编译、汇编.c源文件进入src目录使用 -I 参数指定包含的头文件目录<img src="https://uploader.shimo.im/f/xRhJpX7WnfixzdBH.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img">链接静态库ar rcs libxxx.a xxx.o xxx.o移动到 lib 目录下<img src="D:\Blog\source_posts\webserver\qQjp65wQuBmsjoIG.png!thumbnail" alt="img">生成 .o 可执行文件需要指定头文件  -I .&#x2F;include需要指定静态库   -l  xxx  -L [目录地址]<img src="https://uploader.shimo.im/f/5xWZXKtIZIfyuPct.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img">生成app可执行文件<img src="D:\Blog\source_posts\webserver\Y2mbSMK8OYm61UQo.png!thumbnail" alt="img"> </p>
<h2 id="3-动态库"><a href="#3-动态库" class="headerlink" title="3 动态库"></a>3 动态库</h2><p><img src="D:\Blog\source_posts\webserver\RiNRoQkRjTmmOXmr.png!thumbnail" alt="img"><img src="https://uploader.shimo.im/f/PzyhfyNOUpbwjbFJ.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img">第一种方式：修改LD_LIBRARY_PATH临时添加：export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;home&#x2F;bal&#x2F;linux&#x2F;lesson06&#x2F;library&#x2F;lib永久配置：用户级别：vim .bashrc  最后一行添加上面的指令  source .bashrc系统级别：sudo vim &#x2F;etc&#x2F;profile最后一行添加上面的命令source &#x2F;etc&#x2F;profile</p>
<p>第二种方式：修改&#x2F;etc&#x2F;ld.so.cachesudo vim &#x2F;etc&#x2F;ld.so.conf添加动态库路径sudo ldconfig第三种方式：将动态库文件放在&#x2F;lib 或 &#x2F;usr&#x2F;lib目录下（不建议，里面有很多系统库文件）</p>
<h2 id="4-静态库和动态库对比"><a href="#4-静态库和动态库对比" class="headerlink" title="4 静态库和动态库对比"></a>4 静态库和动态库对比</h2><p><img src="D:\Blog\source_posts\webserver\P2jRTAY9ediHLXrL.png!thumbnail" alt="img"><img src="https://uploader.shimo.im/f/1KzQYgas67P72A7d.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img"></p>
<h2 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5 Makefile"></a>5 Makefile</h2><p>目标+依赖+命令<img src="D:\Blog\source_posts\webserver\7qaAE9XAjUKBvMNH.png!thumbnail" alt="img"><img src="https://uploader.shimo.im/f/k9hfixtKHoLUIk9J.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img"><img src="https://uploader.shimo.im/f/59YUR3Ah1hFFKjS9.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img"><code>src=sub.o add.o mult.o div.o main.o target=app  $(target):$(src)        $(CC) $(src) -o $(target)  %.o:%.c        $(CC) -c $&lt; -o $@</code></p>
<p><img src="D:\Blog\source_posts\webserver\fqW87jS0FAkBTJ1K.png!thumbnail" alt="img"> </p>
<p><code>target=app src=$(wildcard ./*.c) objs=$(patsubst %.c, %.o, $(src))  $(target):$(objs)        $(CC) $(objs) -o $(target)  %.o:%.c        $(CC) -c $&lt; -o $@</code></p>
<h2 id="6-GDB"><a href="#6-GDB" class="headerlink" title="6 GDB"></a>6 GDB</h2><p>为调试而编译时，关掉优化选项-o  ，打开调试选项-g，-Wall（警告）<code>gcc -g -Wall program.c -o program </code></p>
<p>启动和退出：gdb  可执行程序   quit</p>
<p>设置参数  set args 10 20   ； show args  <img src="D:\Blog\source_posts\webserver\V6dLb8f0gs77LyFK.png!thumbnail" alt="img"><img src="https://uploader.shimo.im/f/5XSRGtdsfhV021Hb.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img">until ：需要循环里没有断点，且代码执行完7 文件io<img src="https://uploader.shimo.im/f/O41kLRyBepsLHUhE.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img">可跨平台（不同平台使用不同的api）<img src="https://uploader.shimo.im/f/HOr49fjkQtTTPrqh.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img"> <img src="https://uploader.shimo.im/f/xmxOv529D26CbS1Z.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MTA4NTQ1MTgsImZpbGVHVUlEIjoibG9xZU1ObE1hT0NPR01xbiIsImlhdCI6MTcxMDg1NDIxOCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.J8VFEk_Fu5lzLgqFRwVEbyA2TX5rbyTX-F29EO6sP6A" alt="img">程序执行后（成为进程）会为其创建独立的虚拟地址空间CPU的MMU会将虚拟地址空间映射到真实物理内存堆：从下往上（低地址-&gt;高地址）栈：从上往下（高地址-&gt;低地址）   </p>
<h2 id="7-文件io"><a href="#7-文件io" class="headerlink" title="7 文件io"></a>7 文件io</h2><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240102210431160.png" alt="image-20240102210431160"></p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 打开一个已经存在的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment">     参数：</span></span><br><span class="line"><span class="comment">            - pathname：要打开的文件路径</span></span><br><span class="line"><span class="comment">            - flags：对文件的操作权限设置还有其他的设置</span></span><br><span class="line"><span class="comment">            O_RDONLY,  O_WRONLY,  O_RDWR  </span></span><br><span class="line"><span class="comment">            (这三个设置是互斥的)</span></span><br><span class="line"><span class="comment">     返回值：返回一个新的文件描述符，如果调用失败，返回-1</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    void perror(const char *s);</span></span><br><span class="line"><span class="comment">    作用：打印errno对应的错误描述</span></span><br><span class="line"><span class="comment">    s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 创建一个新的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  ...读写操作</span></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    标准C库的函数</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Linux系统函数</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">            - offset：偏移量</span></span><br><span class="line"><span class="comment">            - whence:</span></span><br><span class="line"><span class="comment">                SEEK_SET</span></span><br><span class="line"><span class="comment">                    设置文件指针的偏移量（通过offset指定大小）：起始位置+offset</span></span><br><span class="line"><span class="comment">                SEEK_CUR</span></span><br><span class="line"><span class="comment">                    设置偏移量：当前位置 + offset</span></span><br><span class="line"><span class="comment">                SEEK_END</span></span><br><span class="line"><span class="comment">                    设置偏移量：文件结尾 + offset</span></span><br><span class="line"><span class="comment">        返回值：返回文件指针的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">        1.移动文件指针到文件头</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.获取当前文件指针的位置</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.获取文件长度</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment">        lseek(fd, 100, SEEK_END)</span></span><br><span class="line"><span class="comment">        注意：需要写一次数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="stat-lstat"><a href="#stat-lstat" class="headerlink" title="stat lstat"></a>stat lstat</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.txt -&gt; b.txt 软链接</span></span><br><span class="line"><span class="comment">lstat获取a.txt的信息，stat获取b.txt的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>struct stat *statbuf 结构体</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240102210455881.png" alt="image-20240102210455881"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240102210505511.png" alt="image-20240102210505511"></p>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int access(const char *pathname, int mode);</span></span><br><span class="line"><span class="comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 判断的文件路径</span></span><br><span class="line"><span class="comment">            - mode:</span></span><br><span class="line"><span class="comment">                R_OK: 判断是否有读权限</span></span><br><span class="line"><span class="comment">                W_OK: 判断是否有写权限</span></span><br><span class="line"><span class="comment">                X_OK: 判断是否有执行权限</span></span><br><span class="line"><span class="comment">                F_OK: 判断文件是否存在</span></span><br><span class="line"><span class="comment">        返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        修改文件的权限</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - mode:需要修改的权限值，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">        作用：缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - path: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - length: 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用：创建一个目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="chdir-getcwd"><a href="#chdir-getcwd" class="headerlink" title="chdir getcwd"></a>chdir getcwd</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            path : 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span></span><br><span class="line"><span class="comment">            - size: 数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">           返回指向的一块内存(就是第一个参数buf)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="opendir-readdir-closedir"><a href="#opendir-readdir-closedir" class="headerlink" title="opendir readdir closedir"></a>opendir readdir closedir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型，理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup  dup2"></a>dup  dup2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup(int oldfd);</span></span><br><span class="line"><span class="comment">        作用：复制一个新的文件描述符</span></span><br><span class="line"><span class="comment">        fd=3, int fd1 = dup(fd),</span></span><br><span class="line"><span class="comment">        fd指向的是a.txt, fd1也指向a.txt</span></span><br><span class="line"><span class="comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符(例如fd1=4)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">	int dup2(int oldfd,int newfd);</span></span><br><span class="line"><span class="comment">	作用：重定向文件描述符（将newfd指向oldfd指向的文件）</span></span><br><span class="line"><span class="comment">	注：oldfd-&gt;a,txt  newfd-&gt;b.txt</span></span><br><span class="line"><span class="comment">	调用函数 int fd3 = dup2(oldfd,newfd)</span></span><br><span class="line"><span class="comment">    	newfd和b.txt先close 然后newfd-&gt;a.txt</span></span><br><span class="line"><span class="comment">    （oldfd必须是一个有效的文件描述符）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    返回值：fd3=newfd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int fcntl(int fd, int cmd, ...);</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        fd : 表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment">        cmd: 表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">                int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_SETFL : 设置文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span></span><br><span class="line"><span class="comment">              可选性：O_APPEND, O)NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                NONBLOK 设置成非阻塞</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        阻塞和非阻塞：描述的是函数调用的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="第二章-Linux多进程开发"><a href="#第二章-Linux多进程开发" class="headerlink" title="第二章 Linux多进程开发"></a>第二章 Linux多进程开发</h1><h2 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h2><p>程序是包含一系列信息的文件（信息用来描述如何创建进程）</p>
<p>进程是正在运行的程序的实例（程序不占用内存和cpu）</p>
<p>时间片由操作系统内核的调度程序分配给进程</p>
<p>（注：熟悉进程调度算法）</p>
<p>并行：同时执行</p>
<p>并发：交替执行</p>
<p>PCB进程控制块：task__struct 结构体</p>
<ul>
<li>​	进程id：pid_t类型，系统中每个进程唯一的id</li>
<li>​	进程状态：就绪、运行、挂起、停止等</li>
<li>​	进程切换时需要保存和恢复的cpu寄存器</li>
<li>​	描述虚拟地址空间的信息</li>
<li>​	描述控制终端的信息</li>
<li>​	当前工作目录</li>
<li>​	umask掩码</li>
<li>​	文件描述符表（包含很多指向file结构体的指针）</li>
<li>​	信号相关的信息</li>
<li>​	用户id和组id</li>
<li>​	会话（session）和进程组</li>
<li>​	进程可以使用的资源上限</li>
</ul>
<h2 id="2-2-进程状态转换"><a href="#2-2-进程状态转换" class="headerlink" title="2.2 进程状态转换"></a>2.2 进程状态转换</h2><p>三态：就绪、运行、阻塞</p>
<p>五态：新建、就绪、运行、阻塞、终止</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240104213546429.png" alt="image-20240104213546429"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240104213555696.png" alt="image-20240104213555696"></p>
<ul>
<li>查看进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux / ajx</span><br><span class="line">a：显示终端上所有进程</span><br><span class="line">u：显示进程详细信息</span><br><span class="line">x：显示没有控制终端的进程</span><br><span class="line">j：列出与作业控制相关的信息</span><br></pre></td></tr></table></figure>

<ul>
<li>实时显示进程动态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">M 根据内存使用量排序 </span><br><span class="line">P 根据 CPU 占有率排序</span><br><span class="line">T 根据进程运行时间长短排序</span><br><span class="line">U 根据用户名来筛选进程</span><br><span class="line">K 输入指定的 PID 杀死进程</span><br></pre></td></tr></table></figure>

<ul>
<li>杀死进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill [-signal] pid</span><br><span class="line">kill –l 列出所有信号</span><br><span class="line">kill –SIGKILL 进程ID</span><br><span class="line">kill -9 进程ID</span><br><span class="line">killall name 根据进程名杀死进程</span><br></pre></td></tr></table></figure>

<p>**◼ **每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p>◼ 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。</p>
<p>◼ 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。</p>
<p>◼ 进程号和进程组相关函数：</p>
<p>pid_t getpid(void);</p>
<p>pid_t getppid(void);</p>
<p>pid_t getpgid(pid_t pid);</p>
<h2 id="2-3-进程创建"><a href="#2-3-进程创建" class="headerlink" title="2.3 进程创建"></a>2.3 进程创建</h2><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t fork(void);</span><br><span class="line">	返回值：</span><br><span class="line">		成功：子进程中返回0，父进程中返回子进程ID</span><br><span class="line">		失败：返回-1</span><br><span class="line">	失败原因：</span><br><span class="line">		1、当前系统进程数已达上限，errno=EAGAIN</span><br><span class="line">		2、系统内存不足，errno=ENOMEM</span><br></pre></td></tr></table></figure>

<h2 id="2-4-父子进程虚拟地址空间"><a href="#2-4-父子进程虚拟地址空间" class="headerlink" title="2.4  父子进程虚拟地址空间"></a>2.4  父子进程虚拟地址空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父子进程之间的关系：</span><br><span class="line">   区别：</span><br><span class="line">       1.fork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;0 返回的子进程的ID</span><br><span class="line">            子进程中: =0</span><br><span class="line">       2.pcb中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">             信号集</span><br><span class="line">    共同点：</span><br><span class="line">       某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据一样</span><br><span class="line">            - 文件描述符表一样</span><br><span class="line">        </span><br><span class="line">  父子进程对变量是不是共享的？</span><br><span class="line"> - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line"> - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。（COW）</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span><br><span class="line">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span><br><span class="line">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span><br><span class="line">只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自独立的地址空间。</span><br><span class="line">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span><br><span class="line">注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享 文件偏移指针。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="2-5-GDB多进程调试"><a href="#2-5-GDB多进程调试" class="headerlink" title="2.5 GDB多进程调试"></a>2.5 GDB多进程调试</h2><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240106151123719.png" alt="image-20240106151123719"></p>
<h2 id="2-6-exec函数族"><a href="#2-6-exec函数族" class="headerlink" title="2.6 exec函数族"></a>2.6 exec函数族</h2><p>作用：调用可执行文件，取代进程后续的内容</p>
<p>调用成功不返回（因为原代码已被替换为可执行文件的内容，没有exec这行代码了）</p>
<p>调用失败返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int execl(const char * path,const char *arg, ...);</span><br><span class="line">        - 参数：</span><br><span class="line">            - path:需要指定的执行的文件的路径或者名称</span><br><span class="line">                a.out /home/nowcoder/a.out 推荐使用绝对路径</span><br><span class="line">                ./a.out hello world</span><br><span class="line"></span><br><span class="line">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">                参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">            如果调用成功，没有返回值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> int execlp(const char *file, const char *arg, ... );</span><br><span class="line">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="line">        - 参数：</span><br><span class="line">            - file:需要执行的可执行文件的文件名</span><br><span class="line">                a.out</span><br><span class="line">                ps</span><br><span class="line"></span><br><span class="line">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">                参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">            如果调用成功，没有返回值。</span><br><span class="line">            </span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">        argv是需要的参数的一个字符串数组</span><br><span class="line">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span><br><span class="line">        execv(&quot;/bin/ps&quot;, argv);</span><br><span class="line">        </span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240107140312527.png" alt="image-20240107140312527"></p>
<p>有p或e：传文件名，否则传路径</p>
<p>e：自定义去哪些环境变量中查找</p>
<p>v：用参数数组写入参数</p>
<p>l：直接写入参数，以null结尾</p>
<h2 id="2-7-进程控制"><a href="#2-7-进程控制" class="headerlink" title="2.7 进程控制"></a>2.7 进程控制</h2><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240107150011858.png" alt="image-20240107150011858"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;hello\n&quot;);</span><br><span class="line">	printf(&quot;world&quot;);</span><br><span class="line">	</span><br><span class="line">	exit(0); // 标准c库，会刷新缓冲区 打印 hello world</span><br><span class="line">	_exit(0);// 系统调用，不会刷新缓冲区  打印 hello （\n会刷新缓冲区） </span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status的值代表进程退出状态，可以被wait或waitpid捕获</span><br></pre></td></tr></table></figure>

<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>◼ <strong>父进程先运行结束，但子进程还在运行，这样的子进程就称为孤儿进程</strong>（Orphan Process）。</p>
<p>◼ 每当出现一个孤儿进程，<strong>内核就把孤儿进程的父进程设为 init ， init 进程会循环地 wait() 这些孤儿进程。</strong>这样，当一个孤儿进程结束了其生命周期的时候，init 进程就会处理它的一切善后工作</p>
<p>◼ 因此孤儿进程并不会有什么危害</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，但内核区的 PCB 没有办法自己释放掉，需要父进程去释放</p>
<p>◼ <strong>子进程先终止</strong>，如果父进程尚未回收，子进程残留的资源（PCB）存放于内核中，变成僵尸（Zombie）进程</p>
<p>◼ <strong>僵尸进程不能被 kill -9 杀死</strong>，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是<strong>系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程</strong>，此为僵尸进程的危害，应当避免</p>
<p>解决方法：</p>
<ol>
<li>终止父进程，让子进程被init进程回收（企业中已运行，不能终止）</li>
<li>在父进程中调用wait或waitpid（常用）</li>
</ol>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>◼ 在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件、占用的内存等。</p>
<p>但是仍然为其保留一定的信息，这些信息主要是进程控制块PCB的信息（包括进程号、退出状态、运行时间等）</p>
<p>◼ 父进程可以通过调用wait或waitpid得到它的退出状态，同时彻底清除掉这个进程</p>
<p>◼ wait() 和 waitpid() 函数的功能一样，区别在于，<strong>wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束</strong></p>
<p>◼ <strong>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环</strong></p>
<h3 id="wait（）"><a href="#wait（）" class="headerlink" title="wait（）"></a>wait（）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t wait(int *wstatus);</span><br><span class="line">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span><br><span class="line">        参数：int *wstatus</span><br><span class="line">            进程退出时的状态信息，传入的是一个int类型的地址，将状态赋给这个参数 （传出参数）</span><br><span class="line">            可以为NULL，表示不获取子进程退出状态</span><br><span class="line">        返回值：</span><br><span class="line">            - 成功：返回被回收的子进程的id</span><br><span class="line">            - 失败：-1 (所有的子进程都已结束/调用函数失败)</span><br><span class="line"></span><br><span class="line">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240107165037885.png" alt="image-20240107165037885"></p>
<h3 id="waitpid（）"><a href="#waitpid（）" class="headerlink" title="waitpid（）"></a>waitpid（）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">        参数：</span><br><span class="line">            - pid:</span><br><span class="line">                pid &gt; 0 : 某个子进程的pid</span><br><span class="line">                pid = 0 : 回收当前进程组中的任意一个子进程    </span><br><span class="line">                pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）</span><br><span class="line">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">            - options：设置阻塞或者非阻塞</span><br><span class="line">                0 : 阻塞</span><br><span class="line">                WNOHANG : 非阻塞</span><br><span class="line">            - 返回值：</span><br><span class="line">                &gt; 0 : 返回子进程的id</span><br><span class="line">                = 0 : options=WNOHANG时, 表示还有子进程</span><br><span class="line">                = -1 ：错误或者没有子进程了</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="2-8-进程间通信IPC"><a href="#2-8-进程间通信IPC" class="headerlink" title="2.8 进程间通信IPC"></a>2.8 进程间通信IPC</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p><strong><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122133916483.png" alt="image-20240122133916483"></strong></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>在内核内存中维护的缓冲器</li>
<li>拥有文件的特质：读操作、写操作</li>
<li>匿名管道没有文件实体，有名管道有文件实体,但不存储数据</li>
<li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少</li>
<li>传递的数据是顺序的</li>
<li>传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的</li>
<li>读数据是一次性操作,在管道中无法使用 lseek() 来随机的访问数据</li>
<li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◼ 创建匿名管道</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">◼ 查看管道缓冲大小命令</span><br><span class="line">ulimit –a</span><br><span class="line">◼ 查看管道缓冲大小函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">long fpathconf(int fd, int name);</span><br><span class="line">/*</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int pipe(int pipefd[2]);</span><br><span class="line">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="line">            pipefd[0] 对应的是管道的读端</span><br><span class="line">            pipefd[1] 对应的是管道的写端</span><br><span class="line">        返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1</span><br><span class="line"></span><br><span class="line">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line"></span><br><span class="line">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">获取管道大小：fpathconf（）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">◼ 通过命令创建有名管道</span><br><span class="line">mkfifo 名字</span><br><span class="line">◼ 通过函数创建有名管道</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    创建fifo文件</span><br><span class="line">    1.通过命令：mkfifo 名字</span><br><span class="line">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/stat.h&gt;</span><br><span class="line">    int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">        参数：</span><br><span class="line">            - pathname: 管道名称的路径</span><br><span class="line">            - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="line">                    是一个八进制的数</span><br><span class="line">        返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中</li>
<li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用</li>
<li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信</li>
</ol>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122134521469.png" alt="image-20240122134521469"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◼ #include &lt;sys/mman.h&gt;</span><br><span class="line">◼ void *mmap(void *addr, size_t length, int prot, int flags, </span><br><span class="line">int fd, off_t offset);</span><br><span class="line">◼ int munmap(void *addr, size_t length);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/mman.h&gt;</span><br><span class="line">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">        - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="line">        - 参数：</span><br><span class="line">            - void *addr: NULL, 由内核指定</span><br><span class="line">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="line">                    获取文件的长度：stat lseek</span><br><span class="line">            - prot : 对申请的内存映射区的操作权限</span><br><span class="line">                -PROT_EXEC ：可执行的权限</span><br><span class="line">                -PROT_READ ：读权限</span><br><span class="line">                -PROT_WRITE ：写权限</span><br><span class="line">                -PROT_NONE ：没有权限</span><br><span class="line">                要操作映射内存，必须要有读的权限。</span><br><span class="line">                PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="line">            - flags :</span><br><span class="line">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="line">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="line">            - fd: 需要映射的那个文件的文件描述符</span><br><span class="line">                - 通过open得到，open的是一个磁盘文件</span><br><span class="line">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="line">                    prot: PROT_READ                open:只读/读写 </span><br><span class="line">                    prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="line">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移</span><br><span class="line">        - 返回值：返回创建的内存的首地址</span><br><span class="line">            失败返回MAP_FAILED，(void *) -1</span><br><span class="line"></span><br><span class="line">    int munmap(void *addr, size_t length);</span><br><span class="line">        - 功能：释放内存映射</span><br><span class="line">        - 参数：</span><br><span class="line">            - addr : 要释放的内存的首地址</span><br><span class="line">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    使用内存映射实现进程间通信：</span><br><span class="line">    1.有关系的进程（父子进程）</span><br><span class="line">        - 还没有子进程的时候</span><br><span class="line">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="line">        - 有了内存映射区以后，创建子进程</span><br><span class="line">        - 父子进程共享创建的内存映射区</span><br><span class="line">    </span><br><span class="line">    2.没有关系的进程间通信</span><br><span class="line">        - 准备一个大小不是0的磁盘文件</span><br><span class="line">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="line">            - 得到一个操作这块内存的指针</span><br><span class="line">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="line">            - 得到一个操作这块内存的指针</span><br><span class="line">        - 使用内存映射区通信</span><br><span class="line"></span><br><span class="line">    注意：内存映射区通信，是非阻塞。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">参数: </span><br><span class="line">	sem:信号对象</span><br><span class="line">	pshared: 控制信号量类型</span><br><span class="line">		- <span class="number">0</span> ：多线程间同步</span><br><span class="line">		- &gt;<span class="number">0</span> : 多进程间同步</span><br><span class="line">	value:信号量的初始值</span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; </span><br><span class="line">    阻塞函数，检测sem的值</span><br><span class="line">    若sem&gt;<span class="number">0</span>，将值减<span class="number">1</span>并返回</span><br><span class="line">    若sem&lt;=<span class="number">0</span>，阻塞，直到sem&gt;<span class="number">0</span>，此时立即减<span class="number">1</span>并返回</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sem_trywait(<span class="type">sem_t</span> *sem);</span><br><span class="line">	非阻塞的函数</span><br><span class="line">	尝试获取获取 sem value 值，如果 sem value = <span class="number">0</span>，不阻塞，直接返回一个错误 EAGAIN</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sem_post(<span class="type">sem_t</span> *sem);</span><br><span class="line">	把指定的信号量 sem 的值加 <span class="number">1</span>，唤醒正在等待该信号量的任意线程</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line">	获取信号量 sem 的当前值，把该值保存在 sval</span><br><span class="line">	若有 <span class="number">1</span> 个或多个线程正在调用 sem_wait 阻塞在该信号量上，该函数返回阻塞在该信号量上进程或线程个数</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">	对用完的信号量的清理</span><br><span class="line">	成功 <span class="number">0</span>，失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure>



<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>事件发生时对进程的通知机制</li>
<li>软件中断，异步通信</li>
</ul>
<p>引发内核为进程产生信号的各类事件如下：</p>
<p> 对于<strong>前台进程，用户可以通过输入特殊的终端字符来给它发送信号</strong>。比如输入Ctrl+C 通常会给进程发送一个中断信号。</p>
<p> <strong>硬件发生异常，即硬件检测到一个错误条件并通知内</strong>核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</p>
<p> <strong>系统状态变化，比如 alarm 定时器到期</strong>将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。</p>
<p> <strong>运行 kill 命令或调用 kill 函数</strong></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145712118.png" alt="image-20240122145712118"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145720598.png" alt="image-20240122145720598"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145731979.png" alt="image-20240122145731979"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145740191.png" alt="image-20240122145740191"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145750661.png" alt="image-20240122145750661"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号的 5 种默认处理动作</span><br><span class="line">◼ 查看信号的详细信息：man 7 signal</span><br><span class="line">◼ 信号的5种默认处理动作</span><br><span class="line">	 Term 终止进程</span><br><span class="line">	 Ign 当前进程忽略掉这个信号</span><br><span class="line">	 Core 终止进程，并生成一个Core文件</span><br><span class="line">	 Stop 暂停当前进程</span><br><span class="line">	 Cont 继续执行当前被暂停的进程</span><br><span class="line">◼ 信号的几种状态：产生、未决、递达</span><br><span class="line">◼ SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</span><br></pre></td></tr></table></figure>

<p>kill、raise、alarm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*  </span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">    int kill(pid_t pid, int sig);</span><br><span class="line">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="line">        - 参数：</span><br><span class="line">            - pid ：</span><br><span class="line">                &gt; 0 : 将信号发送给指定的进程</span><br><span class="line">                = 0 : 将信号发送给当前的进程组</span><br><span class="line">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="line">                &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="line">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="line"></span><br><span class="line">        kill(getppid(), 9);</span><br><span class="line">        kill(getpid(), 9);</span><br><span class="line">        </span><br><span class="line">    int raise(int sig);</span><br><span class="line">        - 功能：给当前进程发送信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - sig : 要发送的信号</span><br><span class="line">        - 返回值：</span><br><span class="line">            - 成功 0</span><br><span class="line">            - 失败 非0</span><br><span class="line">        kill(getpid(), sig);   </span><br><span class="line"></span><br><span class="line">    void abort(void);</span><br><span class="line">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="line">        kill(getpid(), SIGABRT);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>定时器alarm</p>
<p>函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALRM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    unsigned int alarm(unsigned int seconds);</span><br><span class="line">        - 功能：设置定时器（闹钟）。</span><br><span class="line">        - 参数：</span><br><span class="line">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="line">           取消一个定时器，通过alarm(0)。</span><br><span class="line">        - 返回值：</span><br><span class="line">            - 之前没有定时器，返回0</span><br><span class="line">            - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="line"></span><br><span class="line">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="line">        alarm(10);  -&gt; 返回0</span><br><span class="line">        过了1秒</span><br><span class="line">        alarm(5);   -&gt; 返回9</span><br><span class="line">        </span><br><span class="line">    alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    实际的时间 = 内核时间 + 用户时间 + 消耗的时间</span><br><span class="line">    进行文件IO操作的时候比较浪费时间</span><br><span class="line">    定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>定时器setitimer</p>
<p>函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALRM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/time.h&gt;</span><br><span class="line">    int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</span><br><span class="line">    - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">    - 参数：</span><br><span class="line">       - which : 定时器以什么时间计时</span><br><span class="line">      ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用</span><br><span class="line">      ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">      ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line">      - new_value: 设置定时器的属性</span><br><span class="line">      		struct itimerval &#123;      // 定时器的结构体</span><br><span class="line">                struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="line">                struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="line">                &#125;;</span><br><span class="line">            struct timeval &#123;        // 时间的结构体</span><br><span class="line">                 time_t      tv_sec;     //  秒数     </span><br><span class="line">                 suseconds_t tv_usec;    //  微秒    </span><br><span class="line">                &#125;;</span><br><span class="line">      过10秒后，每个2秒定时一次</span><br><span class="line">       - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">       - 返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1 并设置错误号</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>信号捕捉函数signal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    typedef void (*sighandler_t)(int);</span><br><span class="line">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">        - 功能：设置某个信号的捕捉行为</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum: 要捕捉的信号</span><br><span class="line">            - handler: 捕捉到信号要如何处理</span><br><span class="line">                - SIG_IGN ： 忽略信号</span><br><span class="line">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="line">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="line">                回调函数：</span><br><span class="line">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="line">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="line">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">            失败，返回SIG_ERR，设置错误号</span><br><span class="line">            </span><br><span class="line">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>信号捕捉函数sigaction</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line">    - 功能：检查或者改变信号的处理（信号捕捉）</span><br><span class="line">    - 参数：</span><br><span class="line">        - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">        - act ：捕捉到信号之后的处理动作</span><br><span class="line">        - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递<span class="literal">NULL</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 <span class="number">0</span></span><br><span class="line">        失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">    <span class="type">void</span>  (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不常用</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">    <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 被废弃掉了</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>信号集</p>
<p>​	未决信号集、阻塞信号集（内核使用位图机制实现）</p>
<p>​	操作系统不允许我们直接对这两个信号集进行位操作，而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改</p>
<p>​	多个同样的信号到来时，只能记录一个未决信号或阻塞信号（不支持排队）</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122181743080.png" alt="image-20240122181743080"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号集相关函数</span><br><span class="line">/*</span><br><span class="line">    以下信号集相关的函数都是对自定义的信号集进行操作。</span><br><span class="line">    int sigemptyset(sigset_t *set);</span><br><span class="line">        - 功能：清空信号集中的数据,将信号集中的所有标志位 置0</span><br><span class="line">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigfillset(sigset_t *set);</span><br><span class="line">        - 功能：将信号集中的所有的标志位置为1</span><br><span class="line">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigaddset(sigset_t *set, int signum);</span><br><span class="line">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：传出参数，需要操作的信号集</span><br><span class="line">            - signum：需要设置阻塞的那个信号</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigdelset(sigset_t *set, int signum);</span><br><span class="line">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：传出参数，需要操作的信号集</span><br><span class="line">            - signum：需要设置不阻塞的那个信号</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigismember(const sigset_t *set, int signum);</span><br><span class="line">        - 功能：判断某个信号是否阻塞</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：需要操作的信号集</span><br><span class="line">            - signum：需要判断的那个信号</span><br><span class="line">        - 返回值：</span><br><span class="line">            1 ： signum被阻塞</span><br><span class="line">            0 ： signum不阻塞</span><br><span class="line">            -1 ： 失败</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>sigprocmask</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">操作内核中的信号集</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"></span><br><span class="line">   - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">     参数：</span><br><span class="line">     - how : 如何对内核阻塞信号集进行处理</span><br><span class="line">       SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="line">           假设内核中默认的阻塞信号集是mask， mask | <span class="built_in">set</span></span><br><span class="line">       SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="line">           mask &amp;= ~<span class="built_in">set</span></span><br><span class="line">       SIG_SETMASK:覆盖内核中原来的值</span><br><span class="line"></span><br><span class="line">     - <span class="built_in">set</span> ：已经初始化好的用户自定义的信号集</span><br><span class="line">     - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 <span class="literal">NULL</span></span><br><span class="line">          - 返回值：</span><br><span class="line">            成功：<span class="number">0</span></span><br><span class="line">            失败：<span class="number">-1</span></span><br><span class="line">            设置错误号：EFAULT、EINVAL</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sigpending(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">   - 功能：获取内核中的未决信号集</span><br><span class="line">     ：<span class="built_in">set</span>,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240123131458814.png" alt="image-20240123131458814"></p>
<p>SIGCHLD信号</p>
<p>◼ SIGCHLD信号产生的条件</p>
<p>​	 子进程终止时</p>
<p>​	 子进程接收到 SIGSTOP 信号停止时</p>
<p>​	 子进程处在停止态，接受到SIGCONT后唤醒时</p>
<p>◼ 以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>1、调用shmget（）创建或获取一个共享内存段</p>
<p>2、调用shmat（）附上该共享内存段</p>
<p>3、调用shmdt（）分离共享内存段</p>
<p>4、调用shmctl（）删除共享内存段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识（新创建的内存段中的数据都会被初始化为<span class="number">0</span>）</span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  </span><br><span class="line">        失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line">    - 功能：对共享内存进行操作。主要用来删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁对共享内存没有任何影响</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁（所有进程都标记销毁，共享内存才会销毁）</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">    - 功能：根据指定的 路径名和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体<span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> 这个结构体中有一个成员 <span class="title">shm_nattch</span></span></span><br><span class="line"><span class="class">    - <span class="title">shm_nattach</span> 记录了关联的进程个数</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">问题2：可不可以对共享内存进行多次删除 <span class="title">shmctl</span></span></span><br><span class="line"><span class="class">    - 可以的</span></span><br><span class="line"><span class="class">    - 因为<span class="title">shmctl</span> 标记删除共享内存，不是直接删除</span></span><br><span class="line"><span class="class">    - 什么时候真正删除呢?</span></span><br><span class="line"><span class="class">        当和共享内存关联的进程数为0的时候，就真正被删除</span></span><br><span class="line"><span class="class">    - 当共享内存的<span class="title">key</span>为0的时候，表示共享内存被标记删除了</span></span><br><span class="line"><span class="class">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    共享内存和内存映射的区别</span></span><br><span class="line"><span class="class">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span></span><br><span class="line"><span class="class">    2.共享内存效率更高</span></span><br><span class="line"><span class="class">    3.内存</span></span><br><span class="line"><span class="class">        所有的进程操作的是同一块共享内存（在各自的虚拟地址空间中都一样）</span></span><br><span class="line"><span class="class">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存</span></span><br><span class="line"><span class="class">        <span class="title">shm</span>目的是共享，<span class="title">mmap</span>目的是加快文件访问速度</span></span><br><span class="line"><span class="class">    4.数据安全</span></span><br><span class="line"><span class="class">        - 进程突然退出</span></span><br><span class="line"><span class="class">            共享内存还存在</span></span><br><span class="line"><span class="class">            内存映射区消失</span></span><br><span class="line"><span class="class">        - 运行进程的电脑死机，宕机了</span></span><br><span class="line"><span class="class">            数据存储在共享内存中，就没有了</span></span><br><span class="line"><span class="class">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    5.生命周期</span></span><br><span class="line"><span class="class">        - 内存映射区：进程退出，内存映射区销毁</span></span><br><span class="line"><span class="class">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span></span><br><span class="line"><span class="class">            如果一个进程退出，会自动和共享内存取消关联</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240123172019352.png" alt="image-20240123172019352"></p>
<h2 id="2-9-守护进程"><a href="#2-9-守护进程" class="headerlink" title="2.9 守护进程"></a>2.9 守护进程</h2><p>◼ 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是<strong>Linux 中的后台服务进程</strong>。</p>
<p>它是一个生存期较长的进程，通常<strong>独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</strong>。一般采用以 d 结尾的名字</p>
<p>◼ 守护进程具备下列特征：</p>
<p>​	 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</p>
<p>​	 它在后台运行并且不拥有控制终端。<strong>没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</strong></p>
<p>◼ <strong>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">守护进程创建步骤</span><br><span class="line">1、执行fork（），父进程退出，子进程继续执行</span><br><span class="line">2、子进程调用setsid（）开启一个新会话</span><br><span class="line">3、清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限</span><br><span class="line">4、修改进程的当前工作目录，通常会改为根目录（/）</span><br><span class="line">5、关闭守护进程从其父进程继承来的所有打开着的文件描述符</span><br><span class="line">6、在关闭了文件描述符0、1、2后，守护进程通常会打开/dev/null，并使用dup2（）使所有这些描述符指向这个设备  （所有输入到这个设备的内容都会被丢弃）</span><br><span class="line">7、核心业务逻辑</span><br></pre></td></tr></table></figure>

<h1 id="第三章-Linux多线程开发"><a href="#第三章-Linux多线程开发" class="headerlink" title="第三章  Linux多线程开发"></a>第三章  Linux多线程开发</h1><h2 id="3-1-线程概述"><a href="#3-1-线程概述" class="headerlink" title="3.1 线程概述"></a>3.1 线程概述</h2><p>​	与进程（process）类似，线程（thread）是<strong>允许应用程序并发执行多个任务的一种机制</strong>。<strong>一个进程可以包含多个线程</strong>。</p>
<p>​	同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。</p>
<p>（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p>
<p>◼ <strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p>
<p>◼ 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。</p>
<p>◼ 查看指定进程的 LWP 号：ps –Lf pid</p>
<h3 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h3><p>进程间并未共享内存，需要采用一些进程间通信的方式，在进程间做数据交换；调用fork创建进程开销很大，即使采用写时复制技术，仍需要复制像内存页表和文件描述符表等多种进程属性</p>
<p>线程之间由于共享虚拟地址空间，可以方便快速的共享和传递信息；创建线程不需要复制内存或页表等，比创建进程快10倍以上</p>
<h3 id="线程共享和非共享资源"><a href="#线程共享和非共享资源" class="headerlink" title="线程共享和非共享资源"></a>线程共享和非共享资源</h3><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240124110140579.png" alt="image-20240124110140579"></p>
<img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240124110239309.png" alt="image-20240124110239309" style="zoom:67%;" />

<h2 id="3-2-创建线程"><a href="#3-2-创建线程" class="headerlink" title="3.2 创建线程"></a>3.2 创建线程</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span><br><span class="line">    称之为子线程。</span><br><span class="line">    程序中默认只有一个进程，fork()函数调用，<span class="number">2</span>进行</span><br><span class="line">    程序中默认只有一个线程，pthread_create()函数调用，<span class="number">2</span>个线程。</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params">    <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">        - 功能：创建一个子线程</span><br><span class="line">        - 参数：</span><br><span class="line">            - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span><br><span class="line">            - attr : 设置线程的属性，一般使用默认值，<span class="literal">NULL</span></span><br><span class="line">            - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码  (<span class="type">void</span>* - 万能指针，可以传递任意参数)</span><br><span class="line"> 注：在c++程序中使用pthread_creat时，第<span class="number">3</span>个参数必须指向一个静态函数</span><br><span class="line">            - arg : 给第三个参数使用，传参</span><br><span class="line">             </span><br><span class="line">        - 返回值：</span><br><span class="line">            成功：<span class="number">0</span></span><br><span class="line">            失败：返回错误号errnum。</span><br><span class="line">            这个错误号和之前errno不太一样。</span><br><span class="line">            获取错误号的信息：  <span class="type">char</span> * <span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br><span class="line"></span><br><span class="line">注：编译时需要加 -lpthread (因为线程属于第三方库)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pthread-exit-pthread-self-pthread-equal"><a href="#pthread-exit-pthread-self-pthread-equal" class="headerlink" title="pthread_exit()  pthread_self()  pthread_equal()"></a>pthread_exit()  pthread_self()  pthread_equal()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">    功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span><br><span class="line">    参数：</span><br><span class="line">        retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</span><br><span class="line">      注意返回值不要是局部变量</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    功能：获取当前的线程的线程ID</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">    功能：比较两个线程ID是否相等</span><br><span class="line">    不同的操作系统，<span class="type">pthread_t</span>类型的实现不一样，有的是无符号的长整型，有的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>**retval)</span>;</span><br><span class="line">        - 功能：和一个已经终止的线程进行连接</span><br><span class="line">                回收子线程的资源</span><br><span class="line">             	阻塞函数，调用一次只能回收一个子线程</span><br><span class="line">                一般在主线程中使用</span><br><span class="line">        - 参数：</span><br><span class="line">            - thread：需要回收的子线程的ID</span><br><span class="line">            - retval: 接收子线程退出时的返回值</span><br><span class="line"><span class="type">void</span>** 二级指针： 用二级地址存储一级地址，一级地址指向内存</span><br><span class="line">（如果用一级指针，相当于一个地址指向的内存存储了另一个地址，而不是那个地址指向的内存/内容）</span><br><span class="line">        - 返回值：</span><br><span class="line">            <span class="number">0</span> : 成功</span><br><span class="line">            非<span class="number">0</span> : 失败，返回的错误号</span><br></pre></td></tr></table></figure>

<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line">    - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span><br><span class="line">      <span class="number">1.</span>不能多次分离，会产生不可预料的行为。</span><br><span class="line">      <span class="number">2.</span>不能去连接一个已经分离的线程，会报错。</span><br><span class="line">    - 参数：需要分离的线程的ID</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号</span><br></pre></td></tr></table></figure>

<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel()"></a>pthread_cancel()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：取消线程（让线程终止）</span><br><span class="line">        取消某个线程，可以终止某个线程的运行，</span><br><span class="line">        但并不是立马终止，而是当子线程执行到一个取消点，线程才会终止</span><br><span class="line">        取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点</span><br></pre></td></tr></table></figure>

<h2 id="3-3-线程同步"><a href="#3-3-线程同步" class="headerlink" title="3.3 线程同步"></a>3.3 线程同步</h2><p>◼ 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：<strong>必须确保多个线程不会同时修改同一变量</strong>，或者某一线程不会读取正在由其他线程修改的变量</p>
<p>◼ 临界区是指访问某一共享资源的代码片段，这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应中断该片段的执行</p>
<p>◼ <strong>线程同步：当有一个线程在对内存进行操作时，其他线程都不可以对这个内存进行操作，直到该线程完成操作，其他线程才能对该内存进行操作（其他线程处于等待状态）</strong></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240124224829624.png" alt="image-20240124224829624"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">互斥量的类型 <span class="type">pthread_mutex_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">       - 初始化互斥量</span><br><span class="line">       - 参数 ：</span><br><span class="line">           - mutex ： 需要初始化的互斥量变量</span><br><span class="line">           - attr ： 互斥量相关的属性，<span class="literal">NULL</span></span><br><span class="line">       - <span class="keyword">restrict</span> : C语言的修饰符（被修饰的指针所指向的对象，不能再被另外的指针引用或操作）</span><br><span class="line">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex = xxx;</span><br><span class="line">           <span class="type">pthread_mutex_t</span> * mutex1 = mutex;</span><br><span class="line">	返回值：</span><br><span class="line">           <span class="number">0</span>，成功</span><br><span class="line">		</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 释放互斥量的资源</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 解锁</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>◼ 死锁的几种场景：</p>
<p>​	 忘记释放锁</p>
<p>​	 重复加锁 （常见于调用的两个函数都有加锁动作）</p>
<p>​	 多线程多锁，抢占锁资源</p>
<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件；</li>
<li>持有并等待条件；</li>
<li>不可剥夺条件；</li>
<li>环路等待条件；</li>
</ul>
<h3 id="互斥条件"><a href="#互斥条件" class="headerlink" title="#互斥条件"></a><a href="https://xiaolincoding.com/os/4_process/deadlock.html#%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6">#</a>互斥条件</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁的特点：</p>
<p>​	 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操		作</p>
<p>​	 如果有其它线程写数据，则其它线程都不允许读、写操作</p>
<p>​	 写是独占的，写的优先级高</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">读写锁的类型 <span class="type">pthread_rwlock_t</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   条件变量的类型 <span class="type">pthread_cond_t</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">       - 调用该函数，线程会阻塞，等待唤醒</span><br><span class="line"><span class="comment">// 当这个函数阻塞时，会对互斥锁解锁，当不阻塞时，会重新加锁</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">       - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span><br><span class="line">           </span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">       - 唤醒一个或多个等待（cond_wait）的线程</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">       - 唤醒所有的等待的线程</span><br></pre></td></tr></table></figure>

<p>信号量</p>
<p>为了防止多进程竞争共享资源，使得共享的资源，在任意时刻只能被一个进程访问</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存</p>
<p>信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">信号量的类型 <span class="type">sem_t</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">        - 初始化信号量</span><br><span class="line">        - 参数：</span><br><span class="line">            - sem : 信号量变量的地址</span><br><span class="line">            - pshared : <span class="number">0</span> 用在线程间 ，非<span class="number">0</span> 用在进程间</span><br><span class="line">            - value : 记录信号量中的值</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">        - 释放信号量资源</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">      - 对信号量加锁：调用一次对信号量的值<span class="number">-1</span>，如果值为<span class="number">0</span>，就阻塞</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">        - 对信号量解锁：调用一次对信号量的值+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者消费者模型</span></span><br><span class="line">    <span class="type">sem_t</span> psem;</span><br><span class="line">    <span class="type">sem_t</span> csem;</span><br><span class="line">    init(psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    init(csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    producer() &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        sem_post(&amp;csem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    customer() &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        sem_post(&amp;psem)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-Linux网络编程"><a href="#第四章-Linux网络编程" class="headerlink" title="第四章 Linux网络编程"></a>第四章 Linux网络编程</h1><h2 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h2><p>进程间网络通信的特殊文件类型（本质为内核借助缓冲区形成的伪文件）</p>
<p>上联应用进程，下联网络协议栈</p>
<p>由 IP 地址和端口结合</p>
<p>读写套接字和读写文件的操作一致，多用于网络进程间数据的传递</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>大端字节序：</p>
<ul>
<li>高位存在低地址，低位存在高地址</li>
<li>存放时顺序不变</li>
</ul>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240128114213324.png" alt="image-20240128114213324"></p>
<p>小端字节序：</p>
<ul>
<li>高位存放高地址，低位存放低地址</li>
<li>存放时顺序相反</li>
</ul>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240128114151163.png" alt="image-20240128114151163"></p>
<p>注：大多数机器是小端</p>
<p><strong>如何判断大小端？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> value ; <span class="comment">// 2bytes</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)]; <span class="comment">// char[2]</span></span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>]==<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);  <span class="comment">//高位在低地址处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节序转换函数</strong></p>
<p>不同字节序的主机之间传递数据：统一使用网络字节序–大端</p>
<p>发送端总是将数据转换成大端字节序发送，接受端根据自身情况决定是否需要转换（小端机转换）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序-网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序-主机字节序 </span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序-网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序-主机字节序 </span></span><br></pre></td></tr></table></figure>

<h2 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h2><p>本质是一个结构体，封装IP和端口号等信息（客户端与服务器通信，需要服务器的IP和Port）</p>
<ul>
<li>通用socket地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<p>sa_family 成员</p>
<p>​	用于指定协议类型</p>
<table>
<thead>
<tr>
<th><strong>协议族</strong></th>
<th><strong>地址族</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<p>sa_data 成员</p>
<p>​	用于存放socket地址</p>
<table>
<thead>
<tr>
<th><strong>协议族</strong></th>
<th><strong>地址值含义和长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达到108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16 bit 端口号和 32 bit IPv4 地址，共 6 字节</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID，共 26 字节</td>
</tr>
</tbody></table>
<p>Linux 定义了下面这个新的通用的 socket 地址结构体,这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">	<span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>专用socket地址</li>
</ul>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240131170102250.png" alt="image-20240131170102250"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin_family; <span class="comment">/*__SOCKADDR_COMMON(sin_) */</span></span><br><span class="line">	<span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line">	<span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -<span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ypedef <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure>

<p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</p>
<h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面(传出参数)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure>

<h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">				UDP 		TCP</span><br><span class="line">是否创建连接 		无连接 面向连接</span><br><span class="line">是否可靠 		不可靠 可靠的</span><br><span class="line">连接的对象个数 	一对一、一对多、多对一、多对多 支持一对一</span><br><span class="line">传输的方式 		面向数据报 面向字节流</span><br><span class="line">首部开销 		8个字节 最少20个字节</span><br><span class="line">适用场景 		实时应用（视频会议，直播） 可靠性高的应用（文件传输）</span><br><span class="line"></span><br><span class="line">UDP：面向无连接，不可靠，一对一、一对多和多对多，面向数据报，首部8个字节，适用于实时应用（如视频、直播）</span><br><span class="line">TCP：面向连接，可靠传输、一对一，基于字节流，首部至少20个字节，适用于可靠性高的场景（如文件传输）</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\webserver\image-20240210121918330.png" alt="image-20240210121918330"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//tcp通信流程</span><br><span class="line">服务器端（被动接受）</span><br><span class="line">1、创建一个用于监听的套接字</span><br><span class="line">	-监听：是否有客户端连接</span><br><span class="line">	-fd：该套接字的文件描述符</span><br><span class="line">2、绑定IP和端口号（服务器自己的）</span><br><span class="line">	-客户端发起连接时需要知道这个IP和端口号</span><br><span class="line">3、设置监听，监听的fd开始工作</span><br><span class="line">4、阻塞等待，当有客户端发起连接时解除阻塞；服务器接受客户端的连接，返回一个用于通信的fd套接字</span><br><span class="line">5、通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line">6、通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端（主动建立连接）</span><br><span class="line">1、创建一个用于通信的socket套接字（返回一个fd）</span><br><span class="line">2、连接服务器（指定服务器的IP和端口号）</span><br><span class="line">3、连接建立</span><br><span class="line">	-发送数据</span><br><span class="line">	-接收数据</span><br><span class="line">4、通信结束，断开连接</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>用来控制传输数据的吞吐量，解决发送方发送的数据量太大，而接收方接收的速度较慢，从而导致的丢包问题（实现流量控制、拥塞控制）</p>
<ul>
<li>窗口大小就是接收缓冲区的大小</li>
<li>窗口大小会不断变化</li>
<li>通信双方都有发送缓冲区和接收缓冲区</li>
</ul>
<h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">参数：</span><br><span class="line">- sockfd : 要操作的文件描述符</span><br><span class="line">- level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">- optname : 选项的名称</span><br><span class="line">	- SO_REUSEADDR</span><br><span class="line">	- SO_REUSEPORT</span><br><span class="line">- optval : 端口复用的值（整形）</span><br><span class="line">	- <span class="number">1</span> : 可以复用</span><br><span class="line">	- <span class="number">0</span> : 不可以复用</span><br><span class="line">- optlen : optval参数的大小</span><br><span class="line"></span><br><span class="line">端口复用设置的时机：在服务器绑定端口之前</span><br><span class="line">setsockop（）；</span><br><span class="line">bind（）；</span><br></pre></td></tr></table></figure>

<p>为什么需要端口复用:</p>
<p>​	服务器重启时，之前绑定的<strong>端口还未释放</strong> </p>
<p>​	程序突然退出，而系统没有释放端口</p>
<p>查看网络相关信息</p>
<p>netstat -apn</p>
<p>-a 所有的socket</p>
<p>-p 显示正在使用socket的程序名</p>
<p>-n 直接使用ip地址，而不通过域名服务器</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a><strong>IO多路复用</strong></h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>1 构造一个文件描述符列表（添加将要监听的文件描述符）</p>
<p>2 调用系统函数监听此列表，直到进行IO操作时函数返回</p>
<p>​	a 此函数阻塞</p>
<p>​	b 函数对文件描述符的检测操作由内核完成</p>
<p>3 返回时告诉进程有多少描述符要进行IO操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//sizeof(fd_set) =128字节  1024位</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);</span><br><span class="line">- 参数：</span><br><span class="line">	- nfds ： 需要检测的描述符数量+1</span><br><span class="line">	- readfds : 要检测的读文件描述符集合</span><br><span class="line">	- writefds : 要检测的写文件描述符集合</span><br><span class="line">		一般只检测读操作，对应对方发送过来的数据，传入传出参数</span><br><span class="line">	- exceptfds ：检测发生异常的文件描述符</span><br><span class="line">	- timeout : 设置的超时时间</span><br><span class="line">		struct timeval &#123;</span><br><span class="line">			long tv_sec;	/* seconds */</span><br><span class="line">			long tv_usec;	/* microseconds */</span><br><span class="line">		&#125;</span><br><span class="line">		NULL : 永久阻塞，直到检测到文件描述符变化</span><br><span class="line">		tv_sec = 0 tv_usec = 0 ： 不阻塞</span><br><span class="line">		tv_sec &gt; 0 tv_usec &gt; 0 : 阻塞相应的时间</span><br><span class="line">	- 返回值：</span><br><span class="line">		-1：失败</span><br><span class="line">		 n : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line">// 将fd对应的标志位 置为0</span><br><span class="line">void FD_CLR(int fd,fd_set *set);</span><br><span class="line"></span><br><span class="line">//将fd对应的标志位 置为1</span><br><span class="line">void FD_SET(int fd,fd_set *set);</span><br><span class="line"></span><br><span class="line">//判断fd对应的标志位是0（返回0），还是1（返回1） </span><br><span class="line">int FD_ISSET(int fd, fd_set *set); </span><br><span class="line"></span><br><span class="line">//将fd_set的1024bit，全部初始化为0</span><br><span class="line">void FD_ZERO（fd_set *set）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\webserver\image-20240225123554728.png" alt="image-20240225123554728"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 设置监听文件描述符集合 reads</span></span><br><span class="line">fd_set reads;</span><br><span class="line"><span class="comment">//2 将已建立连接的fd标志位 置1（3，4,100,101）</span></span><br><span class="line">FD_SET(<span class="number">3</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">4</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">100</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">101</span>,&amp;reads);</span><br><span class="line"></span><br><span class="line">select(<span class="number">101</span> +<span class="number">1</span> ,&amp;reads,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="number">3</span> 将reads从用户态拷贝到内核态</span><br><span class="line"><span class="number">4</span> 在内核中遍历reads，看哪些fd为<span class="number">1</span>，并检测这些fd是否有数据</span><br><span class="line"><span class="number">5</span> 如果没有数据，重新将其置为<span class="number">0</span>，有数据仍保持<span class="number">1</span></span><br><span class="line"><span class="number">6</span> 将reads从内核态拷贝回用户态</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span> 在用户态遍历哪些fd为<span class="number">1</span>，说明有数据可读（有事件发生）</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    read.../recv...</span><br><span class="line">&#125;</span><br><span class="line">判断是否为<span class="number">1</span></span><br><span class="line">    FD_ISSET(<span class="number">3</span>,&amp;reads);</span><br><span class="line"><span class="number">100</span>断开连接</span><br><span class="line">    FD_CLR(<span class="number">100</span>,&amp;reads);</span><br></pre></td></tr></table></figure>

<p>注：内核对传入的文件描述符表全部遍历，只有判断值为1的才会去检测这个文件描述符是否有数据</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240225144746090.png" alt="image-20240225144746090"></p>
<p>select的缺点：</p>
<p>1.每次调用select，都需要把fd集合从用 户态拷贝到内核态，这个开销在fd很多时 会很大 </p>
<p>2.同时每次调用select都需要在内核遍历 传递进来的所有fd，这个开销在fd很多时 也很大 </p>
<p>3.select支持的文件描述符数量太小了， 默认是1024 </p>
<p>4.fds集合不能重用，每次都需要重置</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><img src="D:\Blog\source_posts\webserver\image-20240225155110793.png" alt="image-20240225155110793"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">	<span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line">举例：</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">	myfd.fd = <span class="number">5</span>;</span><br><span class="line">	myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- fds : <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>结构体数组，需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">		- <span class="title">nfds</span> :</span> fds数组中最大有效元素的索引 + <span class="number">1</span></span><br><span class="line">		- timeout : 阻塞时长</span><br><span class="line">			<span class="number">0</span> : 不阻塞</span><br><span class="line">			<span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">			&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">	- 返回值：	</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure>

<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，<strong>取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制</strong>，当然还会受到系统文件描述符限制。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="D:\Blog\source_posts\webserver\image-20240225164741522.png" alt="image-20240225164741522"></p>
<p>epoll通过两个方面，很好的解决了select&#x2F;poll的问题</p>
<p>1 epoll在内核里使用<strong>红黑树</strong>来跟踪进程所有待检测的文件描述符，把需要监控的socket通过<strong>epoll_ctl(</strong>)函数加入内核的红黑树中（a.增删改高效，O（logn）b.减少了内核和用户态之间的数据拷贝和内存分配）</p>
<p>2 epoll是<strong>事件驱动机制</strong>，<strong>内核里维护一个链表来记录就绪事件</strong>，当某个socket有事件发生时，通过回调函数将其加入到就绪事件列表中（当用户调用epoll_wait()函数时，只返回有事件发生的文件描述符的个数）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发生改变的文件描述符的信息（双向链表）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">	size : 目前没有意义了，随便写一个大于<span class="number">0</span>的数</span><br><span class="line">- 返回值：</span><br><span class="line">	<span class="number">-1</span> : 失败</span><br><span class="line">	&gt; <span class="number">0</span> : 文件描述符，用来操作epoll实例</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,<span class="type">int</span> op,<span class="type">int</span> fd,<span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">-参数 ：</span><br><span class="line">    - epfd：epoll_create的返回值，epoll实例对应的文件描述符</span><br><span class="line">    - op ：需要进行的操作</span><br><span class="line">    	EPOLL_CTL_ADD: 添加</span><br><span class="line">        EPOLL_CTL_MOD: 修改</span><br><span class="line">        EPOLL_CTL_DEL: 删除</span><br><span class="line">    - fd : 要检测的文件描述符</span><br><span class="line">    - event : 检测文件描述符什么事情</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">        <span class="type">void</span>  *ptr;</span><br><span class="line">        <span class="type">int</span>  fd;</span><br><span class="line">        <span class="type">uint32_t</span> u32</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">    &#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">	- EPOLLIN</span><br><span class="line">	- EPOLLOUT</span><br><span class="line">	- EPOLLERR</span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">	- epfd : epoll实例对应的文件描述符</span><br><span class="line">	- events : 传出参数，保存了发生变化的文件描述符的信息</span><br><span class="line">	- maxevents : 第二个参数结构体数组的大小</span><br><span class="line">	- timeout : 阻塞时间</span><br><span class="line">		 <span class="number">0</span> : 不阻塞</span><br><span class="line">		 <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">		 &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">- 返回值：</span><br><span class="line">	- 成功，返回发生变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">    - 失败，返回 <span class="number">-1</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>Epoll 的工作模式：</p>
<p> LT 模式 （水平触发）</p>
<p> 假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知 </p>
<p>​	a.用户不读数据，数据一直在缓冲区，epoll 会一直通知</p>
<p>​	 b.用户只读了一部分数据，epoll会通知 </p>
<p>​	c.缓冲区的数据读完了，不通知 </p>
<p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这 种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操 作。如果你不作任何操作，内核还是会继续通知你的。</p>
<p>ET 模式（边沿触发） </p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p>
<p> a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</p>
<p> b.用户只读了一部分数据，epoll不通知</p>
<p> c.缓冲区的数据读完了，不通知 </p>
<p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述 符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成 未就绪），内核不会发送更多的通知（only once）。 </p>
<p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写 操作把处理多个文件描述符的任务饿死。</p>
<h1 id="第五章-项目实战"><a href="#第五章-项目实战" class="headerlink" title="第五章 项目实战"></a>第五章 项目实战</h1><h2 id="阻塞和非阻塞、同步-异步"><a href="#阻塞和非阻塞、同步-异步" class="headerlink" title="阻塞和非阻塞、同步&#x2F;异步"></a>阻塞和非阻塞、同步&#x2F;异步</h2><p><img src="D:\Blog\source_posts\webserver\阻塞、非阻塞、同步、异步.png" alt="阻塞、非阻塞、同步、异步"></p>
<p>同步io和异步io：本质是针对用户区层面而言的，阻塞io和非阻塞io都是同步io，当使用aio_read（）函数才是异步io；从数据角度看，同步io需要等待数据从内核拷贝到用户，异步io完全不需要等待，全程由内核自动完成，应用程序不需要主动发起拷贝动作</p>
<p>阻塞io：阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程<br>非阻塞io：不需要等待「内核数据准备好」，但需要等待「数据从内核态拷贝到用户态」</p>
<p>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。</p>
<h2 id="Unix-Linux上的五种IO模型"><a href="#Unix-Linux上的五种IO模型" class="headerlink" title="Unix&#x2F;Linux上的五种IO模型"></a>Unix&#x2F;Linux上的五种IO模型</h2><p>1 阻塞 blocking</p>
<p>2 非阻塞 non-blocking</p>
<p>3 IO复用 IO multiplexing</p>
<p>4 信号驱动 signal-driven</p>
<p>​	Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进 程收到SIGIO 信号，然后处理 IO 事件。</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240226220202694.png" alt="image-20240226220202694"></p>
<p>​	内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需 要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。 </p>
<p>5 异步 asynchronous</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240226220315579.png" alt="image-20240226220315579"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> aio_fildes; <span class="comment">/* File desriptor. */</span></span><br><span class="line">	<span class="type">int</span> aio_lio_opcode; <span class="comment">/* Operation to be performed. */</span></span><br><span class="line">	<span class="type">int</span> aio_reqprio; <span class="comment">/* Request priority offset. */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">void</span> *aio_buf; <span class="comment">/* Location of buffer. */</span></span><br><span class="line">	<span class="type">size_t</span> aio_nbytes; <span class="comment">/* Length of transfer. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* Signal number and value. */</span></span><br><span class="line">	<span class="comment">/* Internal members. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> *__<span class="title">next_prio</span>;</span></span><br><span class="line">	<span class="type">int</span> __abs_prio;</span><br><span class="line">	<span class="type">int</span> __policy;</span><br><span class="line">	<span class="type">int</span> __error_code;</span><br><span class="line">	<span class="type">__ssize_t</span> __return_value;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">	<span class="type">__off_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line">	<span class="type">char</span> __pad[<span class="keyword">sizeof</span> (<span class="type">__off64_t</span>) - <span class="keyword">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">__off64_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>工作原理</p>
<p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客 户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方 法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版 本、成功或者错误代码、服务器信息、响应头部和响应数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下是 HTTP 请求/响应的步骤：</span><br><span class="line">1. 客户端连接到 Web 服务器</span><br><span class="line">一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接</span><br><span class="line">字连接。例如，http://www.baidu.com。（URL）</span><br><span class="line">2. 发送 HTTP 请求</span><br><span class="line">通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求</span><br><span class="line">头部、空行和请求数据 4 部分组成。</span><br><span class="line">3. 服务器接受请求并返回 HTTP 响应</span><br><span class="line">Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个</span><br><span class="line">响应由状态行、响应头部、空行和响应数据 4 部分组成。</span><br><span class="line">4. 释放连接 TCP 连接</span><br><span class="line">若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连</span><br><span class="line">接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</span><br><span class="line">5. 客户端浏览器解析 HTML 内容</span><br><span class="line">客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应</span><br><span class="line">头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据</span><br><span class="line">HTML 的语法对其进行格式化，并在浏览器窗口中显示。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在浏览器地址栏键入URL，按下回车之后会经历以下流程：</span><br><span class="line">1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</span><br><span class="line">2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</span><br><span class="line">3. 浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三</span><br><span class="line">次握手的第三个报文的数据发送给服务器;</span><br><span class="line">4. 服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</span><br><span class="line">5. 释放 TCP 连接;</span><br><span class="line">6. 浏览器将该 HTML 文本并显示内容。</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\webserver\image-20240226232931128.png" alt="image-20240226232931128"><img src="D:\Blog\source_posts\webserver\image-20240226232940914.png" alt="image-20240226232940914"></p>
<p>HTTP请求方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副</span><br><span class="line">作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访</span><br><span class="line">问。</span><br><span class="line">2. HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文</span><br><span class="line">部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该</span><br><span class="line">资源的信息”（元信息或称元数据）。</span><br><span class="line">3. POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含</span><br><span class="line">在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</span><br><span class="line">4. PUT：向指定资源位置上传其最新内容。</span><br><span class="line">5. DELETE：请求服务器删除 Request-URI 所标识的资源。</span><br><span class="line">6. TRACE：回显服务器收到的请求，主要用于测试或诊断。</span><br><span class="line">7. OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用&#x27;*&#x27;来代替资源名称，</span><br><span class="line">向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</span><br><span class="line">8. CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服</span><br><span class="line">务器的链接（经由非加密的 HTTP 代理服务器）。</span><br></pre></td></tr></table></figure>

<h2 id="reactor和proactor"><a href="#reactor和proactor" class="headerlink" title="reactor和proactor"></a>reactor和proactor</h2><p>服务器程序通常需要处理三类事件：IO、信号、定时</p>
<p>有两种高效的事件处理模式：Reactor和Proactor</p>
<p>同步IO模型实现Reactor，异步IO模型实现Proactor</p>
<p>reactor：主线程只负责监听，有事件就立即通知工作线程，将socket事件放入请求队列，交给工作线程处理。读写数据、接受新连接以及处理事件都在工作线程中完成。</p>
<p>proactor：所有IO操作都交给主线程和内核来处理（包括读和写），工作线程仅负责业务逻辑。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>将每个定时事件分别封装成定时器，并使用某种容器类数据结构， 比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理</p>
<p>Linux提供了三种定时方法，它们是：</p>
<p> ❑socket选项SO_RCVTIMEO和SO_SNDTIMEO</p>
<p>❑SIGALRM信号</p>
<p>❑I&#x2F;O复用系统调用的超时参数</p>
<h3 id="socket选项SO-RCVTIMEO和-SO-SNDTIMEO"><a href="#socket选项SO-RCVTIMEO和-SO-SNDTIMEO" class="headerlink" title="socket选项SO_RCVTIMEO和 SO_SNDTIMEO"></a>socket选项SO_RCVTIMEO和 SO_SNDTIMEO</h3><p>设置socket接收数据超时时间和发送数据超时时间</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240303162229015.png" alt="image-20240303162229015"></p>
<p>根据系统调用（send、 sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断 超时时间是否已到，进而决定是否开始处理定时任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec=time;</span><br><span class="line">    timeout.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(timeout);</span><br><span class="line">    ret = setsockopt(sockfd,SOL_SOCKET,SO_SNDTIMEO,&amp;timeout,len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINPROGRESS)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; connecting timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SIGALARM信号"><a href="#SIGALARM信号" class="headerlink" title="SIGALARM信号"></a>SIGALARM信号</h3><p>由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来处理定时任务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="D:\Blog\source_posts\webserver\discuss_1682656246568.jpeg" alt="discuss_1682656246568"></p>
<p>Linux下有三种IO复用方式：epoll，select和poll，为什么用epoll，它和其他两个有什么区别呢？（参考StackOverflow上的一个问题：<a href="https://stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select">Why is epoll faster than select?</a>）</p>
<p><strong>文件描述符的添加地点、存储方式，检测事件发生的工作方式、文件描述符的操作模式（LT和ET模式）</strong></p>
<ul>
<li>对于select和poll来说，所有文件描述符都是<strong>在用户态被加入</strong>其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；<strong>epoll则将整个文件描述符集合维护在内核态</strong>，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，由于这些大量的系统调用开销epoll可能会慢于select和poll。</li>
<li><strong>select使用线性表</strong>描述文件描述符集合，文件描述符有上限；<strong>poll使用链表</strong>来描述；<strong>epoll底层通过红黑树</strong>来描述，并且<strong>维护一个ready list</strong>，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。</li>
<li>select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，<strong>当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符</strong>，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。</li>
<li>select和poll都只能工作在相对低效的LT模式下，而<strong>epoll同时支持LT和ET模式。</strong></li>
<li>综上，当监测的<strong>fd数量较小</strong>，且<strong>各个fd都很活跃的情况</strong>下，建议<strong>使用****select和poll</strong>；当监听的<strong>fd数量较</strong>多，且单位时间仅<strong>部分fd活跃</strong>的情况下，<strong>使用epoll</strong>会明显提升性能。</li>
</ul>
<p>c++程序中使用pthread_creat时，该函数的第3个参数必须指向一个静态函数</p>
<p>当调用一个对象的成员函数（非静态成员函数）时，系统会把该对象的起始地址赋给成员函数的this指针，非静态成员函数实际上都是包含了调用他们对象的this指针，经编译器优化，变为： void *worker(this，void *args); 线程函数worker函数形式规定为 void *worker(void *args)，少了this，所以必须为静态函数。而静态成员函数因为不属于某一个对象，和任何对象无关，所以没有this指针。</p>
<hr>
<h1 id="linux高性能服务器编程（游双）笔记"><a href="#linux高性能服务器编程（游双）笔记" class="headerlink" title="linux高性能服务器编程（游双）笔记"></a>linux高性能服务器编程（游双）笔记</h1><p><strong>服务器主要有两种并发编程模式：半同步&#x2F;半异步（half-sync&#x2F;halfasync）模式和领导者&#x2F;追随者（Leader&#x2F;Followers）模</strong></p>
<p><strong>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指 的是程序的执行需要由系统事件来驱动</strong>（中断、信号等）</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240303130817904.png" alt="image-20240303130817904"></p>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
  </entry>
</search>
