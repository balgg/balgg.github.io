<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TCP可靠传输机制</title>
    <url>/2024/01/13/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>发送数据时设定一个定时器，在规定时间内没有收到对方的ACK，就重发该数据</p>
<p>两种情况触发</p>
<ul>
<li>数据包丢失（接收方没有收到数据）</li>
<li>ACK丢失（发送方没有收到ACK）</li>
</ul>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong></p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时的间隔加倍。</strong></p>
<p>问题：超时周期可能相对较长</p>
<p>解决：快速重传</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>不以时间为驱动，而是以数据为驱动</p>
<p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段</p>
<p>（第一个报文丢失，后续发送过来的报文都回复同样的ACK）</p>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109095831996.png" alt="image-20240109095831996" style="zoom: 67%;" />

<p>问题：发送方不清楚重传的时候，是重传一个（seq2），还是重传所有（因为后续接收方都回ACK2，不知道seq3、4、5报文是否也丢失）</p>
<p>解决：SACK方法</p>
<h2 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h2><p><code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong></p>
<p>实现：在TCP头部【选项】字段加一个SACK，它可以将已收到的数据信息发给发送方（发送方知道了哪些数据没收到，就只重传丢失的数据）</p>
<h2 id="D-SACK方法"><a href="#D-SACK方法" class="headerlink" title="D-SACK方法"></a>D-SACK方法</h2><p><strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong></p>
<p>应用于两个场景：</p>
<ul>
<li>ACK丢包</li>
<li>网络延时</li>
</ul>
<p>区分上面两种（第一种发送方没有收到ACK，第二种发送方连续收到重复ACK）</p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul>
<li><p>引入原因：</p>
<p>TCP是每发一个数据，都要一次确认应答，上一个数据包收到应答后，再发送下一个。数据包的往返时间越长，通信效率越低。</p>
</li>
<li><p>窗口：实质是操作系统开辟的一个缓存空间（发送方）</p>
<p>（收到确认应答前，在缓存空间中保留已发送的数据，如果按期收到确认应答，就将数据从缓存空间清除）</p>
</li>
<li><p>窗口大小：无需等待确认应答，而可以继续发送数据的最大值</p>
</li>
<li><p>累计确认：后面的ACK可以确认前面的数据已被接收，即使前一个ACK丢失也没关系</p>
</li>
</ul>
<p>窗口大小由哪一方决定？</p>
<p>​	接收方</p>
<p>​	因为发送方发送的数据大小不能超过接收方的窗口大小，否则接收方会处理不过来导致丢包</p>
<p>​	TCP有一个Window字段，是接收端告诉发送端自己还有多少缓冲区可以接收数据</p>
<p><img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109105354734.png" alt="image-20240109105354734"></p>
<p><strong>注：发送窗口&lt;&#x3D;接收窗口</strong></p>
<h2 id="缓存区与滑动窗口的关系"><a href="#缓存区与滑动窗口的关系" class="headerlink" title="缓存区与滑动窗口的关系"></a>缓存区与滑动窗口的关系</h2><p>如果发生了先减少缓存，再收缩窗口，<strong>就会出现丢包的现象</strong></p>
<p>*<em>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</em></p>
<h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<p>如果通告窗口非0的 ACK 报文在网络中丢失，会造成死锁（双方都在等待对方发送数据）</p>
<p>解决：<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><p>现象：接收方腾出几个字节就立即告诉发送方窗口有几个空闲的位置，发送方会义无反顾地发送这几个字节。</p>
<p>（头部开销很大，实际传输数据量很小）</p>
<p>糊涂窗口综合症的现象发生在发送方和接收方：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>发送方可以发送小数据</li>
</ul>
<p>解决：</p>
<ul>
<li><p>发送方使用Nagle算法，满足以下条件之一才可以发送数据</p>
<ul>
<li>条件1：窗口大小&gt;&#x3D;MSS 且 可发送的数据大小&gt;&#x3D;MSS</li>
<li>条件2：收到之前发送数据的 <code>ack</code> 回包</li>
</ul>
</li>
<li><p>接收方的 窗口大小 &gt;&#x3D; MSS 或 缓存空间有一半可以使用，再通知发送方窗口大小非0</p>
</li>
</ul>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p><strong>避免「发送方」的数据填满整个网络</strong></p>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个状态变量，<strong>它会根据网络的拥塞程度动态变化的</strong></p>
<p>发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值</p>
<p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<p>拥塞控制四种算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>TCP 在刚建立连接完成后，首先是有个【慢启动】的过程，这个慢启动的意思就是<strong>一点一点的提高发送数据包的数量</strong></p>
<p>规则：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</strong>（<strong>指数性的增长</strong>）</p>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109171932406.png" alt="image-20240109171932406" style="zoom:80%;" />

<p>发包数量不能无限增长，什么时候停止呢？</p>
<p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用【拥塞避免算法】。</li>
</ul>
<h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法</p>
<p>规则：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd</strong></p>
<p>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109172659680.png" alt="image-20240109172659680" style="zoom: 67%;" />

<p>一直增长，网络慢慢进入拥堵状态，出现丢包，<strong>触发重传机制，进入【拥塞发生算法】</strong></p>
<h2 id="拥塞发生算法"><a href="#拥塞发生算法" class="headerlink" title="拥塞发生算法"></a>拥塞发生算法</h2><p>【超时重传时的拥塞发生算法】</p>
<ul>
<li>慢启动门限ssthresh 设为 拥塞窗口cwnd的1&#x2F;2（<code>ssthresh=cwnd/2</code>）</li>
<li>cwnd 初始化</li>
</ul>
<img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109173748452.png" alt="image-20240109173748452" style="zoom: 80%;" />

<p>【快速重传时的拥塞发生算法】</p>
<ul>
<li><code>ssthresh = cwnd/2</code> </li>
<li><code>cwnd = ssthresh</code></li>
<li>进入<strong>快速恢复算法</strong></li>
</ul>
<h2 id="快速恢复算法"><a href="#快速恢复算法" class="headerlink" title="快速恢复算法"></a>快速恢复算法</h2><p>快速重传和快速恢复算法一般同时使用</p>
<ul>
<li>让拥塞窗口 <code> cwnd=ssthresh+3</code>  (3 的意思是确认有 3 个数据包被收到了–三次重复ACK)</li>
<li>重传丢失的数据包</li>
<li>如果再收到重复的ACK，那么cwnd增加1（说明此时又有别的数据包被收到了，跟前面+3一个道理）</li>
<li>当收到新数据的ACK，令<code> cwnd=ssthresh</code>（恢复过程结束，再次进入【拥塞避免状态】）</li>
</ul>
<p><img src="C:\Users\baiaolong\AppData\Roaming\Typora\typora-user-images\image-20240109175652172.png" alt="image-20240109175652172"></p>
<p>注：<strong>cwnd逐渐加1</strong>的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2024/01/13/HTTP/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>超文本传输协议（在计算机世界里专门在 <strong>两点之间</strong> 传输 <strong>文字、图片、音频和视频</strong>等超文本数据的 <strong>约定和规范</strong>）</p>
<h1 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h1><p><img src="https://uploader.shimo.im/f/dceIyQvRA2nAilEW.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzIzNDIsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjA0MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.NfcEh5GsSntz9PTzP3GrthIzXWPCldkTU6OjdZZnaQg" alt="img"></p>
<ul>
<li>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
<li><code>5xx</code> 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</li>
</ul>
<h1 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h1><p><em><strong>Host字段</strong></em></p>
<p>客户端发送请求时，用来指定服务器的域名（有了Host字段，就可以将请求发往同一服务器上的不同网站）</p>
<p><img src="https://uploader.shimo.im/f/tyCeIwo1lZOxMVNm.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI1MTMsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjIxMywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.Mf2LO68QOLRs2BaQvz7qySMRZ0J_KpRSFomzwGdIGno" alt="img"></p>
<p><em><strong>Content-Length 字段</strong></em></p>
<p>服务器在返回数据时，表明本次回应的数据长度</p>
<p>（作为 HTTP body 的边界解决“粘包”的问题）</p>
<p><img src="https://uploader.shimo.im/f/k7FAQCMKrQvYNloJ.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI1NjIsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjI2MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.VC6_SMgF0TFgPhXOGsh1SXS2SNdtxkatnuA-KyiUkpw" alt="img"></p>
<p><em><strong>Connection 字段</strong></em></p>
<p>常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用（HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。）</p>
<p><img src="https://uploader.shimo.im/f/PAHYAqxJxFdgS3U7.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI2MTYsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjMxNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.LATFDsceK3vgmPduHDFQvR4t00zRwCO585x_U6CCVf8" alt="img"></p>
<p><em><strong>Content-Type 字段</strong></em></p>
<p>服务器响应时，告诉客户端本次数据的格式</p>
<p><img src="https://uploader.shimo.im/f/21X8kwthQKqlesUX.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI2MzUsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjMzNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.Ha4t5SgwHyigXeiwDBCIA9hPkSXQJv3HnifD4QFa8dk" alt="img"></p>
<p><em><strong>Content-Encoding 字段</strong></em></p>
<p>说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p>
<p><img src="https://uploader.shimo.im/f/OYDSteGj2OhMvUKP.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI2NTAsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjM1MCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.O1xD5FnzBj4K790bCIWggZYYd2d8SBY7DwZzhjtbtlg" alt="img"></p>
<h1 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h1><p>GET 的语义是从服务器获取指定的资源</p>
<p><img src="https://uploader.shimo.im/f/vGs0nvTdg9acDNrE.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI3MDQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjQwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0._UloSkNApzUSUoOv7aMbhpXb95nk081theBjcRpAvbU" alt="img"></p>
<p><img src="https://uploader.shimo.im/f/vGs0nvTdg9acDNrE.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI3MDQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjQwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0._UloSkNApzUSUoOv7aMbhpXb95nk081theBjcRpAvbU" alt="img">POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</p>
<p><img src="https://uploader.shimo.im/f/MS9cZKUxBnbrpJc5.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzI3MDQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczMjQwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0._UloSkNApzUSUoOv7aMbhpXb95nk081theBjcRpAvbU" alt="img"></p>
<ul>
<li><p><strong>GET对数据长度有限制</strong>（因为URL的限制），POST无限制</p>
</li>
<li><p><strong>GET只允许 ASCII 字符</strong>，<strong>POST无限制</strong></p>
</li>
<li><p><strong>GET安全</strong>（不修改服务器资源，只读）、<strong>幂等</strong>（重复操作结果相同）、<strong>可被缓存</strong>；<strong>POST不安全</strong>（修改服务器数据），<strong>不幂等</strong>，（大部分实现）<strong>不可缓存</strong></p>
</li>
<li><p><strong>GET 显示在 URL 上，POST 通过表单提交不显示在 URL 上</strong></p>
<p>（有敏感数据使用POST，但并不能说 GET 不如 POST 安全，因为HTTP 传输的内容都是明文的，要避免传输过程中数据被窃取，就要使用 HTTPS ，这样所有 HTTP 的数据都会被加密传输）</p>
</li>
</ul>
<p>注：get请求可以带body（通常不需要所以才不带）</p>
<h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>强制缓存和协商缓存</p>
<p><strong>强制缓存</strong>：</p>
<p>​	只要<strong>浏览器判断</strong>缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<p>利用下面这两个 HTTP 响应头部（Response Header）字段实现</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p><strong>协商缓存</strong>：</p>
<p>​	<strong>与服务端协商</strong>之后，通过协商结果来判断是否使用本地缓存</p>
<p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<h1 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h1><p>常见到版本有 HTTP&#x2F;1.1，HTTP&#x2F;2.0，HTTP&#x2F;3.0</p>
<p><strong>HTTP&#x2F;1.1</strong></p>
<ul>
<li>优点：<ul>
<li>简单（报文格式header+body）</li>
<li>灵活和易于扩展（HTTPS、HTTP&#x2F;2.0、HTTP&#x2F;3.0）</li>
<li>应用广泛和跨平台（台式机上的浏览器到各种手机app）</li>
</ul>
</li>
<li>缺点：<ul>
<li>无状态（双刃剑）—服务器不会去记忆 HTTP 的状态<ul>
<li>优点：不需要额外资源记录，减轻服务器负担</li>
<li>缺点：完成有关联性的操作时很麻烦（购物每次都要认证身份）<ul>
<li>解决方式： Cookie 技术（在请求和响应报文中写入 Cookie 信息来控制客户端的状态）。客户端第一次请求后，会保存服务器在响应中添加的cookie，再次请求时服务器就会检查cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://uploader.shimo.im/f/29V0Jb1dmNHZp6Hg.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3MzQ2MDUsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzczNDMwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.RquSuhiCxSxVNmXVGgTUAJtrLr29lrIuNbYDx60VeiM" alt="img"></p>
<ul>
<li>明文传输（双刃剑）<ul>
<li>方便调试，抓包可直接查看</li>
<li>信息裸奔</li>
</ul>
</li>
<li>不安全<ul>
<li>可以用 HTTPS 方式解决，引入SSL&#x2F;TLS层</li>
</ul>
</li>
</ul>
<p>性能方面：基于 TCP&#x2F;IP，并且使用了「请求 - 应答」的通信模式，采用长连接，减少了TCP连接的重复建立和断开的额外开销，减轻服务器的负载（HTTP1.0是短连接）</p>
<h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><h2 id="有哪些区别？"><a href="#有哪些区别？" class="headerlink" title="有哪些区别？"></a>有哪些区别？</h2><ul>
<li>HTTPS 更安全，解决了HTTP明文传输的缺陷，在TCP和HTTP之间加入了SSL&#x2F;TLS安全协议，使报文能加密传输</li>
<li>HTTPS在三次握手后，还需要进行SSL&#x2F;TLS的握手过程</li>
<li>HTTP端口号80，HTTPS端口号443</li>
<li>HTTPS需要申请数字证书（保证服务器身份可信）</li>
</ul>
<h2 id="HTTPS解决了HTTP哪些问题？"><a href="#HTTPS解决了HTTP哪些问题？" class="headerlink" title="HTTPS解决了HTTP哪些问题？"></a>HTTPS解决了HTTP哪些问题？</h2><p>1）通过<strong>混合加密</strong>方式，实现信息机密性，防止被窃听</p>
<p>​	非对称加密（公钥和私钥）–通信建立前</p>
<p>​	对称加密（一个密钥）–通信过程中</p>
<p>2）通过<strong>摘要算法+数字签名</strong>的校验机制，防止数据被篡改</p>
<p>​	摘要算法：比对哈希值</p>
<p>​	数字签名：非对称加密（私钥加密，公钥解密）</p>
<p>3）通过<strong>数字证书</strong>的身份认证机制，防止被冒充</p>
<p>​	将公钥放在CA数字证书中，保证公钥身份可靠</p>
<h2 id="HTTPS一定安全可靠吗？"><a href="#HTTPS一定安全可靠吗？" class="headerlink" title="HTTPS一定安全可靠吗？"></a>HTTPS一定安全可靠吗？</h2><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的。</strong></p>
<p>存在这种情况：如果有假基站将信息转发给【中间人服务器】，客户端和【中间人】完成TLS握手，【中间人】和服务器完成TLS握手，中间人不就能获取全部信息？</p>
<p>理论上可以，但前提是在TLS握手时，客户端的用户要点击继续访问【中间人】伪造的证书，因为浏览器是能够识别出【中间人】伪造的证书是非法的，会提醒用户。</p>
<p><strong>如何避免被【中间人抓取数据】？</strong></p>
<p>不中病毒（被恶意导入了中间人的根证书）；不点击任何证书非法网站；采用HTTPS双向认证（增加了服务端对客户端的验证）</p>
<h1 id="HTTP1-1-HTTP2-HTTP3-的优化"><a href="#HTTP1-1-HTTP2-HTTP3-的优化" class="headerlink" title="HTTP1.1 HTTP2 HTTP3 的优化"></a>HTTP1.1 HTTP2 HTTP3 的优化</h1><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p><strong>HTTP1.1</strong>相比HTTP1.0的改进：</p>
<ul>
<li>长连接：减少短连接的性能开销</li>
<li>管道网络传输：可以连续发送请求，不用等待响应后再发送（解决了请求的队头阻塞，但仍然有响应的队头阻塞问题）</li>
</ul>
<p>缺陷（性能瓶颈）：</p>
<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送</li>
<li>队头阻塞</li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端发出，服务器只能被动响应</li>
</ul>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><ul>
<li><p>基于HTTPS，安全性较高</p>
</li>
<li><p>头部压缩：HPACK算法</p>
</li>
<li><p>二进制格式：（原先是纯文本形式）提高了数据传输效率</p>
</li>
<li><p>并发传输：stream（多个stream复用一个TCP连接）</p>
</li>
<li><p>服务器可主动推送资源</p>
<p>缺陷：</p>
<p>HTTP2基于 TCP 协议来传输数据，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，因此，当TCP层出现丢包，需要等待重传，就还会出现<strong>队头阻塞</strong>问题</p>
</li>
</ul>
<h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><p>把 HTTP 下层的 TCP 协议改成了 <strong>UDP</strong></p>
<p>基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输</p>
<p>（QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议）</p>
<p>QUIC 有以下 3 个特点</p>
<ul>
<li><strong>无队头阻塞</strong>：stream相互独立</li>
<li><strong>更快的连接建立</strong>：QUIC的三次握手（内部包含了TLS）取代了 TCP三次握手+TLS1.2四次握手  （TLS1.3三次握手）</li>
<li><strong>连接迁移</strong>：通过连接 ID 来标记通信的两个端点（TCP是四元组）</li>
</ul>
<p><img src="https://uploader.shimo.im/f/TsETyOBpdpZXySxB.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM3NDIxOTQsImZpbGVHVUlEIjoiTjJBMWdPZzFNTXRXdzRxRCIsImlhdCI6MTcwMzc0MTg5NCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjozMDIwMDA3NH0.yrEY353STJ43LXfT7h7U7Fr5bRKQ6igZvuCzKnz5lVE" alt="img"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2024/02/11/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯法都可以抽象为N叉树</p>
<p>模版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例: 输入: n &#x3D; 4, k &#x3D; 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</p>
<p>本质：二叉搜索树</p>
<p><img src="D:\Blog\source_posts\算法\image-20240212002404360.png" alt="image-20240212002404360"></p>
<p>每次从集合中选取一个元素，集合大小随之收缩</p>
<p>​	n相当于树的宽度，也就是for循环几次</p>
<p>​	k相当于树的深度，也就是递归几次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//递归函数的返回值和参数</span></span><br><span class="line">	std::vector&lt; std::vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">backtracing</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//终止条件</span></span><br><span class="line">		<span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123; <span class="comment">//如果path中的元素数量为k，说明获取到一个结果</span></span><br><span class="line">			res.<span class="built_in">push_back</span>(path);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//单层搜索</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">			path.<span class="built_in">push_back</span>(i);<span class="comment">//选取一个元素</span></span><br><span class="line">			<span class="built_in">backtracing</span>(n, k, i + <span class="number">1</span>);<span class="comment">//排除选取的元素，并递归选取剩下的元素</span></span><br><span class="line">			<span class="comment">//回溯</span></span><br><span class="line">			path.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)&#123;</span><br><span class="line">		<span class="built_in">backtracing</span>(n, k, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剪枝优化：</p>
<p>如果for循环起始位置后面的元素个数，已经不够选择了，就没必要继续搜索了</p>
<ul>
<li>已经选择的元素个数：path.size()</li>
<li>还需要选择的元素个数：k-path.size()</li>
<li>如果剩余元素个数小于k-path.size()，就剪枝<ul>
<li>当遍历到n-（k-path.size())+1时</li>
</ul>
</li>
</ul>
<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    std::vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracing</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum +=i;</span><br><span class="line">            <span class="built_in">backtracing</span>(k,n,i+<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//回溯</span></span><br><span class="line">            sum-=i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracing</span>(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//数字和字母映射关系--二维数组</span></span><br><span class="line">    <span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> std::string &amp;digits,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">length</span>()==digits.<span class="built_in">length</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> digit=digits[index]-<span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 字符串转数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:letterMap[digit])&#123; </span><br><span class="line">            path.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="built_in">backtracking</span>(digits,index+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>linux高性能并发服务器</title>
    <url>/2023/12/27/webserver/</url>
    <content><![CDATA[<h1 id="第一章-Linux系统编程"><a href="#第一章-Linux系统编程" class="headerlink" title="第一章 Linux系统编程"></a>第一章 Linux系统编程</h1><h2 id="1-gcc"><a href="#1-gcc" class="headerlink" title="1 gcc"></a>1 gcc</h2><h2 id="2-静态库"><a href="#2-静态库" class="headerlink" title="2 静态库"></a>2 静态库</h2><h2 id="3-动态库"><a href="#3-动态库" class="headerlink" title="3 动态库"></a>3 动态库</h2><h2 id="4-静态库和动态库对比"><a href="#4-静态库和动态库对比" class="headerlink" title="4 静态库和动态库对比"></a>4 静态库和动态库对比</h2><h2 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5 Makefile"></a>5 Makefile</h2><h2 id="6-GDB"><a href="#6-GDB" class="headerlink" title="6 GDB"></a>6 GDB</h2><h2 id="7-文件io"><a href="#7-文件io" class="headerlink" title="7 文件io"></a>7 文件io</h2><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240102210431160.png" alt="image-20240102210431160"></p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 打开一个已经存在的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment">     参数：</span></span><br><span class="line"><span class="comment">            - pathname：要打开的文件路径</span></span><br><span class="line"><span class="comment">            - flags：对文件的操作权限设置还有其他的设置</span></span><br><span class="line"><span class="comment">            O_RDONLY,  O_WRONLY,  O_RDWR  </span></span><br><span class="line"><span class="comment">            (这三个设置是互斥的)</span></span><br><span class="line"><span class="comment">     返回值：返回一个新的文件描述符，如果调用失败，返回-1</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    void perror(const char *s);</span></span><br><span class="line"><span class="comment">    作用：打印errno对应的错误描述</span></span><br><span class="line"><span class="comment">    s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 创建一个新的文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  ...读写操作</span></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    标准C库的函数</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Linux系统函数</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">            - offset：偏移量</span></span><br><span class="line"><span class="comment">            - whence:</span></span><br><span class="line"><span class="comment">                SEEK_SET</span></span><br><span class="line"><span class="comment">                    设置文件指针的偏移量（通过offset指定大小）：起始位置+offset</span></span><br><span class="line"><span class="comment">                SEEK_CUR</span></span><br><span class="line"><span class="comment">                    设置偏移量：当前位置 + offset</span></span><br><span class="line"><span class="comment">                SEEK_END</span></span><br><span class="line"><span class="comment">                    设置偏移量：文件结尾 + offset</span></span><br><span class="line"><span class="comment">        返回值：返回文件指针的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">        1.移动文件指针到文件头</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.获取当前文件指针的位置</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.获取文件长度</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment">        lseek(fd, 100, SEEK_END)</span></span><br><span class="line"><span class="comment">        注意：需要写一次数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="stat-lstat"><a href="#stat-lstat" class="headerlink" title="stat lstat"></a>stat lstat</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.txt -&gt; b.txt 软链接</span></span><br><span class="line"><span class="comment">lstat获取a.txt的信息，stat获取b.txt的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>struct stat *statbuf 结构体</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240102210455881.png" alt="image-20240102210455881"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240102210505511.png" alt="image-20240102210505511"></p>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int access(const char *pathname, int mode);</span></span><br><span class="line"><span class="comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 判断的文件路径</span></span><br><span class="line"><span class="comment">            - mode:</span></span><br><span class="line"><span class="comment">                R_OK: 判断是否有读权限</span></span><br><span class="line"><span class="comment">                W_OK: 判断是否有写权限</span></span><br><span class="line"><span class="comment">                X_OK: 判断是否有执行权限</span></span><br><span class="line"><span class="comment">                F_OK: 判断文件是否存在</span></span><br><span class="line"><span class="comment">        返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        修改文件的权限</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - mode:需要修改的权限值，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">        作用：缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - path: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - length: 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用：创建一个目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="chdir-getcwd"><a href="#chdir-getcwd" class="headerlink" title="chdir getcwd"></a>chdir getcwd</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            path : 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span></span><br><span class="line"><span class="comment">            - size: 数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">           返回指向的一块内存(就是第一个参数buf)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="opendir-readdir-closedir"><a href="#opendir-readdir-closedir" class="headerlink" title="opendir readdir closedir"></a>opendir readdir closedir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型，理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup  dup2"></a>dup  dup2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup(int oldfd);</span></span><br><span class="line"><span class="comment">        作用：复制一个新的文件描述符</span></span><br><span class="line"><span class="comment">        fd=3, int fd1 = dup(fd),</span></span><br><span class="line"><span class="comment">        fd指向的是a.txt, fd1也指向a.txt</span></span><br><span class="line"><span class="comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符(例如fd1=4)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">	int dup2(int oldfd,int newfd);</span></span><br><span class="line"><span class="comment">	作用：重定向文件描述符（将newfd指向oldfd指向的文件）</span></span><br><span class="line"><span class="comment">	注：oldfd-&gt;a,txt  newfd-&gt;b.txt</span></span><br><span class="line"><span class="comment">	调用函数 int fd3 = dup2(oldfd,newfd)</span></span><br><span class="line"><span class="comment">    	newfd和b.txt先close 然后newfd-&gt;a.txt</span></span><br><span class="line"><span class="comment">    （oldfd必须是一个有效的文件描述符）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    返回值：fd3=newfd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int fcntl(int fd, int cmd, ...);</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        fd : 表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment">        cmd: 表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">                int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_SETFL : 设置文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span></span><br><span class="line"><span class="comment">              可选性：O_APPEND, O)NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                NONBLOK 设置成非阻塞</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        阻塞和非阻塞：描述的是函数调用的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="第二章-Linux多进程开发"><a href="#第二章-Linux多进程开发" class="headerlink" title="第二章 Linux多进程开发"></a>第二章 Linux多进程开发</h1><h2 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h2><p>程序是包含一系列信息的文件（信息用来描述如何创建进程）</p>
<p>进程是正在运行的程序的实例（程序不占用内存和cpu）</p>
<p>时间片由操作系统内核的调度程序分配给进程</p>
<p>（注：熟悉进程调度算法）</p>
<p>并行：同时执行</p>
<p>并发：交替执行</p>
<p>PCB进程控制块：task__struct 结构体</p>
<ul>
<li>​	进程id：pid_t类型，系统中每个进程唯一的id</li>
<li>​	进程状态：就绪、运行、挂起、停止等</li>
<li>​	进程切换时需要保存和恢复的cpu寄存器</li>
<li>​	描述虚拟地址空间的信息</li>
<li>​	描述控制终端的信息</li>
<li>​	当前工作目录</li>
<li>​	umask掩码</li>
<li>​	文件描述符表（包含很多指向file结构体的指针）</li>
<li>​	信号相关的信息</li>
<li>​	用户id和组id</li>
<li>​	会话（session）和进程组</li>
<li>​	进程可以使用的资源上限</li>
</ul>
<h2 id="2-2-进程状态转换"><a href="#2-2-进程状态转换" class="headerlink" title="2.2 进程状态转换"></a>2.2 进程状态转换</h2><p>三态：就绪、运行、阻塞</p>
<p>五态：新建、就绪、运行、阻塞、终止</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240104213546429.png" alt="image-20240104213546429"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240104213555696.png" alt="image-20240104213555696"></p>
<ul>
<li>查看进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux / ajx</span><br><span class="line">a：显示终端上所有进程</span><br><span class="line">u：显示进程详细信息</span><br><span class="line">x：显示没有控制终端的进程</span><br><span class="line">j：列出与作业控制相关的信息</span><br></pre></td></tr></table></figure>

<ul>
<li>实时显示进程动态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">M 根据内存使用量排序 </span><br><span class="line">P 根据 CPU 占有率排序</span><br><span class="line">T 根据进程运行时间长短排序</span><br><span class="line">U 根据用户名来筛选进程</span><br><span class="line">K 输入指定的 PID 杀死进程</span><br></pre></td></tr></table></figure>

<ul>
<li>杀死进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill [-signal] pid</span><br><span class="line">kill –l 列出所有信号</span><br><span class="line">kill –SIGKILL 进程ID</span><br><span class="line">kill -9 进程ID</span><br><span class="line">killall name 根据进程名杀死进程</span><br></pre></td></tr></table></figure>

<p>**◼ **每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p>◼ 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。</p>
<p>◼ 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。</p>
<p>◼ 进程号和进程组相关函数：</p>
<p>pid_t getpid(void);</p>
<p>pid_t getppid(void);</p>
<p>pid_t getpgid(pid_t pid);</p>
<h2 id="2-3-进程创建"><a href="#2-3-进程创建" class="headerlink" title="2.3 进程创建"></a>2.3 进程创建</h2><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t fork(void);</span><br><span class="line">	返回值：</span><br><span class="line">		成功：子进程中返回0，父进程中返回子进程ID</span><br><span class="line">		失败：返回-1</span><br><span class="line">	失败原因：</span><br><span class="line">		1、当前系统进程数已达上限，errno=EAGAIN</span><br><span class="line">		2、系统内存不足，errno=ENOMEM</span><br></pre></td></tr></table></figure>

<h2 id="2-4-父子进程虚拟地址空间"><a href="#2-4-父子进程虚拟地址空间" class="headerlink" title="2.4  父子进程虚拟地址空间"></a>2.4  父子进程虚拟地址空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父子进程之间的关系：</span><br><span class="line">   区别：</span><br><span class="line">       1.fork()函数的返回值不同</span><br><span class="line">            父进程中: &gt;0 返回的子进程的ID</span><br><span class="line">            子进程中: =0</span><br><span class="line">       2.pcb中的一些数据</span><br><span class="line">            当前的进程的id pid</span><br><span class="line">            当前的进程的父进程的id ppid</span><br><span class="line">             信号集</span><br><span class="line">    共同点：</span><br><span class="line">       某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="line">            - 用户区的数据一样</span><br><span class="line">            - 文件描述符表一样</span><br><span class="line">        </span><br><span class="line">  父子进程对变量是不是共享的？</span><br><span class="line"> - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="line"> - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。（COW）</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span><br><span class="line">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span><br><span class="line">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span><br><span class="line">只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自独立的地址空间。</span><br><span class="line">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span><br><span class="line">注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享 文件偏移指针。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="2-5-GDB多进程调试"><a href="#2-5-GDB多进程调试" class="headerlink" title="2.5 GDB多进程调试"></a>2.5 GDB多进程调试</h2><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240106151123719.png" alt="image-20240106151123719"></p>
<h2 id="2-6-exec函数族"><a href="#2-6-exec函数族" class="headerlink" title="2.6 exec函数族"></a>2.6 exec函数族</h2><p>作用：调用可执行文件，取代进程后续的内容</p>
<p>调用成功不返回（因为原代码已被替换为可执行文件的内容，没有exec这行代码了）</p>
<p>调用失败返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int execl(const char * path,const char *arg, ...);</span><br><span class="line">        - 参数：</span><br><span class="line">            - path:需要指定的执行的文件的路径或者名称</span><br><span class="line">                a.out /home/nowcoder/a.out 推荐使用绝对路径</span><br><span class="line">                ./a.out hello world</span><br><span class="line"></span><br><span class="line">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">                参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">            如果调用成功，没有返回值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> int execlp(const char *file, const char *arg, ... );</span><br><span class="line">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="line">        - 参数：</span><br><span class="line">            - file:需要执行的可执行文件的文件名</span><br><span class="line">                a.out</span><br><span class="line">                ps</span><br><span class="line"></span><br><span class="line">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="line">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="line">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="line">                参数最后需要以NULL结束（哨兵）</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="line">            如果调用成功，没有返回值。</span><br><span class="line">            </span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">        argv是需要的参数的一个字符串数组</span><br><span class="line">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span><br><span class="line">        execv(&quot;/bin/ps&quot;, argv);</span><br><span class="line">        </span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240107140312527.png" alt="image-20240107140312527"></p>
<p>有p或e：传文件名，否则传路径</p>
<p>e：自定义去哪些环境变量中查找</p>
<p>v：用参数数组写入参数</p>
<p>l：直接写入参数，以null结尾</p>
<h2 id="2-7-进程控制"><a href="#2-7-进程控制" class="headerlink" title="2.7 进程控制"></a>2.7 进程控制</h2><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240107150011858.png" alt="image-20240107150011858"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;hello\n&quot;);</span><br><span class="line">	printf(&quot;world&quot;);</span><br><span class="line">	</span><br><span class="line">	exit(0); // 标准c库，会刷新缓冲区 打印 hello world</span><br><span class="line">	_exit(0);// 系统调用，不会刷新缓冲区  打印 hello （\n会刷新缓冲区） </span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status的值代表进程退出状态，可以被wait或waitpid捕获</span><br></pre></td></tr></table></figure>

<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>◼ <strong>父进程先运行结束，但子进程还在运行，这样的子进程就称为孤儿进程</strong>（Orphan Process）。</p>
<p>◼ 每当出现一个孤儿进程，<strong>内核就把孤儿进程的父进程设为 init ， init 进程会循环地 wait() 这些孤儿进程。</strong>这样，当一个孤儿进程结束了其生命周期的时候，init 进程就会处理它的一切善后工作</p>
<p>◼ 因此孤儿进程并不会有什么危害</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，但内核区的 PCB 没有办法自己释放掉，需要父进程去释放</p>
<p>◼ <strong>子进程先终止</strong>，如果父进程尚未回收，子进程残留的资源（PCB）存放于内核中，变成僵尸（Zombie）进程</p>
<p>◼ <strong>僵尸进程不能被 kill -9 杀死</strong>，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是<strong>系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程</strong>，此为僵尸进程的危害，应当避免</p>
<p>解决方法：</p>
<ol>
<li>终止父进程，让子进程被init进程回收（企业中已运行，不能终止）</li>
<li>在父进程中调用wait或waitpid（常用）</li>
</ol>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>◼ 在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件、占用的内存等。</p>
<p>但是仍然为其保留一定的信息，这些信息主要是进程控制块PCB的信息（包括进程号、退出状态、运行时间等）</p>
<p>◼ 父进程可以通过调用wait或waitpid得到它的退出状态，同时彻底清除掉这个进程</p>
<p>◼ wait() 和 waitpid() 函数的功能一样，区别在于，<strong>wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束</strong></p>
<p>◼ <strong>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环</strong></p>
<h3 id="wait（）"><a href="#wait（）" class="headerlink" title="wait（）"></a>wait（）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t wait(int *wstatus);</span><br><span class="line">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span><br><span class="line">        参数：int *wstatus</span><br><span class="line">            进程退出时的状态信息，传入的是一个int类型的地址，将状态赋给这个参数 （传出参数）</span><br><span class="line">            可以为NULL，表示不获取子进程退出状态</span><br><span class="line">        返回值：</span><br><span class="line">            - 成功：返回被回收的子进程的id</span><br><span class="line">            - 失败：-1 (所有的子进程都已结束/调用函数失败)</span><br><span class="line"></span><br><span class="line">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="line">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240107165037885.png" alt="image-20240107165037885"></p>
<h3 id="waitpid（）"><a href="#waitpid（）" class="headerlink" title="waitpid（）"></a>waitpid（）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/wait.h&gt;</span><br><span class="line">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="line">        参数：</span><br><span class="line">            - pid:</span><br><span class="line">                pid &gt; 0 : 某个子进程的pid</span><br><span class="line">                pid = 0 : 回收当前进程组中的任意一个子进程    </span><br><span class="line">                pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）</span><br><span class="line">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="line">            - options：设置阻塞或者非阻塞</span><br><span class="line">                0 : 阻塞</span><br><span class="line">                WNOHANG : 非阻塞</span><br><span class="line">            - 返回值：</span><br><span class="line">                &gt; 0 : 返回子进程的id</span><br><span class="line">                = 0 : options=WNOHANG时, 表示还有子进程</span><br><span class="line">                = -1 ：错误或者没有子进程了</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="2-8-进程间通信IPC"><a href="#2-8-进程间通信IPC" class="headerlink" title="2.8 进程间通信IPC"></a>2.8 进程间通信IPC</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p><strong><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122133916483.png" alt="image-20240122133916483"></strong></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>在内核内存中维护的缓冲器</li>
<li>拥有文件的特质：读操作、写操作</li>
<li>匿名管道没有文件实体，有名管道有文件实体,但不存储数据</li>
<li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少</li>
<li>传递的数据是顺序的</li>
<li>传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的</li>
<li>读数据是一次性操作,在管道中无法使用 lseek() 来随机的访问数据</li>
<li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◼ 创建匿名管道</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">◼ 查看管道缓冲大小命令</span><br><span class="line">ulimit –a</span><br><span class="line">◼ 查看管道缓冲大小函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">long fpathconf(int fd, int name);</span><br><span class="line">/*</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    int pipe(int pipefd[2]);</span><br><span class="line">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="line">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="line">            pipefd[0] 对应的是管道的读端</span><br><span class="line">            pipefd[1] 对应的是管道的写端</span><br><span class="line">        返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1</span><br><span class="line"></span><br><span class="line">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="line"></span><br><span class="line">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">获取管道大小：fpathconf（）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">◼ 通过命令创建有名管道</span><br><span class="line">mkfifo 名字</span><br><span class="line">◼ 通过函数创建有名管道</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    创建fifo文件</span><br><span class="line">    1.通过命令：mkfifo 名字</span><br><span class="line">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/stat.h&gt;</span><br><span class="line">    int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">        参数：</span><br><span class="line">            - pathname: 管道名称的路径</span><br><span class="line">            - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="line">                    是一个八进制的数</span><br><span class="line">        返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中</li>
<li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用</li>
<li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信</li>
</ol>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122134521469.png" alt="image-20240122134521469"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◼ #include &lt;sys/mman.h&gt;</span><br><span class="line">◼ void *mmap(void *addr, size_t length, int prot, int flags, </span><br><span class="line">int fd, off_t offset);</span><br><span class="line">◼ int munmap(void *addr, size_t length);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/mman.h&gt;</span><br><span class="line">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">        - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="line">        - 参数：</span><br><span class="line">            - void *addr: NULL, 由内核指定</span><br><span class="line">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="line">                    获取文件的长度：stat lseek</span><br><span class="line">            - prot : 对申请的内存映射区的操作权限</span><br><span class="line">                -PROT_EXEC ：可执行的权限</span><br><span class="line">                -PROT_READ ：读权限</span><br><span class="line">                -PROT_WRITE ：写权限</span><br><span class="line">                -PROT_NONE ：没有权限</span><br><span class="line">                要操作映射内存，必须要有读的权限。</span><br><span class="line">                PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="line">            - flags :</span><br><span class="line">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="line">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="line">            - fd: 需要映射的那个文件的文件描述符</span><br><span class="line">                - 通过open得到，open的是一个磁盘文件</span><br><span class="line">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="line">                    prot: PROT_READ                open:只读/读写 </span><br><span class="line">                    prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="line">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移</span><br><span class="line">        - 返回值：返回创建的内存的首地址</span><br><span class="line">            失败返回MAP_FAILED，(void *) -1</span><br><span class="line"></span><br><span class="line">    int munmap(void *addr, size_t length);</span><br><span class="line">        - 功能：释放内存映射</span><br><span class="line">        - 参数：</span><br><span class="line">            - addr : 要释放的内存的首地址</span><br><span class="line">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    使用内存映射实现进程间通信：</span><br><span class="line">    1.有关系的进程（父子进程）</span><br><span class="line">        - 还没有子进程的时候</span><br><span class="line">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="line">        - 有了内存映射区以后，创建子进程</span><br><span class="line">        - 父子进程共享创建的内存映射区</span><br><span class="line">    </span><br><span class="line">    2.没有关系的进程间通信</span><br><span class="line">        - 准备一个大小不是0的磁盘文件</span><br><span class="line">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="line">            - 得到一个操作这块内存的指针</span><br><span class="line">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="line">            - 得到一个操作这块内存的指针</span><br><span class="line">        - 使用内存映射区通信</span><br><span class="line"></span><br><span class="line">    注意：内存映射区通信，是非阻塞。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>事件发生时对进程的通知机制</li>
<li>软件中断，异步通信</li>
</ul>
<p>引发内核为进程产生信号的各类事件如下：</p>
<p> 对于<strong>前台进程，用户可以通过输入特殊的终端字符来给它发送信号</strong>。比如输入Ctrl+C 通常会给进程发送一个中断信号。</p>
<p> <strong>硬件发生异常，即硬件检测到一个错误条件并通知内</strong>核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</p>
<p> <strong>系统状态变化，比如 alarm 定时器到期</strong>将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。</p>
<p> <strong>运行 kill 命令或调用 kill 函数</strong></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145712118.png" alt="image-20240122145712118"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145720598.png" alt="image-20240122145720598"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145731979.png" alt="image-20240122145731979"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145740191.png" alt="image-20240122145740191"></p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122145750661.png" alt="image-20240122145750661"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号的 5 种默认处理动作</span><br><span class="line">◼ 查看信号的详细信息：man 7 signal</span><br><span class="line">◼ 信号的5种默认处理动作</span><br><span class="line">	 Term 终止进程</span><br><span class="line">	 Ign 当前进程忽略掉这个信号</span><br><span class="line">	 Core 终止进程，并生成一个Core文件</span><br><span class="line">	 Stop 暂停当前进程</span><br><span class="line">	 Cont 继续执行当前被暂停的进程</span><br><span class="line">◼ 信号的几种状态：产生、未决、递达</span><br><span class="line">◼ SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</span><br></pre></td></tr></table></figure>

<p>kill、raise、alarm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*  </span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">    int kill(pid_t pid, int sig);</span><br><span class="line">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="line">        - 参数：</span><br><span class="line">            - pid ：</span><br><span class="line">                &gt; 0 : 将信号发送给指定的进程</span><br><span class="line">                = 0 : 将信号发送给当前的进程组</span><br><span class="line">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="line">                &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="line">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="line"></span><br><span class="line">        kill(getppid(), 9);</span><br><span class="line">        kill(getpid(), 9);</span><br><span class="line">        </span><br><span class="line">    int raise(int sig);</span><br><span class="line">        - 功能：给当前进程发送信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - sig : 要发送的信号</span><br><span class="line">        - 返回值：</span><br><span class="line">            - 成功 0</span><br><span class="line">            - 失败 非0</span><br><span class="line">        kill(getpid(), sig);   </span><br><span class="line"></span><br><span class="line">    void abort(void);</span><br><span class="line">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="line">        kill(getpid(), SIGABRT);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>定时器alarm</p>
<p>函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALRM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    unsigned int alarm(unsigned int seconds);</span><br><span class="line">        - 功能：设置定时器（闹钟）。</span><br><span class="line">        - 参数：</span><br><span class="line">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="line">           取消一个定时器，通过alarm(0)。</span><br><span class="line">        - 返回值：</span><br><span class="line">            - 之前没有定时器，返回0</span><br><span class="line">            - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="line"></span><br><span class="line">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="line">        alarm(10);  -&gt; 返回0</span><br><span class="line">        过了1秒</span><br><span class="line">        alarm(5);   -&gt; 返回9</span><br><span class="line">        </span><br><span class="line">    alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    实际的时间 = 内核时间 + 用户时间 + 消耗的时间</span><br><span class="line">    进行文件IO操作的时候比较浪费时间</span><br><span class="line">    定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>定时器setitimer</p>
<p>函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALRM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;sys/time.h&gt;</span><br><span class="line">    int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</span><br><span class="line">    - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="line">    - 参数：</span><br><span class="line">       - which : 定时器以什么时间计时</span><br><span class="line">      ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用</span><br><span class="line">      ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="line">      ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="line">      - new_value: 设置定时器的属性</span><br><span class="line">      		struct itimerval &#123;      // 定时器的结构体</span><br><span class="line">                struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="line">                struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="line">                &#125;;</span><br><span class="line">            struct timeval &#123;        // 时间的结构体</span><br><span class="line">                 time_t      tv_sec;     //  秒数     </span><br><span class="line">                 suseconds_t tv_usec;    //  微秒    </span><br><span class="line">                &#125;;</span><br><span class="line">      过10秒后，每个2秒定时一次</span><br><span class="line">       - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="line">       - 返回值：</span><br><span class="line">            成功 0</span><br><span class="line">            失败 -1 并设置错误号</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>信号捕捉函数signal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    typedef void (*sighandler_t)(int);</span><br><span class="line">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">        - 功能：设置某个信号的捕捉行为</span><br><span class="line">        - 参数：</span><br><span class="line">            - signum: 要捕捉的信号</span><br><span class="line">            - handler: 捕捉到信号要如何处理</span><br><span class="line">                - SIG_IGN ： 忽略信号</span><br><span class="line">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="line">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="line">                回调函数：</span><br><span class="line">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="line">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="line">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="line"></span><br><span class="line">        - 返回值：</span><br><span class="line">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="line">            失败，返回SIG_ERR，设置错误号</span><br><span class="line">            </span><br><span class="line">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>信号捕捉函数sigaction</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line">    - 功能：检查或者改变信号的处理（信号捕捉）</span><br><span class="line">    - 参数：</span><br><span class="line">        - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="line">        - act ：捕捉到信号之后的处理动作</span><br><span class="line">        - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递<span class="literal">NULL</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功 <span class="number">0</span></span><br><span class="line">        失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">    <span class="type">void</span>  (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不常用</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">    <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 被废弃掉了</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>信号集</p>
<p>​	未决信号集、阻塞信号集（内核使用位图机制实现）</p>
<p>​	操作系统不允许我们直接对这两个信号集进行位操作，而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改</p>
<p>​	多个同样的信号到来时，只能记录一个未决信号或阻塞信号（不支持排队）</p>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240122181743080.png" alt="image-20240122181743080"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号集相关函数</span><br><span class="line">/*</span><br><span class="line">    以下信号集相关的函数都是对自定义的信号集进行操作。</span><br><span class="line">    int sigemptyset(sigset_t *set);</span><br><span class="line">        - 功能：清空信号集中的数据,将信号集中的所有标志位 置0</span><br><span class="line">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigfillset(sigset_t *set);</span><br><span class="line">        - 功能：将信号集中的所有的标志位置为1</span><br><span class="line">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigaddset(sigset_t *set, int signum);</span><br><span class="line">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：传出参数，需要操作的信号集</span><br><span class="line">            - signum：需要设置阻塞的那个信号</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigdelset(sigset_t *set, int signum);</span><br><span class="line">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：传出参数，需要操作的信号集</span><br><span class="line">            - signum：需要设置不阻塞的那个信号</span><br><span class="line">        - 返回值：成功返回0， 失败返回-1</span><br><span class="line"></span><br><span class="line">    int sigismember(const sigset_t *set, int signum);</span><br><span class="line">        - 功能：判断某个信号是否阻塞</span><br><span class="line">        - 参数：</span><br><span class="line">            - set：需要操作的信号集</span><br><span class="line">            - signum：需要判断的那个信号</span><br><span class="line">        - 返回值：</span><br><span class="line">            1 ： signum被阻塞</span><br><span class="line">            0 ： signum不阻塞</span><br><span class="line">            -1 ： 失败</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>sigprocmask</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">操作内核中的信号集</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"></span><br><span class="line">   - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="line">     参数：</span><br><span class="line">     - how : 如何对内核阻塞信号集进行处理</span><br><span class="line">       SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="line">           假设内核中默认的阻塞信号集是mask， mask | <span class="built_in">set</span></span><br><span class="line">       SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="line">           mask &amp;= ~<span class="built_in">set</span></span><br><span class="line">       SIG_SETMASK:覆盖内核中原来的值</span><br><span class="line"></span><br><span class="line">     - <span class="built_in">set</span> ：已经初始化好的用户自定义的信号集</span><br><span class="line">     - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 <span class="literal">NULL</span></span><br><span class="line">          - 返回值：</span><br><span class="line">            成功：<span class="number">0</span></span><br><span class="line">            失败：<span class="number">-1</span></span><br><span class="line">            设置错误号：EFAULT、EINVAL</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sigpending(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">   - 功能：获取内核中的未决信号集</span><br><span class="line">     ：<span class="built_in">set</span>,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240123131458814.png" alt="image-20240123131458814"></p>
<p>SIGCHLD信号</p>
<p>◼ SIGCHLD信号产生的条件</p>
<p>​	 子进程终止时</p>
<p>​	 子进程接收到 SIGSTOP 信号停止时</p>
<p>​	 子进程处在停止态，接受到SIGCONT后唤醒时</p>
<p>◼ 以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>1、调用shmget（）创建或获取一个共享内存段</p>
<p>2、调用shmat（）附上该共享内存段</p>
<p>3、调用shmdt（）分离共享内存段</p>
<p>4、调用shmctl（）删除共享内存段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识（新创建的内存段中的数据都会被初始化为<span class="number">0</span>）</span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  </span><br><span class="line">        失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line">    - 功能：对共享内存进行操作。主要用来删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁对共享内存没有任何影响</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁（所有进程都标记销毁，共享内存才会销毁）</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">    - 功能：根据指定的 路径名和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体<span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> 这个结构体中有一个成员 <span class="title">shm_nattch</span></span></span><br><span class="line"><span class="class">    - <span class="title">shm_nattach</span> 记录了关联的进程个数</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">问题2：可不可以对共享内存进行多次删除 <span class="title">shmctl</span></span></span><br><span class="line"><span class="class">    - 可以的</span></span><br><span class="line"><span class="class">    - 因为<span class="title">shmctl</span> 标记删除共享内存，不是直接删除</span></span><br><span class="line"><span class="class">    - 什么时候真正删除呢?</span></span><br><span class="line"><span class="class">        当和共享内存关联的进程数为0的时候，就真正被删除</span></span><br><span class="line"><span class="class">    - 当共享内存的<span class="title">key</span>为0的时候，表示共享内存被标记删除了</span></span><br><span class="line"><span class="class">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    共享内存和内存映射的区别</span></span><br><span class="line"><span class="class">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span></span><br><span class="line"><span class="class">    2.共享内存效率更高</span></span><br><span class="line"><span class="class">    3.内存</span></span><br><span class="line"><span class="class">        所有的进程操作的是同一块共享内存（在各自的虚拟地址空间中都一样）</span></span><br><span class="line"><span class="class">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存</span></span><br><span class="line"><span class="class">        <span class="title">shm</span>目的是共享，<span class="title">mmap</span>目的是加快文件访问速度</span></span><br><span class="line"><span class="class">    4.数据安全</span></span><br><span class="line"><span class="class">        - 进程突然退出</span></span><br><span class="line"><span class="class">            共享内存还存在</span></span><br><span class="line"><span class="class">            内存映射区消失</span></span><br><span class="line"><span class="class">        - 运行进程的电脑死机，宕机了</span></span><br><span class="line"><span class="class">            数据存储在共享内存中，就没有了</span></span><br><span class="line"><span class="class">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    5.生命周期</span></span><br><span class="line"><span class="class">        - 内存映射区：进程退出，内存映射区销毁</span></span><br><span class="line"><span class="class">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span></span><br><span class="line"><span class="class">            如果一个进程退出，会自动和共享内存取消关联</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240123172019352.png" alt="image-20240123172019352"></p>
<h2 id="2-9-守护进程"><a href="#2-9-守护进程" class="headerlink" title="2.9 守护进程"></a>2.9 守护进程</h2><p>◼ 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是<strong>Linux 中的后台服务进程</strong>。</p>
<p>它是一个生存期较长的进程，通常<strong>独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</strong>。一般采用以 d 结尾的名字</p>
<p>◼ 守护进程具备下列特征：</p>
<p>​	 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</p>
<p>​	 它在后台运行并且不拥有控制终端。<strong>没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</strong></p>
<p>◼ <strong>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">守护进程创建步骤</span><br><span class="line">1、执行fork（），父进程退出，子进程继续执行</span><br><span class="line">2、子进程调用setsid（）开启一个新会话</span><br><span class="line">3、清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限</span><br><span class="line">4、修改进程的当前工作目录，通常会改为根目录（/）</span><br><span class="line">5、关闭守护进程从其父进程继承来的所有打开着的文件描述符</span><br><span class="line">6、在关闭了文件描述符0、1、2后，守护进程通常会打开/dev/null，并使用dup2（）使所有这些描述符指向这个设备  （所有输入到这个设备的内容都会被丢弃）</span><br><span class="line">7、核心业务逻辑</span><br></pre></td></tr></table></figure>

<h1 id="第三章-Linux多线程开发"><a href="#第三章-Linux多线程开发" class="headerlink" title="第三章  Linux多线程开发"></a>第三章  Linux多线程开发</h1><h2 id="3-1-线程概述"><a href="#3-1-线程概述" class="headerlink" title="3.1 线程概述"></a>3.1 线程概述</h2><p>​	与进程（process）类似，线程（thread）是<strong>允许应用程序并发执行多个任务的一种机制</strong>。<strong>一个进程可以包含多个线程</strong>。</p>
<p>​	同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。</p>
<p>（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p>
<p>◼ <strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong></p>
<p>◼ 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。</p>
<p>◼ 查看指定进程的 LWP 号：ps –Lf pid</p>
<h3 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h3><p>进程间并未共享内存，需要采用一些进程间通信的方式，在进程间做数据交换；调用fork创建进程开销很大，即使采用写时复制技术，仍需要复制像内存页表和文件描述符表等多种进程属性</p>
<p>线程之间由于共享虚拟地址空间，可以方便快速的共享和传递信息；创建线程不需要复制内存或页表等，比创建进程快10倍以上</p>
<h3 id="线程共享和非共享资源"><a href="#线程共享和非共享资源" class="headerlink" title="线程共享和非共享资源"></a>线程共享和非共享资源</h3><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240124110140579.png" alt="image-20240124110140579"></p>
<img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240124110239309.png" alt="image-20240124110239309" style="zoom:67%;" />

<h2 id="3-2-创建线程"><a href="#3-2-创建线程" class="headerlink" title="3.2 创建线程"></a>3.2 创建线程</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span><br><span class="line">    称之为子线程。</span><br><span class="line">    程序中默认只有一个进程，fork()函数调用，<span class="number">2</span>进行</span><br><span class="line">    程序中默认只有一个线程，pthread_create()函数调用，<span class="number">2</span>个线程。</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params">    <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">        - 功能：创建一个子线程</span><br><span class="line">        - 参数：</span><br><span class="line">            - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span><br><span class="line">            - attr : 设置线程的属性，一般使用默认值，<span class="literal">NULL</span></span><br><span class="line">            - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码  (<span class="type">void</span>* - 万能指针，可以传递任意参数)</span><br><span class="line">            - arg : 给第三个参数使用，传参</span><br><span class="line">        - 返回值：</span><br><span class="line">            成功：<span class="number">0</span></span><br><span class="line">            失败：返回错误号errnum。</span><br><span class="line">            这个错误号和之前errno不太一样。</span><br><span class="line">            获取错误号的信息：  <span class="type">char</span> * <span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br><span class="line"></span><br><span class="line">注：编译时需要加 -lpthread (因为线程属于第三方库)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pthread-exit-pthread-self-pthread-equal"><a href="#pthread-exit-pthread-self-pthread-equal" class="headerlink" title="pthread_exit()  pthread_self()  pthread_equal()"></a>pthread_exit()  pthread_self()  pthread_equal()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">    功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span><br><span class="line">    参数：</span><br><span class="line">        retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</span><br><span class="line">      注意返回值不要是局部变量</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    功能：获取当前的线程的线程ID</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">    功能：比较两个线程ID是否相等</span><br><span class="line">    不同的操作系统，<span class="type">pthread_t</span>类型的实现不一样，有的是无符号的长整型，有的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>**retval)</span>;</span><br><span class="line">        - 功能：和一个已经终止的线程进行连接</span><br><span class="line">                回收子线程的资源</span><br><span class="line">             	阻塞函数，调用一次只能回收一个子线程</span><br><span class="line">                一般在主线程中使用</span><br><span class="line">        - 参数：</span><br><span class="line">            - thread：需要回收的子线程的ID</span><br><span class="line">            - retval: 接收子线程退出时的返回值</span><br><span class="line"><span class="type">void</span>** 二级指针： 用二级地址存储一级地址，一级地址指向内存</span><br><span class="line">（如果用一级指针，相当于一个地址指向的内存存储了另一个地址，而不是那个地址指向的内存/内容）</span><br><span class="line">        - 返回值：</span><br><span class="line">            <span class="number">0</span> : 成功</span><br><span class="line">            非<span class="number">0</span> : 失败，返回的错误号</span><br></pre></td></tr></table></figure>

<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line">    - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span><br><span class="line">      <span class="number">1.</span>不能多次分离，会产生不可预料的行为。</span><br><span class="line">      <span class="number">2.</span>不能去连接一个已经分离的线程，会报错。</span><br><span class="line">    - 参数：需要分离的线程的ID</span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：<span class="number">0</span></span><br><span class="line">        失败：返回错误号</span><br></pre></td></tr></table></figure>

<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel()"></a>pthread_cancel()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">    - 功能：取消线程（让线程终止）</span><br><span class="line">        取消某个线程，可以终止某个线程的运行，</span><br><span class="line">        但并不是立马终止，而是当子线程执行到一个取消点，线程才会终止</span><br><span class="line">        取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点</span><br></pre></td></tr></table></figure>

<h2 id="3-3-线程同步"><a href="#3-3-线程同步" class="headerlink" title="3.3 线程同步"></a>3.3 线程同步</h2><p>◼ 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：<strong>必须确保多个线程不会同时修改同一变量</strong>，或者某一线程不会读取正在由其他线程修改的变量</p>
<p>◼ 临界区是指访问某一共享资源的代码片段，这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应中断该片段的执行</p>
<p>◼ <strong>线程同步：当有一个线程在对内存进行操作时，其他线程都不可以对这个内存进行操作，直到该线程完成操作，其他线程才能对该内存进行操作（其他线程处于等待状态）</strong></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240124224829624.png" alt="image-20240124224829624"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">互斥量的类型 <span class="type">pthread_mutex_t</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">       - 初始化互斥量</span><br><span class="line">       - 参数 ：</span><br><span class="line">           - mutex ： 需要初始化的互斥量变量</span><br><span class="line">           - attr ： 互斥量相关的属性，<span class="literal">NULL</span></span><br><span class="line">       - <span class="keyword">restrict</span> : C语言的修饰符（被修饰的指针所指向的对象，不能再被另外的指针引用或操作）</span><br><span class="line">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex = xxx;</span><br><span class="line">           <span class="type">pthread_mutex_t</span> * mutex1 = mutex;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 释放互斥量的资源</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">       - 解锁</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>◼ 死锁的几种场景：</p>
<p>​	 忘记释放锁</p>
<p>​	 重复加锁 （常见于调用的两个函数都有加锁动作）</p>
<p>​	 多线程多锁，抢占锁资源</p>
<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件；</li>
<li>持有并等待条件；</li>
<li>不可剥夺条件；</li>
<li>环路等待条件；</li>
</ul>
<h3 id="互斥条件"><a href="#互斥条件" class="headerlink" title="#互斥条件"></a><a href="https://xiaolincoding.com/os/4_process/deadlock.html#%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6">#</a>互斥条件</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁的特点：</p>
<p>​	 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操		作</p>
<p>​	 如果有其它线程写数据，则其它线程都不允许读、写操作</p>
<p>​	 写是独占的，写的优先级高</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">读写锁的类型 <span class="type">pthread_rwlock_t</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   条件变量的类型 <span class="type">pthread_cond_t</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">       - 调用该函数，线程会阻塞，等待唤醒</span><br><span class="line"><span class="comment">// 当这个函数阻塞时，会对互斥锁解锁，当不阻塞时，会重新加锁</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">       - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span><br><span class="line">           </span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">       - 唤醒一个或多个等待（cond_wait）的线程</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">       - 唤醒所有的等待的线程</span><br></pre></td></tr></table></figure>

<p>信号量</p>
<p>为了防止多进程竞争共享资源，使得共享的资源，在任意时刻只能被一个进程访问</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存</p>
<p>信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">信号量的类型 <span class="type">sem_t</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">        - 初始化信号量</span><br><span class="line">        - 参数：</span><br><span class="line">            - sem : 信号量变量的地址</span><br><span class="line">            - pshared : <span class="number">0</span> 用在线程间 ，非<span class="number">0</span> 用在进程间</span><br><span class="line">            - value : 记录信号量中的值</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">        - 释放信号量资源</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">      - 对信号量加锁：调用一次对信号量的值<span class="number">-1</span>，如果值为<span class="number">0</span>，就阻塞</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">        - 对信号量解锁：调用一次对信号量的值+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者消费者模型</span></span><br><span class="line">    <span class="type">sem_t</span> psem;</span><br><span class="line">    <span class="type">sem_t</span> csem;</span><br><span class="line">    init(psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    init(csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    producer() &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        sem_post(&amp;csem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    customer() &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        sem_post(&amp;psem)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-Linux网络编程"><a href="#第四章-Linux网络编程" class="headerlink" title="第四章 Linux网络编程"></a>第四章 Linux网络编程</h1><h2 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h2><p>进程间网络通信的特殊文件类型（本质为内核借助缓冲区形成的伪文件）</p>
<p>上联应用进程，下联网络协议栈</p>
<p>由 IP 地址和端口结合</p>
<p>读写套接字和读写文件的操作一致，多用于网络进程间数据的传递</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>大端字节序：</p>
<ul>
<li>高位存在低地址，低位存在高地址</li>
<li>存放时顺序不变</li>
</ul>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240128114213324.png" alt="image-20240128114213324"></p>
<p>小端字节序：</p>
<ul>
<li>高位存放高地址，低位存放低地址</li>
<li>存放时顺序相反</li>
</ul>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240128114151163.png" alt="image-20240128114151163"></p>
<p>注：大多数机器是小端</p>
<p><strong>如何判断大小端？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> value ; <span class="comment">// 2bytes</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)]; <span class="comment">// char[2]</span></span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>]==<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);  <span class="comment">//高位在低地址处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节序转换函数</strong></p>
<p>不同字节序的主机之间传递数据：统一使用网络字节序–大端</p>
<p>发送端总是将数据转换成大端字节序发送，接受端根据自身情况决定是否需要转换（小端机转换）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序-网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序-主机字节序 </span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序-网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序-主机字节序 </span></span><br></pre></td></tr></table></figure>

<h2 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h2><p>本质是一个结构体，封装IP和端口号等信息（客户端与服务器通信，需要服务器的IP和Port）</p>
<ul>
<li>通用socket地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<p>sa_family 成员</p>
<p>​	用于指定协议类型</p>
<table>
<thead>
<tr>
<th><strong>协议族</strong></th>
<th><strong>地址族</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<p>sa_data 成员</p>
<p>​	用于存放socket地址</p>
<table>
<thead>
<tr>
<th><strong>协议族</strong></th>
<th><strong>地址值含义和长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达到108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16 bit 端口号和 32 bit IPv4 地址，共 6 字节</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID，共 26 字节</td>
</tr>
</tbody></table>
<p>Linux 定义了下面这个新的通用的 socket 地址结构体,这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">	<span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>专用socket地址</li>
</ul>
<p><img src="C:\Users\15093\AppData\Roaming\Typora\typora-user-images\image-20240131170102250.png" alt="image-20240131170102250"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin_family; <span class="comment">/*__SOCKADDR_COMMON(sin_) */</span></span><br><span class="line">	<span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line">	<span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -<span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ypedef <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure>

<p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</p>
<h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面(传出参数)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure>

<h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">				UDP 		TCP</span><br><span class="line">是否创建连接 		无连接 面向连接</span><br><span class="line">是否可靠 		不可靠 可靠的</span><br><span class="line">连接的对象个数 	一对一、一对多、多对一、多对多 支持一对一</span><br><span class="line">传输的方式 		面向数据报 面向字节流</span><br><span class="line">首部开销 		8个字节 最少20个字节</span><br><span class="line">适用场景 		实时应用（视频会议，直播） 可靠性高的应用（文件传输）</span><br><span class="line"></span><br><span class="line">UDP：面向无连接，不可靠，一对一、一对多和多对多，面向数据报，首部8个字节，适用于实时应用（如视频、直播）</span><br><span class="line">TCP：面向连接，可靠传输、一对一，基于字节流，首部至少20个字节，适用于可靠性高的场景（如文件传输）</span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\webserver\image-20240210121918330.png" alt="image-20240210121918330"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//tcp通信流程</span><br><span class="line">服务器端（被动接受）</span><br><span class="line">1、创建一个用于监听的套接字</span><br><span class="line">	-监听：是否有客户端连接</span><br><span class="line">	-fd：该套接字的文件描述符</span><br><span class="line">2、绑定IP和端口号（服务器自己的）</span><br><span class="line">	-客户端发起连接时需要知道这个IP和端口号</span><br><span class="line">3、设置监听，监听的fd开始工作</span><br><span class="line">4、阻塞等待，当有客户端发起连接时解除阻塞；服务器接受客户端的连接，返回一个用于通信的fd套接字</span><br><span class="line">5、通信</span><br><span class="line">	-接收数据</span><br><span class="line">	-发送数据</span><br><span class="line">6、通信结束，断开连接</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端（主动建立连接）</span><br><span class="line">1、创建一个用于通信的socket套接字（返回一个fd）</span><br><span class="line">2、连接服务器（指定服务器的IP和端口号）</span><br><span class="line">3、连接建立</span><br><span class="line">	-发送数据</span><br><span class="line">	-接收数据</span><br><span class="line">4、通信结束，断开连接</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>用来控制传输数据的吞吐量，解决发送方发送的数据量太大，而接收方接收的速度较慢，从而导致的丢包问题（实现流量控制、拥塞控制）</p>
<ul>
<li>窗口大小就是接收缓冲区的大小</li>
<li>窗口大小会不断变化</li>
<li>通信双方都有发送缓冲区和接收缓冲区</li>
</ul>
<h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">参数：</span><br><span class="line">- sockfd : 要操作的文件描述符</span><br><span class="line">- level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">- optname : 选项的名称</span><br><span class="line">	- SO_REUSEADDR</span><br><span class="line">	- SO_REUSEPORT</span><br><span class="line">- optval : 端口复用的值（整形）</span><br><span class="line">	- <span class="number">1</span> : 可以复用</span><br><span class="line">	- <span class="number">0</span> : 不可以复用</span><br><span class="line">- optlen : optval参数的大小</span><br><span class="line"></span><br><span class="line">端口复用设置的时机：在服务器绑定端口之前</span><br><span class="line">setsockop（）；</span><br><span class="line">bind（）；</span><br></pre></td></tr></table></figure>

<p>为什么需要端口复用:</p>
<p>​	服务器重启时，之前绑定的<strong>端口还未释放</strong> </p>
<p>​	程序突然退出，而系统没有释放端口</p>
<p>查看网络相关信息</p>
<p>netstat -apn</p>
<p>-a 所有的socket</p>
<p>-p 显示正在使用socket的程序名</p>
<p>-n 直接使用ip地址，而不通过域名服务器</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a><strong>IO多路复用</strong></h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>1 构造一个文件描述符列表（添加将要监听的文件描述符）</p>
<p>2 调用系统函数监听此列表，直到进行IO操作时函数返回</p>
<p>​	a 此函数阻塞</p>
<p>​	b 函数对文件描述符的检测操作由内核完成</p>
<p>3 返回时告诉进程有多少描述符要进行IO操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//sizeof(fd_set) =128字节  1024位</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);</span><br><span class="line">- 参数：</span><br><span class="line">	- nfds ： 需要检测的描述符数量+1</span><br><span class="line">	- readfds : 要检测的读文件描述符集合</span><br><span class="line">	- writefds : 要检测的写文件描述符集合</span><br><span class="line">		一般只检测读操作，对应对方发送过来的数据，传入传出参数</span><br><span class="line">	- exceptfds ：检测发生异常的文件描述符</span><br><span class="line">	- timeout : 设置的超时时间</span><br><span class="line">		struct timeval &#123;</span><br><span class="line">			long tv_sec;	/* seconds */</span><br><span class="line">			long tv_usec;	/* microseconds */</span><br><span class="line">		&#125;</span><br><span class="line">		NULL : 永久阻塞，直到检测到文件描述符变化</span><br><span class="line">		tv_sec = 0 tv_usec = 0 ： 不阻塞</span><br><span class="line">		tv_sec &gt; 0 tv_usec &gt; 0 : 阻塞相应的时间</span><br><span class="line">	- 返回值：</span><br><span class="line">		-1：失败</span><br><span class="line">		 n : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line">// 将fd对应的标志位 置为0</span><br><span class="line">void FD_CLR(int fd,fd_set *set);</span><br><span class="line"></span><br><span class="line">//将fd对应的标志位 置为1</span><br><span class="line">void FD_SET(int fd,fd_set *set);</span><br><span class="line"></span><br><span class="line">//判断fd对应的标志位是0（返回0），还是1（返回1） </span><br><span class="line">int FD_ISSET(int fd, fd_set *set); </span><br><span class="line"></span><br><span class="line">//将fd_set的1024bit，全部初始化为0</span><br><span class="line">void FD_ZERO（fd_set *set）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_posts\webserver\image-20240225123554728.png" alt="image-20240225123554728"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 设置监听文件描述符集合 reads</span></span><br><span class="line">fd_set reads;</span><br><span class="line"><span class="comment">//2 将已建立连接的fd标志位 置1（3，4,100,101）</span></span><br><span class="line">FD_SET(<span class="number">3</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">4</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">100</span>,&amp;reads);</span><br><span class="line">FD_SET(<span class="number">101</span>,&amp;reads);</span><br><span class="line"></span><br><span class="line">select(<span class="number">101</span> +<span class="number">1</span> ,&amp;reads,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="number">3</span> 将reads从用户态拷贝到内核态</span><br><span class="line"><span class="number">4</span> 在内核中遍历reads，看哪些fd为<span class="number">1</span>，并检测这些fd是否有数据</span><br><span class="line"><span class="number">5</span> 如果没有数据，重新将其置为<span class="number">0</span>，有数据仍保持<span class="number">1</span></span><br><span class="line"><span class="number">6</span> 将reads从内核态拷贝回用户态</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">7</span> 在用户态遍历哪些fd为<span class="number">1</span>，说明有数据可读（有事件发生）</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    read.../recv...</span><br><span class="line">&#125;</span><br><span class="line">判断是否为<span class="number">1</span></span><br><span class="line">    FD_ISSET(<span class="number">3</span>,&amp;reads);</span><br><span class="line"><span class="number">100</span>断开连接</span><br><span class="line">    FD_CLR(<span class="number">100</span>,&amp;reads);</span><br></pre></td></tr></table></figure>

<p>注：内核对传入的文件描述符表全部遍历，只有判断值为1的才会去检测这个文件描述符是否有数据</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240225144746090.png" alt="image-20240225144746090"></p>
<p>select的缺点：</p>
<p>1.每次调用select，都需要把fd集合从用 户态拷贝到内核态，这个开销在fd很多时 会很大 </p>
<p>2.同时每次调用select都需要在内核遍历 传递进来的所有fd，这个开销在fd很多时 也很大 </p>
<p>3.select支持的文件描述符数量太小了， 默认是1024 </p>
<p>4.fds集合不能重用，每次都需要重置</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><img src="D:\Blog\source_posts\webserver\image-20240225155110793.png" alt="image-20240225155110793"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">	<span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line">举例：</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">	myfd.fd = <span class="number">5</span>;</span><br><span class="line">	myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- fds : <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>结构体数组，需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">		- <span class="title">nfds</span> :</span> fds数组中最大有效元素的索引 + <span class="number">1</span></span><br><span class="line">		- timeout : 阻塞时长</span><br><span class="line">			<span class="number">0</span> : 不阻塞</span><br><span class="line">			<span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">			&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">	- 返回值：	</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure>

<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，<strong>取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制</strong>，当然还会受到系统文件描述符限制。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="D:\Blog\source_posts\webserver\image-20240225164741522.png" alt="image-20240225164741522"></p>
<p>epoll通过两个方面，很好的解决了select&#x2F;poll的问题</p>
<p>1 epoll在内核里使用<strong>红黑树</strong>来跟踪进程所有待检测的文件描述符，把需要监控的socket通过<strong>epoll_ctl(</strong>)函数加入内核的红黑树中（a.增删改高效，O（logn）b.减少了内核和用户态之间的数据拷贝和内存分配）</p>
<p>2 epoll是<strong>事件驱动机制</strong>，<strong>内核里维护一个链表来记录就绪事件</strong>，当某个socket有事件发生时，通过回调函数将其加入到就绪事件列表中（当用户调用epoll_wait()函数时，只返回有事件发生的文件描述符的个数）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发生改变的文件描述符的信息（双向链表）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">	size : 目前没有意义了，随便写一个大于<span class="number">0</span>的数</span><br><span class="line">- 返回值：</span><br><span class="line">	<span class="number">-1</span> : 失败</span><br><span class="line">	&gt; <span class="number">0</span> : 文件描述符，用来操作epoll实例</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,<span class="type">int</span> op,<span class="type">int</span> fd,<span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">-参数 ：</span><br><span class="line">    - epfd：epoll_create的返回值，epoll实例对应的文件描述符</span><br><span class="line">    - op ：需要进行的操作</span><br><span class="line">    	EPOLL_CTL_ADD: 添加</span><br><span class="line">        EPOLL_CTL_MOD: 修改</span><br><span class="line">        EPOLL_CTL_DEL: 删除</span><br><span class="line">    - fd : 要检测的文件描述符</span><br><span class="line">    - event : 检测文件描述符什么事情</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">        <span class="type">void</span>  *ptr;</span><br><span class="line">        <span class="type">int</span>  fd;</span><br><span class="line">        <span class="type">uint32_t</span> u32</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">    &#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">	- EPOLLIN</span><br><span class="line">	- EPOLLOUT</span><br><span class="line">	- EPOLLERR</span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">	- epfd : epoll实例对应的文件描述符</span><br><span class="line">	- events : 传出参数，保存了发生变化的文件描述符的信息</span><br><span class="line">	- maxevents : 第二个参数结构体数组的大小</span><br><span class="line">	- timeout : 阻塞时间</span><br><span class="line">		 <span class="number">0</span> : 不阻塞</span><br><span class="line">		 <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">		 &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">- 返回值：</span><br><span class="line">	- 成功，返回发生变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">    - 失败，返回 <span class="number">-1</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>Epoll 的工作模式：</p>
<p> LT 模式 （水平触发）</p>
<p> 假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知 </p>
<p>​	a.用户不读数据，数据一直在缓冲区，epoll 会一直通知</p>
<p>​	 b.用户只读了一部分数据，epoll会通知 </p>
<p>​	c.缓冲区的数据读完了，不通知 </p>
<p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这 种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操 作。如果你不作任何操作，内核还是会继续通知你的。</p>
<p>ET 模式（边沿触发） </p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区 读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p>
<p> a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</p>
<p> b.用户只读了一部分数据，epoll不通知</p>
<p> c.缓冲区的数据读完了，不通知 </p>
<p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述 符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成 未就绪），内核不会发送更多的通知（only once）。 </p>
<p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写 操作把处理多个文件描述符的任务饿死。</p>
<h1 id="第五章-项目实战"><a href="#第五章-项目实战" class="headerlink" title="第五章 项目实战"></a>第五章 项目实战</h1><h2 id="阻塞和非阻塞、同步-异步"><a href="#阻塞和非阻塞、同步-异步" class="headerlink" title="阻塞和非阻塞、同步&#x2F;异步"></a>阻塞和非阻塞、同步&#x2F;异步</h2><p><img src="D:\Blog\source_posts\webserver\阻塞、非阻塞、同步、异步.png" alt="阻塞、非阻塞、同步、异步"></p>
<p>同步io和异步io：本质是针对用户区层面而言的，阻塞io和非阻塞io都是同步io，当使用aio_read（）函数才是异步io；从数据角度看，同步io需要等待数据从内核拷贝到用户，异步io完全不需要等待，全程由内核自动完成，应用程序不需要主动发起拷贝动作</p>
<p>阻塞io：阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程<br>非阻塞io：不需要等待「内核数据准备好」，但需要等待「数据从内核态拷贝到用户态」</p>
<p>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。</p>
<h2 id="Unix-Linux上的五种IO模型"><a href="#Unix-Linux上的五种IO模型" class="headerlink" title="Unix&#x2F;Linux上的五种IO模型"></a>Unix&#x2F;Linux上的五种IO模型</h2><p>1 阻塞 blocking</p>
<p>2 非阻塞 non-blocking</p>
<p>3 IO复用 IO multiplexing</p>
<p>4 信号驱动 signal-driven</p>
<p>​	Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进 程收到SIGIO 信号，然后处理 IO 事件。</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240226220202694.png" alt="image-20240226220202694"></p>
<p>​	内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需 要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。 </p>
<p>5 异步 asynchronous</p>
<p><img src="D:\Blog\source_posts\webserver\image-20240226220315579.png" alt="image-20240226220315579"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> aio_fildes; <span class="comment">/* File desriptor. */</span></span><br><span class="line">	<span class="type">int</span> aio_lio_opcode; <span class="comment">/* Operation to be performed. */</span></span><br><span class="line">	<span class="type">int</span> aio_reqprio; <span class="comment">/* Request priority offset. */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">void</span> *aio_buf; <span class="comment">/* Location of buffer. */</span></span><br><span class="line">	<span class="type">size_t</span> aio_nbytes; <span class="comment">/* Length of transfer. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* Signal number and value. */</span></span><br><span class="line">	<span class="comment">/* Internal members. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> *__<span class="title">next_prio</span>;</span></span><br><span class="line">	<span class="type">int</span> __abs_prio;</span><br><span class="line">	<span class="type">int</span> __policy;</span><br><span class="line">	<span class="type">int</span> __error_code;</span><br><span class="line">	<span class="type">__ssize_t</span> __return_value;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">	<span class="type">__off_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line">	<span class="type">char</span> __pad[<span class="keyword">sizeof</span> (<span class="type">__off64_t</span>) - <span class="keyword">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">__off64_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="D:\Blog\source_posts\webserver\discuss_1682656246568.jpeg" alt="discuss_1682656246568"></p>
<p>Linux下有三种IO复用方式：epoll，select和poll，为什么用epoll，它和其他两个有什么区别呢？（参考StackOverflow上的一个问题：<a href="https://stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select">Why is epoll faster than select?</a>）</p>
<p><strong>文件描述符的添加地点、存储方式，检测事件发生的工作方式、文件描述符的操作模式（LT和ET模式）</strong></p>
<ul>
<li>对于select和poll来说，所有文件描述符都是<strong>在用户态被加入</strong>其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；<strong>epoll则将整个文件描述符集合维护在内核态</strong>，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，由于这些大量的系统调用开销epoll可能会慢于select和poll。</li>
<li><strong>select使用线性表</strong>描述文件描述符集合，文件描述符有上限；<strong>poll使用链表</strong>来描述；<strong>epoll底层通过红黑树</strong>来描述，并且<strong>维护一个ready list</strong>，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。</li>
<li>select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，<strong>当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符</strong>，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。</li>
<li>select和poll都只能工作在相对低效的LT模式下，而<strong>epoll同时支持LT和ET模式。</strong></li>
<li>综上，当监测的<strong>fd数量较小</strong>，且<strong>各个fd都很活跃的情况</strong>下，建议<strong>使用****select和poll</strong>；当监听的<strong>fd数量较</strong>多，且单位时间仅<strong>部分fd活跃</strong>的情况下，<strong>使用epoll</strong>会明显提升性能。</li>
</ul>
]]></content>
      <categories>
        <category>webserver</category>
      </categories>
  </entry>
</search>
